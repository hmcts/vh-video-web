/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:5800';
    }

    /**
     * @return Success
     */
    getAudioStreamInfo(hearingId: string): Observable<boolean> {
        let url_ = this.baseUrl + '/conferences/audiostreams/{hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAudioStreamInfo(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAudioStreamInfo(<any>response_);
                        } catch (e) {
                            return <Observable<boolean>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<boolean>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetAudioStreamInfo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    stopAudioRecording(hearingId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/audiostreams/{hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStopAudioRecording(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStopAudioRecording(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processStopAudioRecording(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Start or resume a video hearing
     * @param conferenceId conference id
     * @param body (optional) start hearing request details
     * @return Success
     */
    startOrResumeVideoHearing(conferenceId: string, body: StartHearingRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/start';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStartOrResumeVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStartOrResumeVideoHearing(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processStartOrResumeVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Pause a video hearing
     * @param conferenceId conference id
     * @return Success
     */
    pauseVideoHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/pause';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processPauseVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processPauseVideoHearing(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processPauseVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * End a video hearing
     * @param conferenceId conference id
     * @return Success
     */
    endVideoHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/end';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processEndVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processEndVideoHearing(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processEndVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Call a witness into a video hearing
     * @param conferenceId conference id
     * @param participantId witness id
     * @return Success
     */
    callWitness(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/call';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCallWitness(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCallWitness(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processCallWitness(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Call a witness into a video hearing
     * @param conferenceId conference id
     * @param participantId witness id
     * @return Success
     */
    dismissWitness(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/dismiss';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDismissWitness(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDismissWitness(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processDismissWitness(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get conferences today for a judge or a clerk
     * @return Success
     */
    getConferencesForJudge(): Observable<ConferenceForJudgeResponse[]> {
        let url_ = this.baseUrl + '/conferences/judges';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForJudge(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForJudge(<any>response_);
                        } catch (e) {
                            return <Observable<ConferenceForJudgeResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ConferenceForJudgeResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferencesForJudge(response: HttpResponseBase): Observable<ConferenceForJudgeResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForJudgeResponse.fromJS(item));
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForJudgeResponse[]>(<any>null);
    }

    /**
     * Get conferences today for individual or representative excluding those that have been closed for over 30 minutes
     * @return Success
     */
    getConferencesForIndividual(): Observable<ConferenceForIndividualResponse[]> {
        let url_ = this.baseUrl + '/conferences/individuals';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForIndividual(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForIndividual(<any>response_);
                        } catch (e) {
                            return <Observable<ConferenceForIndividualResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ConferenceForIndividualResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferencesForIndividual(response: HttpResponseBase): Observable<ConferenceForIndividualResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForIndividualResponse.fromJS(item));
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForIndividualResponse[]>(<any>null);
    }

    /**
     * Get conferences for user
     * @param userNames (optional)
     * @return Success
     */
    getConferencesForVhOfficer(userNames: string[] | undefined): Observable<ConferenceForVhOfficerResponse[]> {
        let url_ = this.baseUrl + '/conferences/vhofficer?';
        if (userNames === null) throw new Error("The parameter 'userNames' cannot be null.");
        else if (userNames !== undefined)
            userNames &&
                userNames.forEach(item => {
                    url_ += 'UserNames=' + encodeURIComponent('' + item) + '&';
                });
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForVhOfficer(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForVhOfficer(<any>response_);
                        } catch (e) {
                            return <Observable<ConferenceForVhOfficerResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ConferenceForVhOfficerResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferencesForVhOfficer(response: HttpResponseBase): Observable<ConferenceForVhOfficerResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForVhOfficerResponse.fromJS(item));
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result401: any = null;
                    let resultData401 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result401 = ProblemDetails.fromJS(resultData401);
                    return throwException('Unauthorized', status, _responseText, _headers, result401);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForVhOfficerResponse[]>(<any>null);
    }

    /**
     * Get the details of a conference by id for VH officer
     * @param conferenceId The unique id of the conference
     * @return Success
     */
    getConferenceByIdVHO(conferenceId: string): Observable<ConferenceResponseVho> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/vhofficer';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceByIdVHO(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceByIdVHO(<any>response_);
                        } catch (e) {
                            return <Observable<ConferenceResponseVho>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ConferenceResponseVho>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferenceByIdVHO(response: HttpResponseBase): Observable<ConferenceResponseVho> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceResponseVho.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceResponseVho>(<any>null);
    }

    /**
     * Get the details of a conference by id
     * @param conferenceId The unique id of the conference
     * @return Success
     */
    getConferenceById(conferenceId: string): Observable<ConferenceResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceById(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceById(<any>response_);
                        } catch (e) {
                            return <Observable<ConferenceResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ConferenceResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferenceById(response: HttpResponseBase): Observable<ConferenceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceResponse>(<any>null);
    }

    /**
     * GetClientConfigurationSettings the configuration settings for client
     * @return Success
     */
    getClientConfigurationSettings(): Observable<ClientSettingsResponse> {
        let url_ = this.baseUrl + '/config';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetClientConfigurationSettings(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetClientConfigurationSettings(<any>response_);
                        } catch (e) {
                            return <Observable<ClientSettingsResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ClientSettingsResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetClientConfigurationSettings(response: HttpResponseBase): Observable<ClientSettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ClientSettingsResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ClientSettingsResponse.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ClientSettingsResponse>(<any>null);
    }

    /**
     * Raise or answer to a private consultation request with another participant
     * @param body (optional) Private consultation request with or without an answer
     * @return Success
     */
    handleConsultationRequest(body: PrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processHandleConsultationRequest(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processHandleConsultationRequest(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processHandleConsultationRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = BadRequestModelResponse.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    leavePrivateConsultation(body: LeavePrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/leave';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLeavePrivateConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLeavePrivateConsultation(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processLeavePrivateConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    respondToAdminConsultationRequest(body: PrivateAdminConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/vhofficer/respond';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processRespondToAdminConsultationRequest(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processRespondToAdminConsultationRequest(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processRespondToAdminConsultationRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    callVideoEndpoint(body: PrivateVideoEndpointConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/video-endpoint';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCallVideoEndpoint(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCallVideoEndpoint(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processCallVideoEndpoint(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    startOrJoinConsultation(body: StartPrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/start';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStartOrJoinConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStartOrJoinConsultation(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processStartOrJoinConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    leaveConsultation(body: LeavePrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/end';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLeaveConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLeaveConsultation(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processLeaveConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getVideoEndpointsForConference(conferenceId: string): Observable<VideoEndpointResponse[]> {
        let url_ = this.baseUrl + '/{conferenceId}/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetVideoEndpointsForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetVideoEndpointsForConference(<any>response_);
                        } catch (e) {
                            return <Observable<VideoEndpointResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<VideoEndpointResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetVideoEndpointsForConference(response: HttpResponseBase): Observable<VideoEndpointResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(VideoEndpointResponse.fromJS(item));
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<VideoEndpointResponse[]>(<any>null);
    }

    /**
     * Check Service Health
     * @return Success
     */
    checkServiceHealth(): Observable<HealthCheckResponse> {
        let url_ = this.baseUrl + '/HealthCheck/health';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCheckServiceHealth(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCheckServiceHealth(<any>response_);
                        } catch (e) {
                            return <Observable<HealthCheckResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<HealthCheckResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processCheckServiceHealth(response: HttpResponseBase): Observable<HealthCheckResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HealthCheckResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = HealthCheckResponse.fromJS(resultData500);
                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HealthCheckResponse>(<any>null);
    }

    /**
     * Get all the instant messages for a conference for a participant
     * @param conferenceId Id of the conference
     * @param participantUsername the participant in the conference
     * @return Success
     */
    getConferenceInstantMessageHistoryForParticipant(conferenceId: string, participantUsername: string): Observable<ChatResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/participant/{participantUsername}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantUsername === undefined || participantUsername === null)
            throw new Error("The parameter 'participantUsername' must be defined.");
        url_ = url_.replace('{participantUsername}', encodeURIComponent('' + participantUsername));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceInstantMessageHistoryForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceInstantMessageHistoryForParticipant(<any>response_);
                        } catch (e) {
                            return <Observable<ChatResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ChatResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferenceInstantMessageHistoryForParticipant(response: HttpResponseBase): Observable<ChatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ChatResponse.fromJS(item));
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ChatResponse[]>(<any>null);
    }

    /**
     * Get number of unread messages for vho
     * @param conferenceId Id of the conference
     * @return Success
     */
    getNumberOfUnreadAdminMessagesForConference(conferenceId: string): Observable<UnreadInstantMessageConferenceCountResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/unread/vho';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetNumberOfUnreadAdminMessagesForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetNumberOfUnreadAdminMessagesForConference(<any>response_);
                        } catch (e) {
                            return <Observable<UnreadInstantMessageConferenceCountResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<UnreadInstantMessageConferenceCountResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetNumberOfUnreadAdminMessagesForConference(
        response: HttpResponseBase
    ): Observable<UnreadInstantMessageConferenceCountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UnreadInstantMessageConferenceCountResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UnreadInstantMessageConferenceCountResponse>(<any>null);
    }

    /**
     * Get number of unread messages for a participant
     * @param conferenceId Id of the conference
     * @param participantUsername the participant in the conference
     * @return Success
     */
    getNumberOfUnreadAdminMessagesForConferenceByParticipant(
        conferenceId: string,
        participantUsername: string
    ): Observable<UnreadAdminMessageResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/unread/participant/{participantUsername}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantUsername === undefined || participantUsername === null)
            throw new Error("The parameter 'participantUsername' must be defined.");
        url_ = url_.replace('{participantUsername}', encodeURIComponent('' + participantUsername));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(<any>response_);
                        } catch (e) {
                            return <Observable<UnreadAdminMessageResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<UnreadAdminMessageResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(
        response: HttpResponseBase
    ): Observable<UnreadAdminMessageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UnreadAdminMessageResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UnreadAdminMessageResponse>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    addMediaEventToConference(conferenceId: string, body: AddMediaEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/mediaevents';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddMediaEventToConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddMediaEventToConference(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processAddMediaEventToConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    addSelfTestFailureEventToConference(conferenceId: string, body: AddSelfTestFailureEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/selftestfailureevents';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddSelfTestFailureEventToConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddSelfTestFailureEventToConference(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processAddSelfTestFailureEventToConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getTestCallResult(conferenceId: string, participantId: string): Observable<TestCallScoreResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants/{participantId}/selftestresult';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTestCallResult(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTestCallResult(<any>response_);
                        } catch (e) {
                            return <Observable<TestCallScoreResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TestCallScoreResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetTestCallResult(response: HttpResponseBase): Observable<TestCallScoreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TestCallScoreResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TestCallScoreResponse>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updateParticipantStatus(conferenceId: string, body: UpdateParticipantStatusEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participantstatus';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateParticipantStatus(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateParticipantStatus(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processUpdateParticipantStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param participantId (optional)
     * @return Success
     */
    getIndependentTestCallResult(participantId: string | undefined): Observable<TestCallScoreResponse> {
        let url_ = this.baseUrl + '/conferences/independentselftestresult?';
        if (participantId === null) throw new Error("The parameter 'participantId' cannot be null.");
        else if (participantId !== undefined) url_ += 'participantId=' + encodeURIComponent('' + participantId) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetIndependentTestCallResult(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetIndependentTestCallResult(<any>response_);
                        } catch (e) {
                            return <Observable<TestCallScoreResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TestCallScoreResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetIndependentTestCallResult(response: HttpResponseBase): Observable<TestCallScoreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TestCallScoreResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TestCallScoreResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getHeartbeatDataForParticipant(conferenceId: string, participantId: string): Observable<ParticipantHeartbeatResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/heartbeatrecent';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHeartbeatDataForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHeartbeatDataForParticipant(<any>response_);
                        } catch (e) {
                            return <Observable<ParticipantHeartbeatResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ParticipantHeartbeatResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetHeartbeatDataForParticipant(response: HttpResponseBase): Observable<ParticipantHeartbeatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantHeartbeatResponse.fromJS(item));
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantHeartbeatResponse[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updateParticipantDisplayName(
        conferenceId: string,
        participantId: string,
        body: UpdateParticipantRequest | undefined
    ): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants/{participantId}/participantDisplayName';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateParticipantDisplayName(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateParticipantDisplayName(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processUpdateParticipantDisplayName(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get the participant details of a conference by id for VH officer
     * @param conferenceId The unique id of the conference
     * @return Success
     */
    getParticipantsWithContactDetailsByConferenceId(conferenceId: string): Observable<ParticipantContactDetailsResponseVho[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/vhofficer/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetParticipantsWithContactDetailsByConferenceId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetParticipantsWithContactDetailsByConferenceId(<any>response_);
                        } catch (e) {
                            return <Observable<ParticipantContactDetailsResponseVho[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ParticipantContactDetailsResponseVho[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetParticipantsWithContactDetailsByConferenceId(
        response: HttpResponseBase
    ): Observable<ParticipantContactDetailsResponseVho[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantContactDetailsResponseVho.fromJS(item));
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantContactDetailsResponseVho[]>(<any>null);
    }

    /**
     * @return Success
     */
    getParticipantsByConferenceId(conferenceId: string): Observable<ParticipantForUserResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetParticipantsByConferenceId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetParticipantsByConferenceId(<any>response_);
                        } catch (e) {
                            return <Observable<ParticipantForUserResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ParticipantForUserResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetParticipantsByConferenceId(response: HttpResponseBase): Observable<ParticipantForUserResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantForUserResponse.fromJS(item));
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantForUserResponse[]>(<any>null);
    }

    /**
     * Get profile for logged in user
     * @return Success
     */
    getUserProfile(): Observable<UserProfileResponse> {
        let url_ = this.baseUrl + '/profile';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUserProfile(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUserProfile(<any>response_);
                        } catch (e) {
                            return <Observable<UserProfileResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<UserProfileResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<UserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UserProfileResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UserProfileResponse>(<any>null);
    }

    /**
     * Get profile for username
     * @param username (optional)
     * @return Success
     */
    getProfileByUsername(username: string | undefined): Observable<UserProfileResponse> {
        let url_ = this.baseUrl + '/profile/query?';
        if (username === null) throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined) url_ += 'username=' + encodeURIComponent('' + username) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetProfileByUsername(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetProfileByUsername(<any>response_);
                        } catch (e) {
                            return <Observable<UserProfileResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<UserProfileResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetProfileByUsername(response: HttpResponseBase): Observable<UserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UserProfileResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UserProfileResponse>(<any>null);
    }

    /**
     * Get the Pexip self test node.
     * @return Success
     */
    getPexipConfig(): Observable<SelfTestPexipResponse> {
        let url_ = this.baseUrl + '/selftest';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetPexipConfig(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetPexipConfig(<any>response_);
                        } catch (e) {
                            return <Observable<SelfTestPexipResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<SelfTestPexipResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetPexipConfig(response: HttpResponseBase): Observable<SelfTestPexipResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = SelfTestPexipResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<SelfTestPexipResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getTasks(conferenceId: string): Observable<TaskResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/tasks';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTasks(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTasks(<any>response_);
                        } catch (e) {
                            return <Observable<TaskResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TaskResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetTasks(response: HttpResponseBase): Observable<TaskResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(TaskResponse.fromJS(item));
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TaskResponse[]>(<any>null);
    }

    /**
     * Update existing tasks
     * @param conferenceId The id of the conference to update
     * @param taskId The id of the task to update
     * @return Success
     */
    completeTask(conferenceId: string, taskId: number): Observable<TaskResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/tasks/{taskId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (taskId === undefined || taskId === null) throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace('{taskId}', encodeURIComponent('' + taskId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('patch', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCompleteTask(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCompleteTask(<any>response_);
                        } catch (e) {
                            return <Observable<TaskResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TaskResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processCompleteTask(response: HttpResponseBase): Observable<TaskResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TaskResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TaskResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getSelfTestToken(participantId: string): Observable<TokenResponse> {
        let url_ = this.baseUrl + '/participants/{participantId}/selftesttoken';
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetSelfTestToken(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetSelfTestToken(<any>response_);
                        } catch (e) {
                            return <Observable<TokenResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TokenResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetSelfTestToken(response: HttpResponseBase): Observable<TokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TokenResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TokenResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getJwtoken(participantId: string): Observable<TokenResponse> {
        let url_ = this.baseUrl + '/participants/{participantId}/jwtoken';
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetJwtoken(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetJwtoken(<any>response_);
                        } catch (e) {
                            return <Observable<TokenResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TokenResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetJwtoken(response: HttpResponseBase): Observable<TokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TokenResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TokenResponse>(<any>null);
    }

    /**
     * Get Court rooms accounts (judges)
     * @param userNames (optional)
     * @return Success
     */
    getCourtRoomAccounts(userNames: string[] | undefined): Observable<CourtRoomsAccountResponse[]> {
        let url_ = this.baseUrl + '/api/accounts/courtrooms?';
        if (userNames === null) throw new Error("The parameter 'userNames' cannot be null.");
        else if (userNames !== undefined)
            userNames &&
                userNames.forEach(item => {
                    url_ += 'UserNames=' + encodeURIComponent('' + item) + '&';
                });
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCourtRoomAccounts(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCourtRoomAccounts(<any>response_);
                        } catch (e) {
                            return <Observable<CourtRoomsAccountResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<CourtRoomsAccountResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetCourtRoomAccounts(response: HttpResponseBase): Observable<CourtRoomsAccountResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(CourtRoomsAccountResponse.fromJS(item));
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<CourtRoomsAccountResponse[]>(<any>null);
    }

    /**
     * Get Judge names
     * @return Success
     */
    getDistinctJudgeNames(): Observable<JudgeNameListResponse> {
        let url_ = this.baseUrl + '/hearing-venues';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetDistinctJudgeNames(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetDistinctJudgeNames(<any>response_);
                        } catch (e) {
                            return <Observable<JudgeNameListResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<JudgeNameListResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetDistinctJudgeNames(response: HttpResponseBase): Observable<JudgeNameListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = JudgeNameListResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<JudgeNameListResponse>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    sendEvent(body: ConferenceEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/callback';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSendEvent(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSendEvent(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processSendEvent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    readonly extensions?: { [key: string]: any } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data['type'];
            this.title = _data['title'];
            this.status = _data['status'];
            this.detail = _data['detail'];
            this.instance = _data['instance'];
            if (_data['extensions']) {
                (<any>this).extensions = {} as any;
                for (let key in _data['extensions']) {
                    if (_data['extensions'].hasOwnProperty(key)) (<any>this).extensions![key] = _data['extensions'][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['type'] = this.type;
        data['title'] = this.title;
        data['status'] = this.status;
        data['detail'] = this.detail;
        data['instance'] = this.instance;
        if (this.extensions) {
            data['extensions'] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key)) data['extensions'][key] = this.extensions[key];
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any } | undefined;
}

export enum HearingLayout {
    Dynamic = 'Dynamic',
    OnePlus7 = 'OnePlus7',
    TwoPlus21 = 'TwoPlus21'
}

export class StartHearingRequest implements IStartHearingRequest {
    layout?: HearingLayout | undefined;

    constructor(data?: IStartHearingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layout = _data['layout'];
        }
    }

    static fromJS(data: any): StartHearingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartHearingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['layout'] = this.layout;
        return data;
    }
}

export interface IStartHearingRequest {
    layout?: HearingLayout | undefined;
}

export enum ConferenceStatus {
    NotStarted = 'NotStarted',
    InSession = 'InSession',
    Paused = 'Paused',
    Suspended = 'Suspended',
    Closed = 'Closed'
}

export enum Role {
    None = 'None',
    CaseAdmin = 'CaseAdmin',
    VideoHearingsOfficer = 'VideoHearingsOfficer',
    HearingFacilitationSupport = 'HearingFacilitationSupport',
    Judge = 'Judge',
    Individual = 'Individual',
    Representative = 'Representative',
    JudicialOfficeHolder = 'JudicialOfficeHolder'
}

export class ParticipantForJudgeResponse implements IParticipantForJudgeResponse {
    display_name?: string | undefined;
    /** The participant user role in conference */
    role?: Role;
    /** The representee (if participant is a representative) */
    representee?: string | undefined;
    case_type_group?: string | undefined;
    hearing_role?: string | undefined;

    constructor(data?: IParticipantForJudgeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.display_name = _data['display_name'];
            this.role = _data['role'];
            this.representee = _data['representee'];
            this.case_type_group = _data['case_type_group'];
            this.hearing_role = _data['hearing_role'];
        }
    }

    static fromJS(data: any): ParticipantForJudgeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantForJudgeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['display_name'] = this.display_name;
        data['role'] = this.role;
        data['representee'] = this.representee;
        data['case_type_group'] = this.case_type_group;
        data['hearing_role'] = this.hearing_role;
        return data;
    }
}

export interface IParticipantForJudgeResponse {
    display_name?: string | undefined;
    /** The participant user role in conference */
    role?: Role;
    /** The representee (if participant is a representative) */
    representee?: string | undefined;
    case_type_group?: string | undefined;
    hearing_role?: string | undefined;
}

export class ConferenceForJudgeResponse implements IConferenceForJudgeResponse {
    /** Conference UUID */
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference status */
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForJudgeResponse[] | undefined;
    number_of_endpoints?: number;

    constructor(data?: IConferenceForJudgeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantForJudgeResponse.fromJS(item));
            }
            this.number_of_endpoints = _data['number_of_endpoints'];
        }
    }

    static fromJS(data: any): ConferenceForJudgeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForJudgeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['number_of_endpoints'] = this.number_of_endpoints;
        return data;
    }
}

export interface IConferenceForJudgeResponse {
    /** Conference UUID */
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference status */
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForJudgeResponse[] | undefined;
    number_of_endpoints?: number;
}

export class ConferenceForIndividualResponse implements IConferenceForIndividualResponse {
    /** Conference UUID */
    id?: string;
    scheduled_date_time?: Date;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference status */
    status?: ConferenceStatus;
    closed_date_time?: Date | undefined;

    constructor(data?: IConferenceForIndividualResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConferenceForIndividualResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForIndividualResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        return data;
    }
}

export interface IConferenceForIndividualResponse {
    /** Conference UUID */
    id?: string;
    scheduled_date_time?: Date;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference status */
    status?: ConferenceStatus;
    closed_date_time?: Date | undefined;
}

export enum ParticipantStatus {
    None = 'None',
    NotSignedIn = 'NotSignedIn',
    UnableToJoin = 'UnableToJoin',
    Joining = 'Joining',
    Available = 'Available',
    InHearing = 'InHearing',
    InConsultation = 'InConsultation',
    Disconnected = 'Disconnected'
}

export class ParticipantForUserResponse implements IParticipantForUserResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    hearing_role?: string | undefined;

    constructor(data?: IParticipantForUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.username = _data['username'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.case_type_group = _data['case_type_group'];
            this.representee = _data['representee'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.hearing_role = _data['hearing_role'];
        }
    }

    static fromJS(data: any): ParticipantForUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantForUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['username'] = this.username;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['case_type_group'] = this.case_type_group;
        data['representee'] = this.representee;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['hearing_role'] = this.hearing_role;
        return data;
    }
}

export interface IParticipantForUserResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    hearing_role?: string | undefined;
}

export class ConferenceForVhOfficerResponse implements IConferenceForVhOfficerResponse {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    scheduled_duration?: number;
    /** The current conference status */
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForUserResponse[] | undefined;
    hearing_venue_name?: string | undefined;
    started_date_time?: Date | undefined;
    closed_date_time?: Date | undefined;
    telephone_conference_id?: string | undefined;
    telephone_conference_number?: string | undefined;
    created_date_time?: Date | undefined;

    constructor(data?: IConferenceForVhOfficerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.scheduled_duration = _data['scheduled_duration'];
            this.status = _data['status'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantForUserResponse.fromJS(item));
            }
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.started_date_time = _data['started_date_time'] ? new Date(_data['started_date_time'].toString()) : <any>undefined;
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.telephone_conference_id = _data['telephone_conference_id'];
            this.telephone_conference_number = _data['telephone_conference_number'];
            this.created_date_time = _data['created_date_time'] ? new Date(_data['created_date_time'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConferenceForVhOfficerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForVhOfficerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['scheduled_duration'] = this.scheduled_duration;
        data['status'] = this.status;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['started_date_time'] = this.started_date_time ? this.started_date_time.toISOString() : <any>undefined;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['telephone_conference_id'] = this.telephone_conference_id;
        data['telephone_conference_number'] = this.telephone_conference_number;
        data['created_date_time'] = this.created_date_time ? this.created_date_time.toISOString() : <any>undefined;
        return data;
    }
}

export interface IConferenceForVhOfficerResponse {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    scheduled_duration?: number;
    /** The current conference status */
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForUserResponse[] | undefined;
    hearing_venue_name?: string | undefined;
    started_date_time?: Date | undefined;
    closed_date_time?: Date | undefined;
    telephone_conference_id?: string | undefined;
    telephone_conference_number?: string | undefined;
    created_date_time?: Date | undefined;
}

/** Information about a participant in a conference */
export class ParticipantResponseVho implements IParticipantResponseVho {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    hearing_role?: string | undefined;

    constructor(data?: IParticipantResponseVho) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.username = _data['username'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.case_type_group = _data['case_type_group'];
            this.representee = _data['representee'];
            this.hearing_role = _data['hearing_role'];
        }
    }

    static fromJS(data: any): ParticipantResponseVho {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantResponseVho();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['username'] = this.username;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['case_type_group'] = this.case_type_group;
        data['representee'] = this.representee;
        data['hearing_role'] = this.hearing_role;
        return data;
    }
}

/** Information about a participant in a conference */
export interface IParticipantResponseVho {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    hearing_role?: string | undefined;
}

/** Detailed information about a conference for VHO officer */
export class ConferenceResponseVho implements IConferenceResponseVho {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference Status */
    status?: ConferenceStatus;
    admin_i_frame_uri?: string | undefined;
    participant_uri?: string | undefined;
    pexip_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponseVho[] | undefined;
    closed_date_time?: Date | undefined;
    hearing_venue_name?: string | undefined;

    constructor(data?: IConferenceResponseVho) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.admin_i_frame_uri = _data['admin_i_frame_uri'];
            this.participant_uri = _data['participant_uri'];
            this.pexip_node_uri = _data['pexip_node_uri'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantResponseVho.fromJS(item));
            }
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.hearing_venue_name = _data['hearing_venue_name'];
        }
    }

    static fromJS(data: any): ConferenceResponseVho {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceResponseVho();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['admin_i_frame_uri'] = this.admin_i_frame_uri;
        data['participant_uri'] = this.participant_uri;
        data['pexip_node_uri'] = this.pexip_node_uri;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['hearing_venue_name'] = this.hearing_venue_name;
        return data;
    }
}

/** Detailed information about a conference for VHO officer */
export interface IConferenceResponseVho {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference Status */
    status?: ConferenceStatus;
    admin_i_frame_uri?: string | undefined;
    participant_uri?: string | undefined;
    pexip_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponseVho[] | undefined;
    closed_date_time?: Date | undefined;
    hearing_venue_name?: string | undefined;
}

/** Information about a participant in a conference */
export class ParticipantResponse implements IParticipantResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    hearing_role?: string | undefined;

    constructor(data?: IParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.username = _data['username'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.case_type_group = _data['case_type_group'];
            this.representee = _data['representee'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.hearing_role = _data['hearing_role'];
        }
    }

    static fromJS(data: any): ParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['username'] = this.username;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['case_type_group'] = this.case_type_group;
        data['representee'] = this.representee;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['hearing_role'] = this.hearing_role;
        return data;
    }
}

/** Information about a participant in a conference */
export interface IParticipantResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    hearing_role?: string | undefined;
}

export enum EndpointStatus {
    NotYetJoined = 'NotYetJoined',
    Connected = 'Connected',
    Disconnected = 'Disconnected',
    InConsultation = 'InConsultation'
}

export class VideoEndpointResponse implements IVideoEndpointResponse {
    /** The endpoint id */
    id?: string;
    display_name?: string | undefined;
    /** The current endpoint status */
    status?: EndpointStatus;
    defence_advocate_username?: string | undefined;
    pexip_display_name?: string | undefined;

    constructor(data?: IVideoEndpointResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.display_name = _data['display_name'];
            this.status = _data['status'];
            this.defence_advocate_username = _data['defence_advocate_username'];
            this.pexip_display_name = _data['pexip_display_name'];
        }
    }

    static fromJS(data: any): VideoEndpointResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VideoEndpointResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['display_name'] = this.display_name;
        data['status'] = this.status;
        data['defence_advocate_username'] = this.defence_advocate_username;
        data['pexip_display_name'] = this.pexip_display_name;
        return data;
    }
}

export interface IVideoEndpointResponse {
    /** The endpoint id */
    id?: string;
    display_name?: string | undefined;
    /** The current endpoint status */
    status?: EndpointStatus;
    defence_advocate_username?: string | undefined;
    pexip_display_name?: string | undefined;
}

/** Detailed information about a conference */
export class ConferenceResponse implements IConferenceResponse {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference Status */
    status?: ConferenceStatus;
    participant_uri?: string | undefined;
    pexip_node_uri?: string | undefined;
    pexip_self_test_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponse[] | undefined;
    closed_date_time?: Date | undefined;
    hearing_venue_name?: string | undefined;
    audio_recording_required?: boolean;
    hearing_ref_id?: string;
    /** The video access endpoints in the conference */
    endpoints?: VideoEndpointResponse[] | undefined;

    constructor(data?: IConferenceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.participant_uri = _data['participant_uri'];
            this.pexip_node_uri = _data['pexip_node_uri'];
            this.pexip_self_test_node_uri = _data['pexip_self_test_node_uri'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantResponse.fromJS(item));
            }
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.audio_recording_required = _data['audio_recording_required'];
            this.hearing_ref_id = _data['hearing_ref_id'];
            if (Array.isArray(_data['endpoints'])) {
                this.endpoints = [] as any;
                for (let item of _data['endpoints']) this.endpoints!.push(VideoEndpointResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConferenceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['participant_uri'] = this.participant_uri;
        data['pexip_node_uri'] = this.pexip_node_uri;
        data['pexip_self_test_node_uri'] = this.pexip_self_test_node_uri;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['audio_recording_required'] = this.audio_recording_required;
        data['hearing_ref_id'] = this.hearing_ref_id;
        if (Array.isArray(this.endpoints)) {
            data['endpoints'] = [];
            for (let item of this.endpoints) data['endpoints'].push(item.toJSON());
        }
        return data;
    }
}

/** Detailed information about a conference */
export interface IConferenceResponse {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference Status */
    status?: ConferenceStatus;
    participant_uri?: string | undefined;
    pexip_node_uri?: string | undefined;
    pexip_self_test_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponse[] | undefined;
    closed_date_time?: Date | undefined;
    hearing_venue_name?: string | undefined;
    audio_recording_required?: boolean;
    hearing_ref_id?: string;
    /** The video access endpoints in the conference */
    endpoints?: VideoEndpointResponse[] | undefined;
}

/** Configuration to initialise the UI application */
export class ClientSettingsResponse implements IClientSettingsResponse {
    tenant_id?: string | undefined;
    client_id?: string | undefined;
    redirect_uri?: string | undefined;
    post_logout_redirect_uri?: string | undefined;
    video_api_url?: string | undefined;
    app_insights_instrumentation_key?: string | undefined;
    event_hub_path?: string | undefined;
    join_by_phone_from_date?: string | undefined;

    constructor(data?: IClientSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenant_id = _data['tenant_id'];
            this.client_id = _data['client_id'];
            this.redirect_uri = _data['redirect_uri'];
            this.post_logout_redirect_uri = _data['post_logout_redirect_uri'];
            this.video_api_url = _data['video_api_url'];
            this.app_insights_instrumentation_key = _data['app_insights_instrumentation_key'];
            this.event_hub_path = _data['event_hub_path'];
            this.join_by_phone_from_date = _data['join_by_phone_from_date'];
        }
    }

    static fromJS(data: any): ClientSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['tenant_id'] = this.tenant_id;
        data['client_id'] = this.client_id;
        data['redirect_uri'] = this.redirect_uri;
        data['post_logout_redirect_uri'] = this.post_logout_redirect_uri;
        data['video_api_url'] = this.video_api_url;
        data['app_insights_instrumentation_key'] = this.app_insights_instrumentation_key;
        data['event_hub_path'] = this.event_hub_path;
        data['join_by_phone_from_date'] = this.join_by_phone_from_date;
        return data;
    }
}

/** Configuration to initialise the UI application */
export interface IClientSettingsResponse {
    tenant_id?: string | undefined;
    client_id?: string | undefined;
    redirect_uri?: string | undefined;
    post_logout_redirect_uri?: string | undefined;
    video_api_url?: string | undefined;
    app_insights_instrumentation_key?: string | undefined;
    event_hub_path?: string | undefined;
    join_by_phone_from_date?: string | undefined;
}

export enum ConsultationAnswer {
    None = 'None',
    Accepted = 'Accepted',
    Rejected = 'Rejected',
    Cancelled = 'Cancelled',
    Failed = 'Failed',
    NoRoomsAvailable = 'NoRoomsAvailable'
}

/** Raise or respond to a private consultation request */
export class PrivateConsultationRequest implements IPrivateConsultationRequest {
    conference_id?: string;
    requested_by_id?: string;
    requested_for_id?: string;
    /** Consultation Answer (absent value is treated as raising a consultation request) */
    answer?: ConsultationAnswer | undefined;

    constructor(data?: IPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.requested_by_id = _data['requested_by_id'];
            this.requested_for_id = _data['requested_for_id'];
            this.answer = _data['answer'];
        }
    }

    static fromJS(data: any): PrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['requested_by_id'] = this.requested_by_id;
        data['requested_for_id'] = this.requested_for_id;
        data['answer'] = this.answer;
        return data;
    }
}

/** Raise or respond to a private consultation request */
export interface IPrivateConsultationRequest {
    conference_id?: string;
    requested_by_id?: string;
    requested_for_id?: string;
    /** Consultation Answer (absent value is treated as raising a consultation request) */
    answer?: ConsultationAnswer | undefined;
}

export class BadModel implements IBadModel {
    title?: string | undefined;
    errors?: string[] | undefined;

    constructor(data?: IBadModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data['title'];
            if (Array.isArray(_data['errors'])) {
                this.errors = [] as any;
                for (let item of _data['errors']) this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): BadModel {
        data = typeof data === 'object' ? data : {};
        let result = new BadModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['title'] = this.title;
        if (Array.isArray(this.errors)) {
            data['errors'] = [];
            for (let item of this.errors) data['errors'].push(item);
        }
        return data;
    }
}

export interface IBadModel {
    title?: string | undefined;
    errors?: string[] | undefined;
}

export class BadRequestModelResponse implements IBadRequestModelResponse {
    readonly errors?: BadModel[] | undefined;

    constructor(data?: IBadRequestModelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['errors'])) {
                (<any>this).errors = [] as any;
                for (let item of _data['errors']) (<any>this).errors!.push(BadModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BadRequestModelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BadRequestModelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data['errors'] = [];
            for (let item of this.errors) data['errors'].push(item.toJSON());
        }
        return data;
    }
}

export interface IBadRequestModelResponse {
    errors?: BadModel[] | undefined;
}

/** Leave a private consultation */
export class LeavePrivateConsultationRequest implements ILeavePrivateConsultationRequest {
    conference_id?: string;
    participant_id?: string;

    constructor(data?: ILeavePrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
        }
    }

    static fromJS(data: any): LeavePrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        return data;
    }
}

/** Leave a private consultation */
export interface ILeavePrivateConsultationRequest {
    conference_id?: string;
    participant_id?: string;
}

export enum RoomType {
    WaitingRoom = 'WaitingRoom',
    HearingRoom = 'HearingRoom',
    ConsultationRoom1 = 'ConsultationRoom1',
    ConsultationRoom2 = 'ConsultationRoom2',
    AdminRoom = 'AdminRoom'
}

/** Request a private consultation with another participant */
export class PrivateAdminConsultationRequest implements IPrivateAdminConsultationRequest {
    conference_id?: string;
    participant_id?: string;
    /** Response to a consultation request (i.e. 'Accepted or Rejected') */
    answer?: ConsultationAnswer;
    consultation_room?: RoomType;

    constructor(data?: IPrivateAdminConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
            this.answer = _data['answer'];
            this.consultation_room = _data['consultation_room'];
        }
    }

    static fromJS(data: any): PrivateAdminConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PrivateAdminConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        data['answer'] = this.answer;
        data['consultation_room'] = this.consultation_room;
        return data;
    }
}

/** Request a private consultation with another participant */
export interface IPrivateAdminConsultationRequest {
    conference_id?: string;
    participant_id?: string;
    /** Response to a consultation request (i.e. 'Accepted or Rejected') */
    answer?: ConsultationAnswer;
    consultation_room?: RoomType;
}

export class PrivateVideoEndpointConsultationRequest implements IPrivateVideoEndpointConsultationRequest {
    conference_id?: string;
    endpoint_id?: string;

    constructor(data?: IPrivateVideoEndpointConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.endpoint_id = _data['endpoint_id'];
        }
    }

    static fromJS(data: any): PrivateVideoEndpointConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PrivateVideoEndpointConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['endpoint_id'] = this.endpoint_id;
        return data;
    }
}

export interface IPrivateVideoEndpointConsultationRequest {
    conference_id?: string;
    endpoint_id?: string;
}

export enum VirtualCourtRoomType {
    JudgeJOH = 'JudgeJOH',
    Participant = 'Participant'
}

export class StartPrivateConsultationRequest implements IStartPrivateConsultationRequest {
    conference_id?: string;
    requested_by?: string;
    room_type?: VirtualCourtRoomType;

    constructor(data?: IStartPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.requested_by = _data['requested_by'];
            this.room_type = _data['room_type'];
        }
    }

    static fromJS(data: any): StartPrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartPrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['requested_by'] = this.requested_by;
        data['room_type'] = this.room_type;
        return data;
    }
}

export interface IStartPrivateConsultationRequest {
    conference_id?: string;
    requested_by?: string;
    room_type?: VirtualCourtRoomType;
}

export class HealthCheck implements IHealthCheck {
    successful?: boolean;
    error_message?: string | undefined;
    data?: { [key: string]: any } | undefined;

    constructor(data?: IHealthCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.successful = _data['successful'];
            this.error_message = _data['error_message'];
            if (_data['data']) {
                this.data = {} as any;
                for (let key in _data['data']) {
                    if (_data['data'].hasOwnProperty(key)) this.data![key] = _data['data'][key];
                }
            }
        }
    }

    static fromJS(data: any): HealthCheck {
        data = typeof data === 'object' ? data : {};
        let result = new HealthCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['successful'] = this.successful;
        data['error_message'] = this.error_message;
        if (this.data) {
            data['data'] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key)) data['data'][key] = this.data[key];
            }
        }
        return data;
    }
}

export interface IHealthCheck {
    successful?: boolean;
    error_message?: string | undefined;
    data?: { [key: string]: any } | undefined;
}

export class ApplicationVersion implements IApplicationVersion {
    file_version?: string | undefined;
    information_version?: string | undefined;

    constructor(data?: IApplicationVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file_version = _data['file_version'];
            this.information_version = _data['information_version'];
        }
    }

    static fromJS(data: any): ApplicationVersion {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['file_version'] = this.file_version;
        data['information_version'] = this.information_version;
        return data;
    }
}

export interface IApplicationVersion {
    file_version?: string | undefined;
    information_version?: string | undefined;
}

export class HealthCheckResponse implements IHealthCheckResponse {
    bookings_api_health?: HealthCheck | undefined;
    user_api_health?: HealthCheck | undefined;
    video_api_health?: HealthCheck | undefined;
    app_version?: ApplicationVersion | undefined;

    constructor(data?: IHealthCheckResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookings_api_health = _data['bookings_api_health'] ? HealthCheck.fromJS(_data['bookings_api_health']) : <any>undefined;
            this.user_api_health = _data['user_api_health'] ? HealthCheck.fromJS(_data['user_api_health']) : <any>undefined;
            this.video_api_health = _data['video_api_health'] ? HealthCheck.fromJS(_data['video_api_health']) : <any>undefined;
            this.app_version = _data['app_version'] ? ApplicationVersion.fromJS(_data['app_version']) : <any>undefined;
        }
    }

    static fromJS(data: any): HealthCheckResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HealthCheckResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['bookings_api_health'] = this.bookings_api_health ? this.bookings_api_health.toJSON() : <any>undefined;
        data['user_api_health'] = this.user_api_health ? this.user_api_health.toJSON() : <any>undefined;
        data['video_api_health'] = this.video_api_health ? this.video_api_health.toJSON() : <any>undefined;
        data['app_version'] = this.app_version ? this.app_version.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHealthCheckResponse {
    bookings_api_health?: HealthCheck | undefined;
    user_api_health?: HealthCheck | undefined;
    video_api_health?: HealthCheck | undefined;
    app_version?: ApplicationVersion | undefined;
}

export class ChatResponse implements IChatResponse {
    /** Message UUID */
    readonly id?: string;
    /** Username of sender */
    from?: string | undefined;
    from_display_name?: string | undefined;
    /** Username of recipient */
    to?: string | undefined;
    /** Body of message */
    message?: string | undefined;
    /** Time of message */
    timestamp?: Date;
    is_user?: boolean;

    constructor(data?: IChatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data['id'];
            this.from = _data['from'];
            this.from_display_name = _data['from_display_name'];
            this.to = _data['to'];
            this.message = _data['message'];
            this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
            this.is_user = _data['is_user'];
        }
    }

    static fromJS(data: any): ChatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['from'] = this.from;
        data['from_display_name'] = this.from_display_name;
        data['to'] = this.to;
        data['message'] = this.message;
        data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data['is_user'] = this.is_user;
        return data;
    }
}

export interface IChatResponse {
    /** Message UUID */
    id?: string;
    /** Username of sender */
    from?: string | undefined;
    from_display_name?: string | undefined;
    /** Username of recipient */
    to?: string | undefined;
    /** Body of message */
    message?: string | undefined;
    /** Time of message */
    timestamp?: Date;
    is_user?: boolean;
}

export class UnreadAdminMessageResponse implements IUnreadAdminMessageResponse {
    participant_username?: string | undefined;
    number_of_unread_messages?: number;

    constructor(data?: IUnreadAdminMessageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participant_username = _data['participant_username'];
            this.number_of_unread_messages = _data['number_of_unread_messages'];
        }
    }

    static fromJS(data: any): UnreadAdminMessageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnreadAdminMessageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['participant_username'] = this.participant_username;
        data['number_of_unread_messages'] = this.number_of_unread_messages;
        return data;
    }
}

export interface IUnreadAdminMessageResponse {
    participant_username?: string | undefined;
    number_of_unread_messages?: number;
}

export class UnreadInstantMessageConferenceCountResponse implements IUnreadInstantMessageConferenceCountResponse {
    number_of_unread_messages_conference?: UnreadAdminMessageResponse[] | undefined;

    constructor(data?: IUnreadInstantMessageConferenceCountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['number_of_unread_messages_conference'])) {
                this.number_of_unread_messages_conference = [] as any;
                for (let item of _data['number_of_unread_messages_conference'])
                    this.number_of_unread_messages_conference!.push(UnreadAdminMessageResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UnreadInstantMessageConferenceCountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnreadInstantMessageConferenceCountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.number_of_unread_messages_conference)) {
            data['number_of_unread_messages_conference'] = [];
            for (let item of this.number_of_unread_messages_conference) data['number_of_unread_messages_conference'].push(item.toJSON());
        }
        return data;
    }
}

export interface IUnreadInstantMessageConferenceCountResponse {
    number_of_unread_messages_conference?: UnreadAdminMessageResponse[] | undefined;
}

export enum EventType {
    None = 'None',
    Joined = 'Joined',
    Disconnected = 'Disconnected',
    Transfer = 'Transfer',
    Help = 'Help',
    Pause = 'Pause',
    Close = 'Close',
    Leave = 'Leave',
    Consultation = 'Consultation',
    MediaPermissionDenied = 'MediaPermissionDenied',
    ParticipantJoining = 'ParticipantJoining',
    SelfTestFailed = 'SelfTestFailed',
    Suspend = 'Suspend',
    VhoCall = 'VhoCall',
    ParticipantNotSignedIn = 'ParticipantNotSignedIn',
    Start = 'Start',
    CountdownFinished = 'CountdownFinished',
    EndpointJoined = 'EndpointJoined',
    EndpointDisconnected = 'EndpointDisconnected',
    EndpointTransfer = 'EndpointTransfer',
    ConnectingToEventHub = 'ConnectingToEventHub',
    SelectingMedia = 'SelectingMedia',
    ConnectingToConference = 'ConnectingToConference'
}

export class AddMediaEventRequest implements IAddMediaEventRequest {
    readonly event_type?: EventType;

    constructor(data?: IAddMediaEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).event_type = _data['event_type'];
        }
    }

    static fromJS(data: any): AddMediaEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddMediaEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        return data;
    }
}

export interface IAddMediaEventRequest {
    event_type?: EventType;
}

export enum SelfTestFailureReason {
    Camera = 'Camera',
    Microphone = 'Microphone',
    Video = 'Video',
    BadScore = 'BadScore',
    IncompleteTest = 'IncompleteTest'
}

export class AddSelfTestFailureEventRequest implements IAddSelfTestFailureEventRequest {
    readonly event_type?: EventType;
    self_test_failure_reason?: SelfTestFailureReason;

    constructor(data?: IAddSelfTestFailureEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).event_type = _data['event_type'];
            this.self_test_failure_reason = _data['self_test_failure_reason'];
        }
    }

    static fromJS(data: any): AddSelfTestFailureEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddSelfTestFailureEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        data['self_test_failure_reason'] = this.self_test_failure_reason;
        return data;
    }
}

export interface IAddSelfTestFailureEventRequest {
    event_type?: EventType;
    self_test_failure_reason?: SelfTestFailureReason;
}

export enum TestScore {
    Good = 'Good',
    Okay = 'Okay',
    Bad = 'Bad'
}

export class TestCallScoreResponse implements ITestCallScoreResponse {
    score?: TestScore;
    passed?: boolean;

    constructor(data?: ITestCallScoreResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.score = _data['score'];
            this.passed = _data['passed'];
        }
    }

    static fromJS(data: any): TestCallScoreResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestCallScoreResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['score'] = this.score;
        data['passed'] = this.passed;
        return data;
    }
}

export interface ITestCallScoreResponse {
    score?: TestScore;
    passed?: boolean;
}

export class UpdateParticipantStatusEventRequest implements IUpdateParticipantStatusEventRequest {
    event_type?: EventType;

    constructor(data?: IUpdateParticipantStatusEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_type = _data['event_type'];
        }
    }

    static fromJS(data: any): UpdateParticipantStatusEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantStatusEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        return data;
    }
}

export interface IUpdateParticipantStatusEventRequest {
    event_type?: EventType;
}

export class ParticipantHeartbeatResponse implements IParticipantHeartbeatResponse {
    recent_packet_loss?: number;
    browser_name?: string | undefined;
    browser_version?: string | undefined;
    operating_system?: string | undefined;
    operating_system_version?: string | undefined;
    timestamp?: Date;

    constructor(data?: IParticipantHeartbeatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recent_packet_loss = _data['recent_packet_loss'];
            this.browser_name = _data['browser_name'];
            this.browser_version = _data['browser_version'];
            this.operating_system = _data['operating_system'];
            this.operating_system_version = _data['operating_system_version'];
            this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipantHeartbeatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantHeartbeatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['recent_packet_loss'] = this.recent_packet_loss;
        data['browser_name'] = this.browser_name;
        data['browser_version'] = this.browser_version;
        data['operating_system'] = this.operating_system;
        data['operating_system_version'] = this.operating_system_version;
        data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IParticipantHeartbeatResponse {
    recent_packet_loss?: number;
    browser_name?: string | undefined;
    browser_version?: string | undefined;
    operating_system?: string | undefined;
    operating_system_version?: string | undefined;
    timestamp?: Date;
}

export class UpdateParticipantRequest implements IUpdateParticipantRequest {
    fullname!: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    representee?: string | undefined;
    contact_email?: string | undefined;
    contact_telephone?: string | undefined;
    username?: string | undefined;

    constructor(data?: IUpdateParticipantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullname = _data['fullname'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.display_name = _data['display_name'];
            this.representee = _data['representee'];
            this.contact_email = _data['contact_email'];
            this.contact_telephone = _data['contact_telephone'];
            this.username = _data['username'];
        }
    }

    static fromJS(data: any): UpdateParticipantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['fullname'] = this.fullname;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['display_name'] = this.display_name;
        data['representee'] = this.representee;
        data['contact_email'] = this.contact_email;
        data['contact_telephone'] = this.contact_telephone;
        data['username'] = this.username;
        return data;
    }
}

export interface IUpdateParticipantRequest {
    fullname: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    representee?: string | undefined;
    contact_email?: string | undefined;
    contact_telephone?: string | undefined;
    username?: string | undefined;
}

export class ParticipantContactDetailsResponseVho implements IParticipantContactDetailsResponseVho {
    /** The participant id in a conference */
    id?: string;
    conference_id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    /** The participant's user role */
    role?: Role;
    hearing_role?: string | undefined;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    case_type_group?: string | undefined;
    ref_id?: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    contact_telephone?: string | undefined;
    hearing_venue_name?: string | undefined;
    judge_in_another_hearing?: boolean;
    /** The participant represented by the representative */
    representee?: string | undefined;

    constructor(data?: IParticipantContactDetailsResponseVho) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.conference_id = _data['conference_id'];
            this.name = _data['name'];
            this.username = _data['username'];
            this.role = _data['role'];
            this.hearing_role = _data['hearing_role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.case_type_group = _data['case_type_group'];
            this.ref_id = _data['ref_id'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.contact_email = _data['contact_email'];
            this.contact_telephone = _data['contact_telephone'];
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.judge_in_another_hearing = _data['judge_in_another_hearing'];
            this.representee = _data['representee'];
        }
    }

    static fromJS(data: any): ParticipantContactDetailsResponseVho {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantContactDetailsResponseVho();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['conference_id'] = this.conference_id;
        data['name'] = this.name;
        data['username'] = this.username;
        data['role'] = this.role;
        data['hearing_role'] = this.hearing_role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['case_type_group'] = this.case_type_group;
        data['ref_id'] = this.ref_id;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['contact_email'] = this.contact_email;
        data['contact_telephone'] = this.contact_telephone;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['judge_in_another_hearing'] = this.judge_in_another_hearing;
        data['representee'] = this.representee;
        return data;
    }
}

export interface IParticipantContactDetailsResponseVho {
    /** The participant id in a conference */
    id?: string;
    conference_id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    /** The participant's user role */
    role?: Role;
    hearing_role?: string | undefined;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    case_type_group?: string | undefined;
    ref_id?: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    contact_telephone?: string | undefined;
    hearing_venue_name?: string | undefined;
    judge_in_another_hearing?: boolean;
    /** The participant represented by the representative */
    representee?: string | undefined;
}

export class UserProfileResponse implements IUserProfileResponse {
    role?: Role;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    username?: string | undefined;

    constructor(data?: IUserProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data['role'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.display_name = _data['display_name'];
            this.username = _data['username'];
        }
    }

    static fromJS(data: any): UserProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['role'] = this.role;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['display_name'] = this.display_name;
        data['username'] = this.username;
        return data;
    }
}

export interface IUserProfileResponse {
    role?: Role;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    username?: string | undefined;
}

export class SelfTestPexipResponse implements ISelfTestPexipResponse {
    pexip_self_test_node?: string | undefined;

    constructor(data?: ISelfTestPexipResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pexip_self_test_node = _data['pexip_self_test_node'];
        }
    }

    static fromJS(data: any): SelfTestPexipResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SelfTestPexipResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['pexip_self_test_node'] = this.pexip_self_test_node;
        return data;
    }
}

export interface ISelfTestPexipResponse {
    pexip_self_test_node?: string | undefined;
}

export enum TaskType {
    Hearing = 'Hearing',
    Judge = 'Judge',
    Participant = 'Participant'
}

export enum TaskStatus {
    ToDo = 'ToDo',
    Done = 'Done'
}

export class TaskResponse implements ITaskResponse {
    id?: number;
    origin_id?: string;
    body?: string | undefined;
    type?: TaskType;
    status?: TaskStatus;
    created?: Date;
    updated?: Date | undefined;
    updated_by?: string | undefined;

    constructor(data?: ITaskResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.origin_id = _data['origin_id'];
            this.body = _data['body'];
            this.type = _data['type'];
            this.status = _data['status'];
            this.created = _data['created'] ? new Date(_data['created'].toString()) : <any>undefined;
            this.updated = _data['updated'] ? new Date(_data['updated'].toString()) : <any>undefined;
            this.updated_by = _data['updated_by'];
        }
    }

    static fromJS(data: any): TaskResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['origin_id'] = this.origin_id;
        data['body'] = this.body;
        data['type'] = this.type;
        data['status'] = this.status;
        data['created'] = this.created ? this.created.toISOString() : <any>undefined;
        data['updated'] = this.updated ? this.updated.toISOString() : <any>undefined;
        data['updated_by'] = this.updated_by;
        return data;
    }
}

export interface ITaskResponse {
    id?: number;
    origin_id?: string;
    body?: string | undefined;
    type?: TaskType;
    status?: TaskStatus;
    created?: Date;
    updated?: Date | undefined;
    updated_by?: string | undefined;
}

export class TokenResponse implements ITokenResponse {
    expires_on?: string | undefined;
    token?: string | undefined;

    constructor(data?: ITokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expires_on = _data['expires_on'];
            this.token = _data['token'];
        }
    }

    static fromJS(data: any): TokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['expires_on'] = this.expires_on;
        data['token'] = this.token;
        return data;
    }
}

export interface ITokenResponse {
    expires_on?: string | undefined;
    token?: string | undefined;
}

export class CourtRoomsAccountResponse implements ICourtRoomsAccountResponse {
    /** The venue name (judge first name) */
    venue?: string | undefined;
    court_rooms?: string[] | undefined;

    constructor(data?: ICourtRoomsAccountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.venue = _data['venue'];
            if (Array.isArray(_data['court_rooms'])) {
                this.court_rooms = [] as any;
                for (let item of _data['court_rooms']) this.court_rooms!.push(item);
            }
        }
    }

    static fromJS(data: any): CourtRoomsAccountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CourtRoomsAccountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['venue'] = this.venue;
        if (Array.isArray(this.court_rooms)) {
            data['court_rooms'] = [];
            for (let item of this.court_rooms) data['court_rooms'].push(item);
        }
        return data;
    }
}

export interface ICourtRoomsAccountResponse {
    /** The venue name (judge first name) */
    venue?: string | undefined;
    court_rooms?: string[] | undefined;
}

export class JudgeNameListResponse implements IJudgeNameListResponse {
    first_names?: string[] | undefined;

    constructor(data?: IJudgeNameListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['first_names'])) {
                this.first_names = [] as any;
                for (let item of _data['first_names']) this.first_names!.push(item);
            }
        }
    }

    static fromJS(data: any): JudgeNameListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JudgeNameListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.first_names)) {
            data['first_names'] = [];
            for (let item of this.first_names) data['first_names'].push(item);
        }
        return data;
    }
}

export interface IJudgeNameListResponse {
    first_names?: string[] | undefined;
}

export class ConferenceEventRequest implements IConferenceEventRequest {
    event_id?: string | undefined;
    event_type?: EventType;
    time_stamp_utc?: Date;
    conference_id?: string | undefined;
    participant_id?: string | undefined;
    transfer_from?: string | undefined;
    transfer_to?: string | undefined;
    reason?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IConferenceEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_id = _data['event_id'];
            this.event_type = _data['event_type'];
            this.time_stamp_utc = _data['time_stamp_utc'] ? new Date(_data['time_stamp_utc'].toString()) : <any>undefined;
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
            this.transfer_from = _data['transfer_from'];
            this.transfer_to = _data['transfer_to'];
            this.reason = _data['reason'];
            this.phone = _data['phone'];
        }
    }

    static fromJS(data: any): ConferenceEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_id'] = this.event_id;
        data['event_type'] = this.event_type;
        data['time_stamp_utc'] = this.time_stamp_utc ? this.time_stamp_utc.toISOString() : <any>undefined;
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        data['transfer_from'] = this.transfer_from;
        data['transfer_to'] = this.transfer_to;
        data['reason'] = this.reason;
        data['phone'] = this.phone;
        return data;
    }
}

export interface IConferenceEventRequest {
    event_id?: string | undefined;
    event_type?: EventType;
    time_stamp_utc?: Date;
    conference_id?: string | undefined;
    participant_id?: string | undefined;
    transfer_from?: string | undefined;
    transfer_to?: string | undefined;
    reason?: string | undefined;
    phone?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): Observable<any> {
    if (result !== null && result !== undefined) return _observableThrow(result);
    else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next('');
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
