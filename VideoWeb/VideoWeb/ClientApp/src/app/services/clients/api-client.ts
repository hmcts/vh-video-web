/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export class ApiClientBase {
    protected transformOptions(options: any) {
        options.headers = options.headers.append('Cache-Control', 'no-store');
        return Promise.resolve(options);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiClient extends ApiClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:5800';
    }

    /**
     * @return Success
     */
    getAudioStreamInfo(hearingId: string, wowzaSingleApp: boolean): Observable<boolean> {
        let url_ = this.baseUrl + '/conferences/audiostreams/{hearingId}/{wowzaSingleApp}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        if (wowzaSingleApp === undefined || wowzaSingleApp === null) throw new Error("The parameter 'wowzaSingleApp' must be defined.");
        url_ = url_.replace('{wowzaSingleApp}', encodeURIComponent('' + wowzaSingleApp));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAudioStreamInfo(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAudioStreamInfo(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<boolean>;
                        }
                    } else return _observableThrow(response_) as any as Observable<boolean>;
                })
            );
    }

    protected processGetAudioStreamInfo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;

                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return Success
     */
    stopAudioRecording(hearingId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/audiostreams/{hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('delete', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStopAudioRecording(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStopAudioRecording(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processStopAudioRecording(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Start or resume a video hearing
     * @param conferenceId conference id
     * @param body (optional) start hearing request details
     * @return Accepted
     */
    startOrResumeVideoHearing(conferenceId: string, body: StartHearingRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/start';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStartOrResumeVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStartOrResumeVideoHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processStartOrResumeVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Returns the active layout for a conference
     * @param conferenceId conference id
     * @return Success
     */
    getLayoutForHearing(conferenceId: string): Observable<HearingLayout> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/getlayout';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetLayoutForHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetLayoutForHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingLayout>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingLayout>;
                })
            );
    }

    protected processGetLayoutForHearing(response: HttpResponseBase): Observable<HearingLayout> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;

                    return _observableOf(result200);
                })
            );
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result403: any = null;
                    let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result403 = ProblemDetails.fromJS(resultData403);
                    return throwException('Forbidden', status, _responseText, _headers, result403);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HearingLayout>(null as any);
    }

    /**
     * Update the active layout for a conference
     * @param conferenceId conference id
     * @param layout (optional) layout
     * @return Success
     */
    updateLayoutForHearing(conferenceId: string, layout: HearingLayout | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/updatelayout?';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (layout === null) throw new Error("The parameter 'layout' cannot be null.");
        else if (layout !== undefined) url_ += 'layout=' + encodeURIComponent('' + layout) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateLayoutForHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateLayoutForHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processUpdateLayoutForHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result403: any = null;
                    let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result403 = ProblemDetails.fromJS(resultData403);
                    return throwException('Forbidden', status, _responseText, _headers, result403);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get recommended layout for hearing
     * @param conferenceId conference id
     * @return Success
     */
    getRecommendedLayoutForHearing(conferenceId: string): Observable<HearingLayout> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/getrecommendedlayout';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetRecommendedLayoutForHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetRecommendedLayoutForHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingLayout>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingLayout>;
                })
            );
    }

    protected processGetRecommendedLayoutForHearing(response: HttpResponseBase): Observable<HearingLayout> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;

                    return _observableOf(result200);
                })
            );
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result403: any = null;
                    let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result403 = ProblemDetails.fromJS(resultData403);
                    return throwException('Forbidden', status, _responseText, _headers, result403);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HearingLayout>(null as any);
    }

    /**
     * Pause a video hearing
     * @param conferenceId conference id
     * @return Accepted
     */
    pauseVideoHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/pause';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processPauseVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processPauseVideoHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processPauseVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Suspend a video hearing
     * @param conferenceId conference id
     * @return Accepted
     */
    suspendVideoHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/suspend';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSuspendVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSuspendVideoHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processSuspendVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * End a video hearing
     * @param conferenceId conference id
     * @return Accepted
     */
    endVideoHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/end';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processEndVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processEndVideoHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processEndVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Call a witness into a video hearing
     * @param conferenceId conference id
     * @param participantId witness id
     * @return Accepted
     */
    callParticipant(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/call';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCallParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCallParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processCallParticipant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Joins a video hearing currently in session
     * @param conferenceId conference id
     * @param participantId participant id
     * @return Accepted
     */
    joinHearingInSession(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/join-hearing';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processJoinHearingInSession(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processJoinHearingInSession(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processJoinHearingInSession(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Call a witness into a video hearing
     * @param conferenceId conference id
     * @param participantId witness id
     * @return Accepted
     */
    dismissParticipant(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/dismiss';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDismissParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDismissParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processDismissParticipant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Leave host from hearing
     * @param conferenceId conference id
     * @param participantId witness id
     * @return Accepted
     */
    leaveHearing(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/leave';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLeaveHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLeaveHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processLeaveHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get conferences today for a host
     * @return Success
     */
    getConferencesForHost(): Observable<ConferenceForHostResponse[]> {
        let url_ = this.baseUrl + '/conferences/hosts';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForHost(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForHost(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceForHostResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceForHostResponse[]>;
                })
            );
    }

    protected processGetConferencesForHost(response: HttpResponseBase): Observable<ConferenceForHostResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForHostResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForHostResponse[]>(null as any);
    }

    /**
     * Get conferences today for staff member with the specifed hearing venue names
     * @param hearingVenueNames (optional)
     * @return Success
     */
    getConferencesForStaffMember(hearingVenueNames: string[] | undefined): Observable<ConferenceForHostResponse[]> {
        let url_ = this.baseUrl + '/conferences/staffmember?';
        if (hearingVenueNames === null) throw new Error("The parameter 'hearingVenueNames' cannot be null.");
        else if (hearingVenueNames !== undefined)
            hearingVenueNames &&
                hearingVenueNames.forEach(item => {
                    url_ += 'hearingVenueNames=' + encodeURIComponent('' + item) + '&';
                });
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForStaffMember(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForStaffMember(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceForHostResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceForHostResponse[]>;
                })
            );
    }

    protected processGetConferencesForStaffMember(response: HttpResponseBase): Observable<ConferenceForHostResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForHostResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForHostResponse[]>(null as any);
    }

    /**
     * Get conferences today for individual or representative excluding those that have been closed for over 120 minutes
     * @return Success
     */
    getConferencesForIndividual(): Observable<ConferenceForIndividualResponse[]> {
        let url_ = this.baseUrl + '/conferences/individuals';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForIndividual(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForIndividual(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceForIndividualResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceForIndividualResponse[]>;
                })
            );
    }

    protected processGetConferencesForIndividual(response: HttpResponseBase): Observable<ConferenceForIndividualResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForIndividualResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForIndividualResponse[]>(null as any);
    }

    /**
     * Get conferences for user
     * @param hearingVenueNames (optional)
     * @return Success
     */
    getConferencesForVhOfficer(hearingVenueNames: string[] | undefined): Observable<ConferenceForVhOfficerResponse[]> {
        let url_ = this.baseUrl + '/conferences/vhofficer?';
        if (hearingVenueNames === null) throw new Error("The parameter 'hearingVenueNames' cannot be null.");
        else if (hearingVenueNames !== undefined)
            hearingVenueNames &&
                hearingVenueNames.forEach(item => {
                    url_ += 'HearingVenueNames=' + encodeURIComponent('' + item) + '&';
                });
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForVhOfficer(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForVhOfficer(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceForVhOfficerResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceForVhOfficerResponse[]>;
                })
            );
    }

    protected processGetConferencesForVhOfficer(response: HttpResponseBase): Observable<ConferenceForVhOfficerResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForVhOfficerResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result401: any = null;
                    let resultData401 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result401 = ProblemDetails.fromJS(resultData401);
                    return throwException('Unauthorized', status, _responseText, _headers, result401);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForVhOfficerResponse[]>(null as any);
    }

    /**
     * Get the details of a conference by id for VH officer
     * @param conferenceId The unique id of the conference
     * @return Success
     */
    getConferenceByIdVHO(conferenceId: string): Observable<ConferenceResponseVho> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/vhofficer';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceByIdVHO(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceByIdVHO(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceResponseVho>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceResponseVho>;
                })
            );
    }

    protected processGetConferenceByIdVHO(response: HttpResponseBase): Observable<ConferenceResponseVho> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceResponseVho.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('No Content', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceResponseVho>(null as any);
    }

    /**
     * Get the details of a conference by id
     * @param conferenceId The unique id of the conference
     * @return Success
     */
    getConferenceById(conferenceId: string): Observable<ConferenceResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceById(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceById(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceResponse>;
                })
            );
    }

    protected processGetConferenceById(response: HttpResponseBase): Observable<ConferenceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('No Content', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceResponse>(null as any);
    }

    /**
     * Updates the video control statuses for the conference
     * @param conferenceId conference id
     * @param body (optional) Request object to set Video Control Staus
     * @return Accepted
     */
    setVideoControlStatusesForConference(
        conferenceId: string,
        body: SetConferenceVideoControlStatusesRequest | undefined
    ): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/setVideoControlStatuses';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('put', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSetVideoControlStatusesForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSetVideoControlStatusesForConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processSetVideoControlStatusesForConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Returns the video control statuses for the conference
     * @param conferenceId conference id
     * @return Success
     */
    getVideoControlStatusesForConference(conferenceId: string): Observable<ConferenceVideoControlStatuses> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/getVideoControlStatuses';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetVideoControlStatusesForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetVideoControlStatusesForConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceVideoControlStatuses>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceVideoControlStatuses>;
                })
            );
    }

    protected processGetVideoControlStatusesForConference(response: HttpResponseBase): Observable<ConferenceVideoControlStatuses> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceVideoControlStatuses.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result204: any = null;
                    let resultData204 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result204 = ConferenceVideoControlStatuses.fromJS(resultData204);
                    return _observableOf(result204);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceVideoControlStatuses>(null as any);
    }

    /**
     * GetClientConfigurationSettings the configuration settings for client
     * @return Success
     */
    getClientConfigurationSettings(): Observable<ClientSettingsResponse> {
        let url_ = this.baseUrl + '/config';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetClientConfigurationSettings(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetClientConfigurationSettings(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ClientSettingsResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ClientSettingsResponse>;
                })
            );
    }

    protected processGetClientConfigurationSettings(response: HttpResponseBase): Observable<ClientSettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ClientSettingsResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ClientSettingsResponse>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    leaveConsultation(body: LeavePrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/leave';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLeaveConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLeaveConsultation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processLeaveConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    respondToConsultationRequest(body: PrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/respond';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processRespondToConsultationRequest(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processRespondToConsultationRequest(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processRespondToConsultationRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return Accepted
     */
    joinPrivateConsultation(body: JoinPrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/joinPrivateConsultation';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processJoinPrivateConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processJoinPrivateConsultation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processJoinPrivateConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return Accepted
     */
    startOrJoinConsultation(body: StartPrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/start';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStartOrJoinConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStartOrJoinConsultation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processStartOrJoinConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result403: any = null;
                    let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result403 = ProblemDetails.fromJS(resultData403);
                    return throwException('Forbidden', status, _responseText, _headers, result403);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    lockConsultationRoomRequest(body: LockConsultationRoomRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/lock';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLockConsultationRoomRequest(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLockConsultationRoomRequest(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processLockConsultationRoomRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return Accepted
     */
    inviteToConsultation(body: InviteToConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/invite';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processInviteToConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processInviteToConsultation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processInviteToConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return Accepted
     */
    addEndpointToConsultation(body: AddEndpointConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/addendpoint';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddEndpointToConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddEndpointToConsultation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processAddEndpointToConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getVideoEndpointsForConference(conferenceId: string): Observable<VideoEndpointResponse[]> {
        let url_ = this.baseUrl + '/{conferenceId}/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetVideoEndpointsForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetVideoEndpointsForConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<VideoEndpointResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<VideoEndpointResponse[]>;
                })
            );
    }

    protected processGetVideoEndpointsForConference(response: HttpResponseBase): Observable<VideoEndpointResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(VideoEndpointResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<VideoEndpointResponse[]>(null as any);
    }

    /**
     * @return Success
     */
    allowedVideoCallEndpoints(conferenceId: string): Observable<AllowedEndpointResponse[]> {
        let url_ = this.baseUrl + '/{conferenceId}/allowed-video-call-endpoints';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAllowedVideoCallEndpoints(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAllowedVideoCallEndpoints(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<AllowedEndpointResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<AllowedEndpointResponse[]>;
                })
            );
    }

    protected processAllowedVideoCallEndpoints(response: HttpResponseBase): Observable<AllowedEndpointResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(AllowedEndpointResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<AllowedEndpointResponse[]>(null as any);
    }

    /**
     * returns the FeatureToggles
     * @param featureName (optional)
     * @return Success
     */
    getFeatureFlag(featureName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + '/feature-flag?';
        if (featureName === null) throw new Error("The parameter 'featureName' cannot be null.");
        else if (featureName !== undefined) url_ += 'featureName=' + encodeURIComponent('' + featureName) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetFeatureFlag(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetFeatureFlag(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<boolean>;
                        }
                    } else return _observableThrow(response_) as any as Observable<boolean>;
                })
            );
    }

    protected processGetFeatureFlag(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;

                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Check Service Health
     * @return Success
     */
    checkServiceHealth(): Observable<HealthCheckResponse> {
        let url_ = this.baseUrl + '/HealthCheck/health';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCheckServiceHealth(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCheckServiceHealth(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HealthCheckResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HealthCheckResponse>;
                })
            );
    }

    protected processCheckServiceHealth(response: HttpResponseBase): Observable<HealthCheckResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = HealthCheckResponse.fromJS(resultData500);
                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HealthCheckResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HealthCheckResponse>(null as any);
    }

    /**
     * Check Service Health
     * @return Success
     */
    checkServiceHealth2(): Observable<HealthCheckResponse> {
        let url_ = this.baseUrl + '/health/liveness';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCheckServiceHealth2(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCheckServiceHealth2(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HealthCheckResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HealthCheckResponse>;
                })
            );
    }

    protected processCheckServiceHealth2(response: HttpResponseBase): Observable<HealthCheckResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = HealthCheckResponse.fromJS(resultData500);
                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HealthCheckResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HealthCheckResponse>(null as any);
    }

    /**
     * @return Success
     */
    getHeartbeatConfigForParticipant(participantId: string): Observable<HeartbeatConfigurationResponse> {
        let url_ = this.baseUrl + '/heartbeat/GetHeartbeatConfigForParticipant/{participantId}';
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHeartbeatConfigForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHeartbeatConfigForParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HeartbeatConfigurationResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HeartbeatConfigurationResponse>;
                })
            );
    }

    protected processGetHeartbeatConfigForParticipant(response: HttpResponseBase): Observable<HeartbeatConfigurationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HeartbeatConfigurationResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HeartbeatConfigurationResponse>(null as any);
    }

    /**
     * Get all the instant messages for a conference for a participant
     * @param conferenceId Id of the conference
     * @param participantId the participant in the conference
     * @return Success
     */
    getConferenceInstantMessageHistoryForParticipant(conferenceId: string, participantId: string): Observable<ChatResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/participant/{participantId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceInstantMessageHistoryForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceInstantMessageHistoryForParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ChatResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ChatResponse[]>;
                })
            );
    }

    protected processGetConferenceInstantMessageHistoryForParticipant(response: HttpResponseBase): Observable<ChatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ChatResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ChatResponse[]>(null as any);
    }

    /**
     * Get number of unread messages for vho
     * @param conferenceId Id of the conference
     * @return Success
     */
    getNumberOfUnreadAdminMessagesForConference(conferenceId: string): Observable<UnreadInstantMessageConferenceCountResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/unread/vho';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetNumberOfUnreadAdminMessagesForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetNumberOfUnreadAdminMessagesForConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UnreadInstantMessageConferenceCountResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UnreadInstantMessageConferenceCountResponse>;
                })
            );
    }

    protected processGetNumberOfUnreadAdminMessagesForConference(
        response: HttpResponseBase
    ): Observable<UnreadInstantMessageConferenceCountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UnreadInstantMessageConferenceCountResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UnreadInstantMessageConferenceCountResponse>(null as any);
    }

    /**
     * Get number of unread messages for a participant
     * @param conferenceId Id of the conference
     * @param participantId the participant in the conference
     * @return Success
     */
    getNumberOfUnreadAdminMessagesForConferenceByParticipant(
        conferenceId: string,
        participantId: string
    ): Observable<UnreadAdminMessageResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/unread/participant/{participantId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UnreadAdminMessageResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UnreadAdminMessageResponse>;
                })
            );
    }

    protected processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(
        response: HttpResponseBase
    ): Observable<UnreadAdminMessageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UnreadAdminMessageResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UnreadAdminMessageResponse>(null as any);
    }

    /**
     * @param conferenceId (optional)
     * @return No Content
     */
    conferenceAdded(conferenceId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + '/internalevent/ConferenceAdded?';
        if (conferenceId === null) throw new Error("The parameter 'conferenceId' cannot be null.");
        else if (conferenceId !== undefined) url_ += 'conferenceId=' + encodeURIComponent('' + conferenceId) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processConferenceAdded(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processConferenceAdded(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processConferenceAdded(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param conferenceId (optional)
     * @param body (optional)
     * @return No Content
     */
    participantsUpdated(conferenceId: string | undefined, body: UpdateConferenceParticipantsRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/internalevent/ParticipantsUpdated?';
        if (conferenceId === null) throw new Error("The parameter 'conferenceId' cannot be null.");
        else if (conferenceId !== undefined) url_ += 'conferenceId=' + encodeURIComponent('' + conferenceId) + '&';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processParticipantsUpdated(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processParticipantsUpdated(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processParticipantsUpdated(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    addMediaEventToConference(conferenceId: string, body: AddMediaEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/mediaevents';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddMediaEventToConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddMediaEventToConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processAddMediaEventToConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    addSelfTestFailureEventToConference(conferenceId: string, body: AddSelfTestFailureEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/selftestfailureevents';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddSelfTestFailureEventToConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddSelfTestFailureEventToConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processAddSelfTestFailureEventToConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getTestCallResult(conferenceId: string, participantId: string): Observable<TestCallScoreResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants/{participantId}/selftestresult';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTestCallResult(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTestCallResult(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TestCallScoreResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TestCallScoreResponse>;
                })
            );
    }

    protected processGetTestCallResult(response: HttpResponseBase): Observable<TestCallScoreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TestCallScoreResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TestCallScoreResponse>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    updateParticipantStatus(conferenceId: string, body: UpdateParticipantStatusEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participantstatus';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateParticipantStatus(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateParticipantStatus(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processUpdateParticipantStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param participantId (optional)
     * @return Success
     */
    getIndependentTestCallResult(participantId: string | undefined): Observable<TestCallScoreResponse> {
        let url_ = this.baseUrl + '/conferences/independentselftestresult?';
        if (participantId === null) throw new Error("The parameter 'participantId' cannot be null.");
        else if (participantId !== undefined) url_ += 'participantId=' + encodeURIComponent('' + participantId) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetIndependentTestCallResult(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetIndependentTestCallResult(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TestCallScoreResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TestCallScoreResponse>;
                })
            );
    }

    protected processGetIndependentTestCallResult(response: HttpResponseBase): Observable<TestCallScoreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TestCallScoreResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TestCallScoreResponse>(null as any);
    }

    /**
     * @return Success
     */
    getHeartbeatDataForParticipant(conferenceId: string, participantId: string): Observable<ParticipantHeartbeatResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/heartbeatrecent';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHeartbeatDataForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHeartbeatDataForParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ParticipantHeartbeatResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ParticipantHeartbeatResponse[]>;
                })
            );
    }

    protected processGetHeartbeatDataForParticipant(response: HttpResponseBase): Observable<ParticipantHeartbeatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantHeartbeatResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantHeartbeatResponse[]>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    updateParticipantDisplayName(
        conferenceId: string,
        participantId: string,
        body: UpdateParticipantDisplayNameRequest | undefined
    ): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants/{participantId}/participantDisplayName';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateParticipantDisplayName(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateParticipantDisplayName(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processUpdateParticipantDisplayName(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get the participant details of a conference by id for VH officer
     * @param conferenceId The unique id of the conference
     * @return Success
     */
    getParticipantsWithContactDetailsByConferenceId(conferenceId: string): Observable<ParticipantContactDetailsResponseVho[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/vhofficer/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetParticipantsWithContactDetailsByConferenceId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetParticipantsWithContactDetailsByConferenceId(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ParticipantContactDetailsResponseVho[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ParticipantContactDetailsResponseVho[]>;
                })
            );
    }

    protected processGetParticipantsWithContactDetailsByConferenceId(
        response: HttpResponseBase
    ): Observable<ParticipantContactDetailsResponseVho[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantContactDetailsResponseVho.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantContactDetailsResponseVho[]>(null as any);
    }

    /**
     * @return Success
     */
    getParticipantsByConferenceId(conferenceId: string): Observable<ParticipantForUserResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetParticipantsByConferenceId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetParticipantsByConferenceId(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ParticipantForUserResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ParticipantForUserResponse[]>;
                })
            );
    }

    protected processGetParticipantsByConferenceId(response: HttpResponseBase): Observable<ParticipantForUserResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantForUserResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantForUserResponse[]>(null as any);
    }

    /**
     * @return Success
     */
    getCurrentParticipant(conferenceId: string): Observable<LoggedParticipantResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/currentparticipant';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCurrentParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCurrentParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<LoggedParticipantResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<LoggedParticipantResponse>;
                })
            );
    }

    protected processGetCurrentParticipant(response: HttpResponseBase): Observable<LoggedParticipantResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = LoggedParticipantResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<LoggedParticipantResponse>(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    staffMemberJoinConference(conferenceId: string, body: StaffMemberJoinConferenceRequest | undefined): Observable<ConferenceResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/joinConference';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStaffMemberJoinConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStaffMemberJoinConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceResponse>;
                })
            );
    }

    protected processStaffMemberJoinConference(response: HttpResponseBase): Observable<ConferenceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceResponse>(null as any);
    }

    /**
     * Get profile for logged in user
     * @return Success
     */
    getUserProfile(): Observable<UserProfileResponse> {
        let url_ = this.baseUrl + '/profile';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUserProfile(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUserProfile(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserProfileResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserProfileResponse>;
                })
            );
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<UserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UserProfileResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UserProfileResponse>(null as any);
    }

    /**
     * Get profile for username
     * @param username (optional)
     * @return Success
     */
    getProfileByUsername(username: string | undefined): Observable<UserProfileResponse> {
        let url_ = this.baseUrl + '/profile/query?';
        if (username === null) throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined) url_ += 'username=' + encodeURIComponent('' + username) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetProfileByUsername(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetProfileByUsername(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserProfileResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserProfileResponse>;
                })
            );
    }

    protected processGetProfileByUsername(response: HttpResponseBase): Observable<UserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UserProfileResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UserProfileResponse>(null as any);
    }

    /**
     * @return Success
     */
    getQuickLinkParticipantRoles(): Observable<Role[]> {
        let url_ = this.baseUrl + '/quickjoin/GetQuickLinkParticipantRoles';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetQuickLinkParticipantRoles(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetQuickLinkParticipantRoles(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<Role[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<Role[]>;
                })
            );
    }

    protected processGetQuickLinkParticipantRoles(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(item);
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<Role[]>(null as any);
    }

    /**
     * @return Success
     */
    validateQuickLink(hearingId: string): Observable<boolean> {
        let url_ = this.baseUrl + '/quickjoin/ValidateQuickLink/{hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processValidateQuickLink(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processValidateQuickLink(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<boolean>;
                        }
                    } else return _observableThrow(response_) as any as Observable<boolean>;
                })
            );
    }

    protected processValidateQuickLink(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;

                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * joinConferenceAsAQuickLinkUser
     * @param body (optional)
     * @return Success
     */
    joinConferenceAsAQuickLinkUser(
        hearingId: string,
        body: QuickLinkParticipantJoinRequest | undefined
    ): Observable<QuickLinkParticipantJoinResponse> {
        let url_ = this.baseUrl + '/quickjoin/joinConferenceAsAQuickLinkUser/${hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processJoinConferenceAsAQuickLinkUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processJoinConferenceAsAQuickLinkUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<QuickLinkParticipantJoinResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<QuickLinkParticipantJoinResponse>;
                })
            );
    }

    protected processJoinConferenceAsAQuickLinkUser(response: HttpResponseBase): Observable<QuickLinkParticipantJoinResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = QuickLinkParticipantJoinResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<QuickLinkParticipantJoinResponse>(null as any);
    }

    /**
     * isQuickLinkParticipantAuthorised
     * @return Success
     */
    isQuickLinkParticipantAuthorised(): Observable<void> {
        let url_ = this.baseUrl + '/quickjoin/isQuickLinkParticipantAuthorised';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processIsQuickLinkParticipantAuthorised(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processIsQuickLinkParticipantAuthorised(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processIsQuickLinkParticipantAuthorised(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result403: any = null;
                    let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result403 = ProblemDetails.fromJS(resultData403);
                    return throwException('Forbidden', status, _responseText, _headers, result403);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get the Pexip self test node.
     * @return Success
     */
    getPexipConfig(): Observable<SelfTestPexipResponse> {
        let url_ = this.baseUrl + '/selftest';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetPexipConfig(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetPexipConfig(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<SelfTestPexipResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<SelfTestPexipResponse>;
                })
            );
    }

    protected processGetPexipConfig(response: HttpResponseBase): Observable<SelfTestPexipResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = SelfTestPexipResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<SelfTestPexipResponse>(null as any);
    }

    /**
     * @return Success
     */
    getTasks(conferenceId: string): Observable<TaskResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/tasks';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTasks(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTasks(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TaskResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TaskResponse[]>;
                })
            );
    }

    protected processGetTasks(response: HttpResponseBase): Observable<TaskResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(TaskResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TaskResponse[]>(null as any);
    }

    /**
     * Update existing tasks
     * @param conferenceId The id of the conference to update
     * @param taskId The id of the task to update
     * @return Success
     */
    completeTask(conferenceId: string, taskId: number): Observable<TaskResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/tasks/{taskId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (taskId === undefined || taskId === null) throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace('{taskId}', encodeURIComponent('' + taskId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('patch', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCompleteTask(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCompleteTask(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TaskResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TaskResponse>;
                })
            );
    }

    protected processCompleteTask(response: HttpResponseBase): Observable<TaskResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TaskResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TaskResponse>(null as any);
    }

    /**
     * @return Success
     */
    getSelfTestToken(participantId: string): Observable<TokenResponse> {
        let url_ = this.baseUrl + '/participants/{participantId}/selftesttoken';
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetSelfTestToken(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetSelfTestToken(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TokenResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TokenResponse>;
                })
            );
    }

    protected processGetSelfTestToken(response: HttpResponseBase): Observable<TokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TokenResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TokenResponse>(null as any);
    }

    /**
     * Get Court rooms accounts (judges)
     * @param hearingVenueNames (optional)
     * @return Success
     */
    getCourtRoomAccounts(hearingVenueNames: string[] | undefined): Observable<CourtRoomsAccountResponse[]> {
        let url_ = this.baseUrl + '/api/accounts/courtrooms?';
        if (hearingVenueNames === null) throw new Error("The parameter 'hearingVenueNames' cannot be null.");
        else if (hearingVenueNames !== undefined)
            hearingVenueNames &&
                hearingVenueNames.forEach(item => {
                    url_ += 'HearingVenueNames=' + encodeURIComponent('' + item) + '&';
                });
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCourtRoomAccounts(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCourtRoomAccounts(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<CourtRoomsAccountResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<CourtRoomsAccountResponse[]>;
                })
            );
    }

    protected processGetCourtRoomAccounts(response: HttpResponseBase): Observable<CourtRoomsAccountResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(CourtRoomsAccountResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<CourtRoomsAccountResponse[]>(null as any);
    }

    /**
     * Get available courts
     * @return Success
     */
    getVenues(): Observable<HearingVenueResponse[]> {
        let url_ = this.baseUrl + '/hearing-venues/courts';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetVenues(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetVenues(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingVenueResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingVenueResponse[]>;
                })
            );
    }

    protected processGetVenues(response: HttpResponseBase): Observable<HearingVenueResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(HearingVenueResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HearingVenueResponse[]>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    sendEvent(body: ConferenceEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/callback';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSendEvent(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSendEvent(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processSendEvent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param participantType (optional)
     * @return Success
     */
    getParticipantRoomForParticipant(
        conferenceId: string,
        participantId: string,
        participantType: string | undefined
    ): Observable<SharedParticipantRoom> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/rooms/shared/{participantId}?';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        if (participantType === null) throw new Error("The parameter 'participantType' cannot be null.");
        else if (participantType !== undefined) url_ += 'participantType=' + encodeURIComponent('' + participantType) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetParticipantRoomForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetParticipantRoomForParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<SharedParticipantRoom>;
                        }
                    } else return _observableThrow(response_) as any as Observable<SharedParticipantRoom>;
                })
            );
    }

    protected processGetParticipantRoomForParticipant(response: HttpResponseBase): Observable<SharedParticipantRoom> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = SharedParticipantRoom.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : <any>null;

                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<SharedParticipantRoom>(null as any);
    }
}

export class HearingVenueResponse implements IHearingVenueResponse {
    id?: number;
    name?: string | undefined;

    constructor(data?: IHearingVenueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
        }
    }

    static fromJS(data: any): HearingVenueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HearingVenueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        return data;
    }
}

export interface IHearingVenueResponse {
    id?: number;
    name?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property)) this[property] = _data[property];
            }
            this.type = _data['type'];
            this.title = _data['title'];
            this.status = _data['status'];
            this.detail = _data['detail'];
            this.instance = _data['instance'];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property)) data[property] = this[property];
        }
        data['type'] = this.type;
        data['title'] = this.title;
        data['status'] = this.status;
        data['detail'] = this.detail;
        data['instance'] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export enum EventType {
    None = 'None',
    Joined = 'Joined',
    Disconnected = 'Disconnected',
    Transfer = 'Transfer',
    Help = 'Help',
    Pause = 'Pause',
    Close = 'Close',
    Leave = 'Leave',
    Consultation = 'Consultation',
    MediaPermissionDenied = 'MediaPermissionDenied',
    ParticipantJoining = 'ParticipantJoining',
    SelfTestFailed = 'SelfTestFailed',
    Suspend = 'Suspend',
    VhoCall = 'VhoCall',
    ParticipantNotSignedIn = 'ParticipantNotSignedIn',
    Start = 'Start',
    CountdownFinished = 'CountdownFinished',
    EndpointJoined = 'EndpointJoined',
    EndpointDisconnected = 'EndpointDisconnected',
    EndpointTransfer = 'EndpointTransfer',
    ConnectingToEventHub = 'ConnectingToEventHub',
    SelectingMedia = 'SelectingMedia',
    ConnectingToConference = 'ConnectingToConference',
    RoomParticipantJoined = 'RoomParticipantJoined',
    RoomParticipantDisconnected = 'RoomParticipantDisconnected',
    RoomParticipantTransfer = 'RoomParticipantTransfer'
}

export enum LinkedParticipantType {
    Interpreter = 'Interpreter'
}

export enum TaskStatus {
    ToDo = 'ToDo',
    Done = 'Done'
}

export enum TaskType {
    Hearing = 'Hearing',
    Judge = 'Judge',
    Participant = 'Participant'
}

export enum TestScore {
    Good = 'Good',
    Okay = 'Okay',
    Bad = 'Bad'
}

export enum UserRole {
    None = 'None',
    CaseAdmin = 'CaseAdmin',
    VideoHearingsOfficer = 'VideoHearingsOfficer',
    HearingFacilitationSupport = 'HearingFacilitationSupport',
    Judge = 'Judge',
    Individual = 'Individual',
    Representative = 'Representative',
    JudicialOfficeHolder = 'JudicialOfficeHolder',
    QuickLinkParticipant = 'QuickLinkParticipant',
    QuickLinkObserver = 'QuickLinkObserver',
    StaffMember = 'StaffMember'
}

export class ConferenceEventRequest implements IConferenceEventRequest {
    event_id?: string | undefined;
    event_type?: EventType;
    time_stamp_utc?: Date;
    conference_id?: string | undefined;
    participant_id?: string | undefined;
    participant_room_id?: string | undefined;
    transfer_from?: string | undefined;
    transfer_to?: string | undefined;
    reason?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IConferenceEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_id = _data['event_id'];
            this.event_type = _data['event_type'];
            this.time_stamp_utc = _data['time_stamp_utc'] ? new Date(_data['time_stamp_utc'].toString()) : <any>undefined;
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
            this.participant_room_id = _data['participant_room_id'];
            this.transfer_from = _data['transfer_from'];
            this.transfer_to = _data['transfer_to'];
            this.reason = _data['reason'];
            this.phone = _data['phone'];
        }
    }

    static fromJS(data: any): ConferenceEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_id'] = this.event_id;
        data['event_type'] = this.event_type;
        data['time_stamp_utc'] = this.time_stamp_utc ? this.time_stamp_utc.toISOString() : <any>undefined;
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        data['participant_room_id'] = this.participant_room_id;
        data['transfer_from'] = this.transfer_from;
        data['transfer_to'] = this.transfer_to;
        data['reason'] = this.reason;
        data['phone'] = this.phone;
        return data;
    }
}

export interface IConferenceEventRequest {
    event_id?: string | undefined;
    event_type?: EventType;
    time_stamp_utc?: Date;
    conference_id?: string | undefined;
    participant_id?: string | undefined;
    participant_room_id?: string | undefined;
    transfer_from?: string | undefined;
    transfer_to?: string | undefined;
    reason?: string | undefined;
    phone?: string | undefined;
}

export enum HearingLayout {
    Dynamic = 'Dynamic',
    OnePlus7 = 'OnePlus7',
    TwoPlus21 = 'TwoPlus21'
}

export class LinkedParticipantRequest implements ILinkedParticipantRequest {
    participant_ref_id?: string;
    linked_ref_id?: string;
    type?: LinkedParticipantType;

    constructor(data?: ILinkedParticipantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participant_ref_id = _data['participant_ref_id'];
            this.linked_ref_id = _data['linked_ref_id'];
            this.type = _data['type'];
        }
    }

    static fromJS(data: any): LinkedParticipantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedParticipantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['participant_ref_id'] = this.participant_ref_id;
        data['linked_ref_id'] = this.linked_ref_id;
        data['type'] = this.type;
        return data;
    }
}

export interface ILinkedParticipantRequest {
    participant_ref_id?: string;
    linked_ref_id?: string;
    type?: LinkedParticipantType;
}

export class ParticipantRequest implements IParticipantRequest {
    id?: string;
    participant_ref_id?: string;
    name?: string | undefined;
    display_name?: string | undefined;
    username?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    contact_telephone?: string | undefined;
    user_role?: UserRole;
    hearing_role?: string | undefined;
    case_type_group?: string | undefined;
    representee?: string | undefined;
    linked_participants?: LinkedParticipantRequest[] | undefined;

    constructor(data?: IParticipantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.participant_ref_id = _data['participant_ref_id'];
            this.name = _data['name'];
            this.display_name = _data['display_name'];
            this.username = _data['username'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.contact_email = _data['contact_email'];
            this.contact_telephone = _data['contact_telephone'];
            this.user_role = _data['user_role'];
            this.hearing_role = _data['hearing_role'];
            this.case_type_group = _data['case_type_group'];
            this.representee = _data['representee'];
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['participant_ref_id'] = this.participant_ref_id;
        data['name'] = this.name;
        data['display_name'] = this.display_name;
        data['username'] = this.username;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['contact_email'] = this.contact_email;
        data['contact_telephone'] = this.contact_telephone;
        data['user_role'] = this.user_role;
        data['hearing_role'] = this.hearing_role;
        data['case_type_group'] = this.case_type_group;
        data['representee'] = this.representee;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

export interface IParticipantRequest {
    id?: string;
    participant_ref_id?: string;
    name?: string | undefined;
    display_name?: string | undefined;
    username?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    contact_telephone?: string | undefined;
    user_role?: UserRole;
    hearing_role?: string | undefined;
    case_type_group?: string | undefined;
    representee?: string | undefined;
    linked_participants?: LinkedParticipantRequest[] | undefined;
}

export class StartHearingRequest implements IStartHearingRequest {
    layout?: HearingLayout;
    participants_to_force_transfer?: string[] | undefined;
    mute_guests?: boolean | undefined;

    constructor(data?: IStartHearingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layout = _data['layout'];
            if (Array.isArray(_data['participants_to_force_transfer'])) {
                this.participants_to_force_transfer = [] as any;
                for (let item of _data['participants_to_force_transfer']) this.participants_to_force_transfer!.push(item);
            }
            this.mute_guests = _data['mute_guests'];
        }
    }

    static fromJS(data: any): StartHearingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartHearingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['layout'] = this.layout;
        if (Array.isArray(this.participants_to_force_transfer)) {
            data['participants_to_force_transfer'] = [];
            for (let item of this.participants_to_force_transfer) data['participants_to_force_transfer'].push(item);
        }
        data['mute_guests'] = this.mute_guests;
        return data;
    }
}

export interface IStartHearingRequest {
    layout?: HearingLayout;
    participants_to_force_transfer?: string[] | undefined;
    mute_guests?: boolean | undefined;
}

export class UpdateConferenceParticipantsRequest implements IUpdateConferenceParticipantsRequest {
    existing_participants?: UpdateParticipantRequest[] | undefined;
    new_participants?: ParticipantRequest[] | undefined;
    removed_participants?: string[] | undefined;
    linked_participants?: LinkedParticipantRequest[] | undefined;

    constructor(data?: IUpdateConferenceParticipantsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['existing_participants'])) {
                this.existing_participants = [] as any;
                for (let item of _data['existing_participants']) this.existing_participants!.push(UpdateParticipantRequest.fromJS(item));
            }
            if (Array.isArray(_data['new_participants'])) {
                this.new_participants = [] as any;
                for (let item of _data['new_participants']) this.new_participants!.push(ParticipantRequest.fromJS(item));
            }
            if (Array.isArray(_data['removed_participants'])) {
                this.removed_participants = [] as any;
                for (let item of _data['removed_participants']) this.removed_participants!.push(item);
            }
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateConferenceParticipantsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateConferenceParticipantsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.existing_participants)) {
            data['existing_participants'] = [];
            for (let item of this.existing_participants) data['existing_participants'].push(item.toJSON());
        }
        if (Array.isArray(this.new_participants)) {
            data['new_participants'] = [];
            for (let item of this.new_participants) data['new_participants'].push(item.toJSON());
        }
        if (Array.isArray(this.removed_participants)) {
            data['removed_participants'] = [];
            for (let item of this.removed_participants) data['removed_participants'].push(item);
        }
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateConferenceParticipantsRequest {
    existing_participants?: UpdateParticipantRequest[] | undefined;
    new_participants?: ParticipantRequest[] | undefined;
    removed_participants?: string[] | undefined;
    linked_participants?: LinkedParticipantRequest[] | undefined;
}

export class UpdateParticipantRequest implements IUpdateParticipantRequest {
    participant_ref_id?: string;
    fullname?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    representee?: string | undefined;
    contact_email?: string | undefined;
    contact_telephone?: string | undefined;
    username?: string | undefined;
    linked_participants?: LinkedParticipantRequest[] | undefined;

    constructor(data?: IUpdateParticipantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participant_ref_id = _data['participant_ref_id'];
            this.fullname = _data['fullname'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.display_name = _data['display_name'];
            this.representee = _data['representee'];
            this.contact_email = _data['contact_email'];
            this.contact_telephone = _data['contact_telephone'];
            this.username = _data['username'];
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateParticipantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['participant_ref_id'] = this.participant_ref_id;
        data['fullname'] = this.fullname;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['display_name'] = this.display_name;
        data['representee'] = this.representee;
        data['contact_email'] = this.contact_email;
        data['contact_telephone'] = this.contact_telephone;
        data['username'] = this.username;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateParticipantRequest {
    participant_ref_id?: string;
    fullname?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    representee?: string | undefined;
    contact_email?: string | undefined;
    contact_telephone?: string | undefined;
    username?: string | undefined;
    linked_participants?: LinkedParticipantRequest[] | undefined;
}

export class ParticipantHeartbeatResponse implements IParticipantHeartbeatResponse {
    recent_packet_loss?: number;
    browser_name?: string | undefined;
    browser_version?: string | undefined;
    operating_system?: string | undefined;
    operating_system_version?: string | undefined;
    timestamp?: Date;

    constructor(data?: IParticipantHeartbeatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recent_packet_loss = _data['recent_packet_loss'];
            this.browser_name = _data['browser_name'];
            this.browser_version = _data['browser_version'];
            this.operating_system = _data['operating_system'];
            this.operating_system_version = _data['operating_system_version'];
            this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipantHeartbeatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantHeartbeatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['recent_packet_loss'] = this.recent_packet_loss;
        data['browser_name'] = this.browser_name;
        data['browser_version'] = this.browser_version;
        data['operating_system'] = this.operating_system;
        data['operating_system_version'] = this.operating_system_version;
        data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IParticipantHeartbeatResponse {
    recent_packet_loss?: number;
    browser_name?: string | undefined;
    browser_version?: string | undefined;
    operating_system?: string | undefined;
    operating_system_version?: string | undefined;
    timestamp?: Date;
}

export class TaskResponse implements ITaskResponse {
    id?: number;
    origin_id?: string;
    body?: string | undefined;
    type?: TaskType;
    status?: TaskStatus;
    created?: Date;
    updated?: Date | undefined;
    updated_by?: string | undefined;

    constructor(data?: ITaskResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.origin_id = _data['origin_id'];
            this.body = _data['body'];
            this.type = _data['type'];
            this.status = _data['status'];
            this.created = _data['created'] ? new Date(_data['created'].toString()) : <any>undefined;
            this.updated = _data['updated'] ? new Date(_data['updated'].toString()) : <any>undefined;
            this.updated_by = _data['updated_by'];
        }
    }

    static fromJS(data: any): TaskResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['origin_id'] = this.origin_id;
        data['body'] = this.body;
        data['type'] = this.type;
        data['status'] = this.status;
        data['created'] = this.created ? this.created.toISOString() : <any>undefined;
        data['updated'] = this.updated ? this.updated.toISOString() : <any>undefined;
        data['updated_by'] = this.updated_by;
        return data;
    }
}

export interface ITaskResponse {
    id?: number;
    origin_id?: string;
    body?: string | undefined;
    type?: TaskType;
    status?: TaskStatus;
    created?: Date;
    updated?: Date | undefined;
    updated_by?: string | undefined;
}

export class TestCallScoreResponse implements ITestCallScoreResponse {
    score?: TestScore;
    passed?: boolean;

    constructor(data?: ITestCallScoreResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.score = _data['score'];
            this.passed = _data['passed'];
        }
    }

    static fromJS(data: any): TestCallScoreResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestCallScoreResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['score'] = this.score;
        data['passed'] = this.passed;
        return data;
    }
}

export interface ITestCallScoreResponse {
    score?: TestScore;
    passed?: boolean;
}

export enum ConferenceStatus {
    NotStarted = 'NotStarted',
    InSession = 'InSession',
    Paused = 'Paused',
    Suspended = 'Suspended',
    Closed = 'Closed'
}

export class ConferenceVideoControlStatuses implements IConferenceVideoControlStatuses {
    participant_id_to_video_control_status_map?: { [key: string]: VideoControlStatus } | undefined;

    constructor(data?: IConferenceVideoControlStatuses) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data['participant_id_to_video_control_status_map']) {
                this.participant_id_to_video_control_status_map = {} as any;
                for (let key in _data['participant_id_to_video_control_status_map']) {
                    if (_data['participant_id_to_video_control_status_map'].hasOwnProperty(key))
                        (<any>this.participant_id_to_video_control_status_map)![key] = _data['participant_id_to_video_control_status_map'][
                            key
                        ]
                            ? VideoControlStatus.fromJS(_data['participant_id_to_video_control_status_map'][key])
                            : new VideoControlStatus();
                }
            }
        }
    }

    static fromJS(data: any): ConferenceVideoControlStatuses {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceVideoControlStatuses();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.participant_id_to_video_control_status_map) {
            data['participant_id_to_video_control_status_map'] = {};
            for (let key in this.participant_id_to_video_control_status_map) {
                if (this.participant_id_to_video_control_status_map.hasOwnProperty(key))
                    (<any>data['participant_id_to_video_control_status_map'])[key] = this.participant_id_to_video_control_status_map[key]
                        ? this.participant_id_to_video_control_status_map[key].toJSON()
                        : <any>undefined;
            }
        }
        return data;
    }
}

export interface IConferenceVideoControlStatuses {
    participant_id_to_video_control_status_map?: { [key: string]: VideoControlStatus } | undefined;
}

export enum ConsultationAnswer {
    None = 'None',
    Accepted = 'Accepted',
    Rejected = 'Rejected',
    Failed = 'Failed',
    Transferring = 'Transferring'
}

export enum EndpointStatus {
    NotYetJoined = 'NotYetJoined',
    Connected = 'Connected',
    Disconnected = 'Disconnected',
    InConsultation = 'InConsultation'
}

export enum LinkType {
    Interpreter = 'Interpreter'
}

export enum ParticipantStatus {
    None = 'None',
    NotSignedIn = 'NotSignedIn',
    UnableToJoin = 'UnableToJoin',
    Joining = 'Joining',
    Available = 'Available',
    InHearing = 'InHearing',
    InConsultation = 'InConsultation',
    Disconnected = 'Disconnected'
}

export enum Role {
    None = 'None',
    CaseAdmin = 'CaseAdmin',
    VideoHearingsOfficer = 'VideoHearingsOfficer',
    HearingFacilitationSupport = 'HearingFacilitationSupport',
    Judge = 'Judge',
    Individual = 'Individual',
    Representative = 'Representative',
    JudicialOfficeHolder = 'JudicialOfficeHolder',
    QuickLinkParticipant = 'QuickLinkParticipant',
    QuickLinkObserver = 'QuickLinkObserver',
    StaffMember = 'StaffMember'
}

export class VideoControlStatus implements IVideoControlStatus {
    is_remote_muted?: boolean;
    is_hand_raised?: boolean;
    is_spotlighted?: boolean;
    is_local_audio_muted?: boolean;
    is_local_video_muted?: boolean;

    constructor(data?: IVideoControlStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.is_remote_muted = _data['is_remote_muted'];
            this.is_hand_raised = _data['is_hand_raised'];
            this.is_spotlighted = _data['is_spotlighted'];
            this.is_local_audio_muted = _data['is_local_audio_muted'];
            this.is_local_video_muted = _data['is_local_video_muted'];
        }
    }

    static fromJS(data: any): VideoControlStatus {
        data = typeof data === 'object' ? data : {};
        let result = new VideoControlStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['is_remote_muted'] = this.is_remote_muted;
        data['is_hand_raised'] = this.is_hand_raised;
        data['is_spotlighted'] = this.is_spotlighted;
        data['is_local_audio_muted'] = this.is_local_audio_muted;
        data['is_local_video_muted'] = this.is_local_video_muted;
        return data;
    }
}

export interface IVideoControlStatus {
    is_remote_muted?: boolean;
    is_hand_raised?: boolean;
    is_spotlighted?: boolean;
    is_local_audio_muted?: boolean;
    is_local_video_muted?: boolean;
}

export enum VirtualCourtRoomType {
    JudgeJOH = 'JudgeJOH',
    Participant = 'Participant'
}

export class AddEndpointConsultationRequest implements IAddEndpointConsultationRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The id of the endpoint you would like to invite into the consultation */
    endpoint_id?: string;

    constructor(data?: IAddEndpointConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.room_label = _data['room_label'];
            this.endpoint_id = _data['endpoint_id'];
        }
    }

    static fromJS(data: any): AddEndpointConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddEndpointConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['room_label'] = this.room_label;
        data['endpoint_id'] = this.endpoint_id;
        return data;
    }
}

export interface IAddEndpointConsultationRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The id of the endpoint you would like to invite into the consultation */
    endpoint_id?: string;
}

export class AddMediaEventRequest implements IAddMediaEventRequest {
    event_type?: EventType;

    constructor(data?: IAddMediaEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_type = _data['event_type'];
        }
    }

    static fromJS(data: any): AddMediaEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddMediaEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        return data;
    }
}

export interface IAddMediaEventRequest {
    event_type?: EventType;
}

export class AddSelfTestFailureEventRequest implements IAddSelfTestFailureEventRequest {
    event_type?: EventType;
    self_test_failure_reason?: SelfTestFailureReason;

    constructor(data?: IAddSelfTestFailureEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_type = _data['event_type'];
            this.self_test_failure_reason = _data['self_test_failure_reason'];
        }
    }

    static fromJS(data: any): AddSelfTestFailureEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddSelfTestFailureEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        data['self_test_failure_reason'] = this.self_test_failure_reason;
        return data;
    }
}

export interface IAddSelfTestFailureEventRequest {
    event_type?: EventType;
    self_test_failure_reason?: SelfTestFailureReason;
}

export class InviteToConsultationRequest implements IInviteToConsultationRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The id of the participant you would like to invite into the consultation */
    participant_id?: string;

    constructor(data?: IInviteToConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.room_label = _data['room_label'];
            this.participant_id = _data['participant_id'];
        }
    }

    static fromJS(data: any): InviteToConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InviteToConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['room_label'] = this.room_label;
        data['participant_id'] = this.participant_id;
        return data;
    }
}

export interface IInviteToConsultationRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The id of the participant you would like to invite into the consultation */
    participant_id?: string;
}

export class JoinPrivateConsultationRequest implements IJoinPrivateConsultationRequest {
    conference_id?: string;
    participant_id?: string;
    room_label?: string | undefined;

    constructor(data?: IJoinPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
            this.room_label = _data['room_label'];
        }
    }

    static fromJS(data: any): JoinPrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JoinPrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        data['room_label'] = this.room_label;
        return data;
    }
}

export interface IJoinPrivateConsultationRequest {
    conference_id?: string;
    participant_id?: string;
    room_label?: string | undefined;
}

/** Leave a private consultation */
export class LeavePrivateConsultationRequest implements ILeavePrivateConsultationRequest {
    /** The id of the conference */
    conference_id?: string;
    /** The id of the participant */
    participant_id?: string;

    constructor(data?: ILeavePrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
        }
    }

    static fromJS(data: any): LeavePrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        return data;
    }
}

/** Leave a private consultation */
export interface ILeavePrivateConsultationRequest {
    /** The id of the conference */
    conference_id?: string;
    /** The id of the participant */
    participant_id?: string;
}

export class LockConsultationRoomRequest implements ILockConsultationRoomRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The desired lock state of the room */
    lock?: boolean;

    constructor(data?: ILockConsultationRoomRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.room_label = _data['room_label'];
            this.lock = _data['lock'];
        }
    }

    static fromJS(data: any): LockConsultationRoomRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LockConsultationRoomRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['room_label'] = this.room_label;
        data['lock'] = this.lock;
        return data;
    }
}

export interface ILockConsultationRoomRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The desired lock state of the room */
    lock?: boolean;
}

/** Raise or respond to a private consultation request */
export class PrivateConsultationRequest implements IPrivateConsultationRequest {
    /** ID unique to the request */
    invitation_id?: string;
    /** Conference ID */
    conference_id?: string;
    /** Id of participant requesting consultation */
    requested_by_id?: string;
    /** Id of participant requesting consultation with */
    requested_for_id?: string;
    answer?: ConsultationAnswer;
    /** The room to have a private consultation in */
    room_label?: string | undefined;

    constructor(data?: IPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invitation_id = _data['invitation_id'];
            this.conference_id = _data['conference_id'];
            this.requested_by_id = _data['requested_by_id'];
            this.requested_for_id = _data['requested_for_id'];
            this.answer = _data['answer'];
            this.room_label = _data['room_label'];
        }
    }

    static fromJS(data: any): PrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['invitation_id'] = this.invitation_id;
        data['conference_id'] = this.conference_id;
        data['requested_by_id'] = this.requested_by_id;
        data['requested_for_id'] = this.requested_for_id;
        data['answer'] = this.answer;
        data['room_label'] = this.room_label;
        return data;
    }
}

/** Raise or respond to a private consultation request */
export interface IPrivateConsultationRequest {
    /** ID unique to the request */
    invitation_id?: string;
    /** Conference ID */
    conference_id?: string;
    /** Id of participant requesting consultation */
    requested_by_id?: string;
    /** Id of participant requesting consultation with */
    requested_for_id?: string;
    answer?: ConsultationAnswer;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
}

export class QuickLinkParticipantJoinRequest implements IQuickLinkParticipantJoinRequest {
    name?: string | undefined;
    role?: Role;

    constructor(data?: IQuickLinkParticipantJoinRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data['name'];
            this.role = _data['role'];
        }
    }

    static fromJS(data: any): QuickLinkParticipantJoinRequest {
        data = typeof data === 'object' ? data : {};
        let result = new QuickLinkParticipantJoinRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['name'] = this.name;
        data['role'] = this.role;
        return data;
    }
}

export interface IQuickLinkParticipantJoinRequest {
    name?: string | undefined;
    role?: Role;
}

export enum SelfTestFailureReason {
    Camera = 'Camera',
    Microphone = 'Microphone',
    Video = 'Video',
    BadScore = 'BadScore',
    IncompleteTest = 'IncompleteTest'
}

export class SetConferenceVideoControlStatusesRequest implements ISetConferenceVideoControlStatusesRequest {
    participant_id_to_video_control_status_map?:
        | { [key: string]: SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest }
        | undefined;

    constructor(data?: ISetConferenceVideoControlStatusesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data['participant_id_to_video_control_status_map']) {
                this.participant_id_to_video_control_status_map = {} as any;
                for (let key in _data['participant_id_to_video_control_status_map']) {
                    if (_data['participant_id_to_video_control_status_map'].hasOwnProperty(key))
                        (<any>this.participant_id_to_video_control_status_map)![key] = _data['participant_id_to_video_control_status_map'][
                            key
                        ]
                            ? SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest.fromJS(
                                  _data['participant_id_to_video_control_status_map'][key]
                              )
                            : new SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest();
                }
            }
        }
    }

    static fromJS(data: any): SetConferenceVideoControlStatusesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetConferenceVideoControlStatusesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.participant_id_to_video_control_status_map) {
            data['participant_id_to_video_control_status_map'] = {};
            for (let key in this.participant_id_to_video_control_status_map) {
                if (this.participant_id_to_video_control_status_map.hasOwnProperty(key))
                    (<any>data['participant_id_to_video_control_status_map'])[key] = this.participant_id_to_video_control_status_map[key]
                        ? this.participant_id_to_video_control_status_map[key].toJSON()
                        : <any>undefined;
            }
        }
        return data;
    }
}

export interface ISetConferenceVideoControlStatusesRequest {
    participant_id_to_video_control_status_map?:
        | { [key: string]: SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest }
        | undefined;
}

export class SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest
    implements ISetConferenceVideoControlStatusesRequest_VideoControlStatusRequest
{
    is_spotlighted?: boolean;
    is_local_audio_muted?: boolean;
    is_remote_muted?: boolean;
    is_hand_raised?: boolean;
    is_local_video_muted?: boolean;

    constructor(data?: ISetConferenceVideoControlStatusesRequest_VideoControlStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.is_spotlighted = _data['is_spotlighted'];
            this.is_local_audio_muted = _data['is_local_audio_muted'];
            this.is_remote_muted = _data['is_remote_muted'];
            this.is_hand_raised = _data['is_hand_raised'];
            this.is_local_video_muted = _data['is_local_video_muted'];
        }
    }

    static fromJS(data: any): SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['is_spotlighted'] = this.is_spotlighted;
        data['is_local_audio_muted'] = this.is_local_audio_muted;
        data['is_remote_muted'] = this.is_remote_muted;
        data['is_hand_raised'] = this.is_hand_raised;
        data['is_local_video_muted'] = this.is_local_video_muted;
        return data;
    }
}

export interface ISetConferenceVideoControlStatusesRequest_VideoControlStatusRequest {
    is_spotlighted?: boolean;
    is_local_audio_muted?: boolean;
    is_remote_muted?: boolean;
    is_hand_raised?: boolean;
    is_local_video_muted?: boolean;
}

export class StaffMemberJoinConferenceRequest implements IStaffMemberJoinConferenceRequest {
    /** Staff Member Username */
    username?: string | undefined;

    constructor(data?: IStaffMemberJoinConferenceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data['username'];
        }
    }

    static fromJS(data: any): StaffMemberJoinConferenceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StaffMemberJoinConferenceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['username'] = this.username;
        return data;
    }
}

export interface IStaffMemberJoinConferenceRequest {
    /** Staff Member Username */
    username?: string | undefined;
}

export class StartPrivateConsultationRequest implements IStartPrivateConsultationRequest {
    invite_participants?: string[] | undefined;
    invite_endpoints?: string[] | undefined;
    conference_id?: string;
    requested_by?: string;
    room_type?: VirtualCourtRoomType;

    constructor(data?: IStartPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['invite_participants'])) {
                this.invite_participants = [] as any;
                for (let item of _data['invite_participants']) this.invite_participants!.push(item);
            }
            if (Array.isArray(_data['invite_endpoints'])) {
                this.invite_endpoints = [] as any;
                for (let item of _data['invite_endpoints']) this.invite_endpoints!.push(item);
            }
            this.conference_id = _data['conference_id'];
            this.requested_by = _data['requested_by'];
            this.room_type = _data['room_type'];
        }
    }

    static fromJS(data: any): StartPrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartPrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.invite_participants)) {
            data['invite_participants'] = [];
            for (let item of this.invite_participants) data['invite_participants'].push(item);
        }
        if (Array.isArray(this.invite_endpoints)) {
            data['invite_endpoints'] = [];
            for (let item of this.invite_endpoints) data['invite_endpoints'].push(item);
        }
        data['conference_id'] = this.conference_id;
        data['requested_by'] = this.requested_by;
        data['room_type'] = this.room_type;
        return data;
    }
}

export interface IStartPrivateConsultationRequest {
    invite_participants?: string[] | undefined;
    invite_endpoints?: string[] | undefined;
    conference_id?: string;
    requested_by?: string;
    room_type?: VirtualCourtRoomType;
}

export class UpdateParticipantDisplayNameRequest implements IUpdateParticipantDisplayNameRequest {
    /** Participant Fullname */
    fullname?: string | undefined;
    /** Participant FirstName */
    first_name?: string | undefined;
    /** Participant LastName */
    last_name?: string | undefined;
    /** Participant Display Name */
    display_name?: string | undefined;
    /** Representee */
    representee?: string | undefined;

    constructor(data?: IUpdateParticipantDisplayNameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullname = _data['fullname'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.display_name = _data['display_name'];
            this.representee = _data['representee'];
        }
    }

    static fromJS(data: any): UpdateParticipantDisplayNameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantDisplayNameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['fullname'] = this.fullname;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['display_name'] = this.display_name;
        data['representee'] = this.representee;
        return data;
    }
}

export interface IUpdateParticipantDisplayNameRequest {
    /** Participant Fullname */
    fullname?: string | undefined;
    /** Participant FirstName */
    first_name?: string | undefined;
    /** Participant LastName */
    last_name?: string | undefined;
    /** Participant Display Name */
    display_name?: string | undefined;
    /** Representee */
    representee?: string | undefined;
}

export class UpdateParticipantStatusEventRequest implements IUpdateParticipantStatusEventRequest {
    event_type?: EventType;

    constructor(data?: IUpdateParticipantStatusEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_type = _data['event_type'];
        }
    }

    static fromJS(data: any): UpdateParticipantStatusEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantStatusEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        return data;
    }
}

export interface IUpdateParticipantStatusEventRequest {
    event_type?: EventType;
}

export class AllowedEndpointResponse implements IAllowedEndpointResponse {
    id?: string;
    display_name?: string | undefined;
    defence_advocate_username?: string | undefined;

    constructor(data?: IAllowedEndpointResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.display_name = _data['display_name'];
            this.defence_advocate_username = _data['defence_advocate_username'];
        }
    }

    static fromJS(data: any): AllowedEndpointResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AllowedEndpointResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['display_name'] = this.display_name;
        data['defence_advocate_username'] = this.defence_advocate_username;
        return data;
    }
}

export interface IAllowedEndpointResponse {
    id?: string;
    display_name?: string | undefined;
    defence_advocate_username?: string | undefined;
}

export class ApplicationVersion implements IApplicationVersion {
    file_version?: string | undefined;
    information_version?: string | undefined;

    constructor(data?: IApplicationVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file_version = _data['file_version'];
            this.information_version = _data['information_version'];
        }
    }

    static fromJS(data: any): ApplicationVersion {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['file_version'] = this.file_version;
        data['information_version'] = this.information_version;
        return data;
    }
}

export interface IApplicationVersion {
    file_version?: string | undefined;
    information_version?: string | undefined;
}

export class ChatResponse implements IChatResponse {
    /** Message UUID */
    readonly id?: string;
    /** Username of sender */
    from?: string | undefined;
    /** Display name of sender */
    from_display_name?: string | undefined;
    /** Username of recipient */
    to?: string | undefined;
    /** Body of message */
    message?: string | undefined;
    /** Time of message */
    timestamp?: Date;
    /** Did the message originate from user logged in */
    is_user?: boolean;

    constructor(data?: IChatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data['id'];
            this.from = _data['from'];
            this.from_display_name = _data['from_display_name'];
            this.to = _data['to'];
            this.message = _data['message'];
            this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
            this.is_user = _data['is_user'];
        }
    }

    static fromJS(data: any): ChatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['from'] = this.from;
        data['from_display_name'] = this.from_display_name;
        data['to'] = this.to;
        data['message'] = this.message;
        data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data['is_user'] = this.is_user;
        return data;
    }
}

export interface IChatResponse {
    /** Message UUID */
    id?: string;
    /** Username of sender */
    from?: string | undefined;
    /** Display name of sender */
    from_display_name?: string | undefined;
    /** Username of recipient */
    to?: string | undefined;
    /** Body of message */
    message?: string | undefined;
    /** Time of message */
    timestamp?: Date;
    /** Did the message originate from user logged in */
    is_user?: boolean;
}

/** Configuration to initialise the UI application */
export class ClientSettingsResponse implements IClientSettingsResponse {
    /** The application insight instrumentation key */
    app_insights_instrumentation_key?: string | undefined;
    /** The eventhub path */
    event_hub_path?: string | undefined;
    /** The date to set option ON to display functionality to join hearing by phone */
    join_by_phone_from_date?: string | undefined;
    /** The turn server */
    kinly_turn_server?: string | undefined;
    /** The turn server username */
    kinly_turn_server_user?: string | undefined;
    /** The turn server password */
    kinly_turn_server_credential?: string | undefined;
    e_jud_idp_settings?: IdpSettingsResponse;
    vh_idp_settings?: IdpSettingsResponse;
    /** Enable video filters */
    enable_video_filters?: boolean;
    /** Enable Android support */
    enable_android_support?: boolean;
    /** Enable iOS mobile support */
    enable_ios_mobile_support?: boolean;
    /** Enable iOS tablet support */
    enable_ios_tablet_support?: boolean;
    /** Enable dynamic evidence sharing button */
    enable_dynamic_evidence_sharing?: boolean;
    /** Blur radius in pixels */
    blur_radius?: number;

    constructor(data?: IClientSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.app_insights_instrumentation_key = _data['app_insights_instrumentation_key'];
            this.event_hub_path = _data['event_hub_path'];
            this.join_by_phone_from_date = _data['join_by_phone_from_date'];
            this.kinly_turn_server = _data['kinly_turn_server'];
            this.kinly_turn_server_user = _data['kinly_turn_server_user'];
            this.kinly_turn_server_credential = _data['kinly_turn_server_credential'];
            this.e_jud_idp_settings = _data['e_jud_idp_settings']
                ? IdpSettingsResponse.fromJS(_data['e_jud_idp_settings'])
                : <any>undefined;
            this.vh_idp_settings = _data['vh_idp_settings'] ? IdpSettingsResponse.fromJS(_data['vh_idp_settings']) : <any>undefined;
            this.enable_video_filters = _data['enable_video_filters'];
            this.enable_android_support = _data['enable_android_support'];
            this.enable_ios_mobile_support = _data['enable_ios_mobile_support'];
            this.enable_ios_tablet_support = _data['enable_ios_tablet_support'];
            this.enable_dynamic_evidence_sharing = _data['enable_dynamic_evidence_sharing'];
            this.blur_radius = _data['blur_radius'];
        }
    }

    static fromJS(data: any): ClientSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['app_insights_instrumentation_key'] = this.app_insights_instrumentation_key;
        data['event_hub_path'] = this.event_hub_path;
        data['join_by_phone_from_date'] = this.join_by_phone_from_date;
        data['kinly_turn_server'] = this.kinly_turn_server;
        data['kinly_turn_server_user'] = this.kinly_turn_server_user;
        data['kinly_turn_server_credential'] = this.kinly_turn_server_credential;
        data['e_jud_idp_settings'] = this.e_jud_idp_settings ? this.e_jud_idp_settings.toJSON() : <any>undefined;
        data['vh_idp_settings'] = this.vh_idp_settings ? this.vh_idp_settings.toJSON() : <any>undefined;
        data['enable_video_filters'] = this.enable_video_filters;
        data['enable_android_support'] = this.enable_android_support;
        data['enable_ios_mobile_support'] = this.enable_ios_mobile_support;
        data['enable_ios_tablet_support'] = this.enable_ios_tablet_support;
        data['enable_dynamic_evidence_sharing'] = this.enable_dynamic_evidence_sharing;
        data['blur_radius'] = this.blur_radius;
        return data;
    }
}

/** Configuration to initialise the UI application */
export interface IClientSettingsResponse {
    /** The application insight instrumentation key */
    app_insights_instrumentation_key?: string | undefined;
    /** The eventhub path */
    event_hub_path?: string | undefined;
    /** The date to set option ON to display functionality to join hearing by phone */
    join_by_phone_from_date?: string | undefined;
    /** The turn server */
    kinly_turn_server?: string | undefined;
    /** The turn server username */
    kinly_turn_server_user?: string | undefined;
    /** The turn server password */
    kinly_turn_server_credential?: string | undefined;
    e_jud_idp_settings?: IdpSettingsResponse;
    vh_idp_settings?: IdpSettingsResponse;
    /** Enable video filters */
    enable_video_filters?: boolean;
    /** Enable Android support */
    enable_android_support?: boolean;
    /** Enable iOS mobile support */
    enable_ios_mobile_support?: boolean;
    /** Enable iOS tablet support */
    enable_ios_tablet_support?: boolean;
    /** Enable dynamic evidence sharing button */
    enable_dynamic_evidence_sharing?: boolean;
    /** Blur radius in pixels */
    blur_radius?: number;
}

export class ConferenceForHostResponse implements IConferenceForHostResponse {
    /** Conference UUID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The scheduled duration in minutes */
    scheduled_duration?: number;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForHostResponse[] | undefined;
    /** The number of hearing endpoints */
    number_of_endpoints?: number;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;

    constructor(data?: IConferenceForHostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantForHostResponse.fromJS(item));
            }
            this.number_of_endpoints = _data['number_of_endpoints'];
            this.hearing_venue_is_scottish = _data['hearing_venue_is_scottish'];
        }
    }

    static fromJS(data: any): ConferenceForHostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForHostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['number_of_endpoints'] = this.number_of_endpoints;
        data['hearing_venue_is_scottish'] = this.hearing_venue_is_scottish;
        return data;
    }
}

export interface IConferenceForHostResponse {
    /** Conference UUID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The scheduled duration in minutes */
    scheduled_duration?: number;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForHostResponse[] | undefined;
    /** The number of hearing endpoints */
    number_of_endpoints?: number;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;
}

export class ConferenceForIndividualResponse implements IConferenceForIndividualResponse {
    /** Conference UUID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The conference closed datetime */
    closed_date_time?: Date | undefined;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;

    constructor(data?: IConferenceForIndividualResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.hearing_venue_is_scottish = _data['hearing_venue_is_scottish'];
        }
    }

    static fromJS(data: any): ConferenceForIndividualResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForIndividualResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['hearing_venue_is_scottish'] = this.hearing_venue_is_scottish;
        return data;
    }
}

export interface IConferenceForIndividualResponse {
    /** Conference UUID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The conference closed datetime */
    closed_date_time?: Date | undefined;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;
}

export class ConferenceForVhOfficerResponse implements IConferenceForVhOfficerResponse {
    /** Conference ID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    /** The scheduled duration in minutes */
    scheduled_duration?: number;
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForUserResponse[] | undefined;
    /** The name of the hearing venue */
    hearing_venue_name?: string | undefined;
    /** Started date time as UTC */
    started_date_time?: Date | undefined;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The telephone Id of the conference */
    telephone_conference_id?: string | undefined;
    /** The telephone conference number to dial */
    telephone_conference_numbers?: string | undefined;
    /** Created date time as UTC */
    created_date_time?: Date | undefined;

    constructor(data?: IConferenceForVhOfficerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.scheduled_duration = _data['scheduled_duration'];
            this.status = _data['status'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantForUserResponse.fromJS(item));
            }
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.started_date_time = _data['started_date_time'] ? new Date(_data['started_date_time'].toString()) : <any>undefined;
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.telephone_conference_id = _data['telephone_conference_id'];
            this.telephone_conference_numbers = _data['telephone_conference_numbers'];
            this.created_date_time = _data['created_date_time'] ? new Date(_data['created_date_time'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConferenceForVhOfficerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForVhOfficerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['scheduled_duration'] = this.scheduled_duration;
        data['status'] = this.status;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['started_date_time'] = this.started_date_time ? this.started_date_time.toISOString() : <any>undefined;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['telephone_conference_id'] = this.telephone_conference_id;
        data['telephone_conference_numbers'] = this.telephone_conference_numbers;
        data['created_date_time'] = this.created_date_time ? this.created_date_time.toISOString() : <any>undefined;
        return data;
    }
}

export interface IConferenceForVhOfficerResponse {
    /** Conference ID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    /** The scheduled duration in minutes */
    scheduled_duration?: number;
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForUserResponse[] | undefined;
    /** The name of the hearing venue */
    hearing_venue_name?: string | undefined;
    /** Started date time as UTC */
    started_date_time?: Date | undefined;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The telephone Id of the conference */
    telephone_conference_id?: string | undefined;
    /** The telephone conference number to dial */
    telephone_conference_numbers?: string | undefined;
    /** Created date time as UTC */
    created_date_time?: Date | undefined;
}

/** Detailed information about a conference */
export class ConferenceResponse implements IConferenceResponse {
    /** Conference ID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** Scheduled duration in minutes */
    scheduled_duration?: number;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The participant meeting room uri */
    participant_uri?: string | undefined;
    /** The pexip node to connect to */
    pexip_node_uri?: string | undefined;
    /** The pexip self-test node to connect to */
    pexip_self_test_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponse[] | undefined;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The name of venue */
    hearing_venue_name?: string | undefined;
    /** The options indicated hearing audio recording */
    audio_recording_required?: boolean;
    /** The hearing Id */
    hearing_ref_id?: string;
    /** The video access endpoints in the conference */
    endpoints?: VideoEndpointResponse[] | undefined;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;
    /** Property to indicate whether wowza recording is via single app setup or bespoke hearing setup */
    wowza_single_app?: boolean;

    constructor(data?: IConferenceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.participant_uri = _data['participant_uri'];
            this.pexip_node_uri = _data['pexip_node_uri'];
            this.pexip_self_test_node_uri = _data['pexip_self_test_node_uri'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantResponse.fromJS(item));
            }
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.audio_recording_required = _data['audio_recording_required'];
            this.hearing_ref_id = _data['hearing_ref_id'];
            if (Array.isArray(_data['endpoints'])) {
                this.endpoints = [] as any;
                for (let item of _data['endpoints']) this.endpoints!.push(VideoEndpointResponse.fromJS(item));
            }
            this.hearing_venue_is_scottish = _data['hearing_venue_is_scottish'];
            this.wowza_single_app = _data['wowza_single_app'];
        }
    }

    static fromJS(data: any): ConferenceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['participant_uri'] = this.participant_uri;
        data['pexip_node_uri'] = this.pexip_node_uri;
        data['pexip_self_test_node_uri'] = this.pexip_self_test_node_uri;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['audio_recording_required'] = this.audio_recording_required;
        data['hearing_ref_id'] = this.hearing_ref_id;
        if (Array.isArray(this.endpoints)) {
            data['endpoints'] = [];
            for (let item of this.endpoints) data['endpoints'].push(item.toJSON());
        }
        data['hearing_venue_is_scottish'] = this.hearing_venue_is_scottish;
        data['wowza_single_app'] = this.wowza_single_app;
        return data;
    }
}

/** Detailed information about a conference */
export interface IConferenceResponse {
    /** Conference ID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** Scheduled duration in minutes */
    scheduled_duration?: number;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The participant meeting room uri */
    participant_uri?: string | undefined;
    /** The pexip node to connect to */
    pexip_node_uri?: string | undefined;
    /** The pexip self-test node to connect to */
    pexip_self_test_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponse[] | undefined;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The name of venue */
    hearing_venue_name?: string | undefined;
    /** The options indicated hearing audio recording */
    audio_recording_required?: boolean;
    /** The hearing Id */
    hearing_ref_id?: string;
    /** The video access endpoints in the conference */
    endpoints?: VideoEndpointResponse[] | undefined;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;
    /** Property to indicate whether wowza recording is via single app setup or bespoke hearing setup */
    wowza_single_app?: boolean;
}

/** Detailed information about a conference for VHO officer */
export class ConferenceResponseVho implements IConferenceResponseVho {
    /** Conference ID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** Scheduled duration in minutes */
    scheduled_duration?: number;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The uri of the Admin iFrame */
    admin_i_frame_uri?: string | undefined;
    /** The participant meeting room uri */
    participant_uri?: string | undefined;
    /** The pexip node to connect to */
    pexip_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponseVho[] | undefined;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The name of venue */
    hearing_venue_name?: string | undefined;
    /** The hearing id of the video hearing conference */
    hearing_id?: string;

    constructor(data?: IConferenceResponseVho) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.admin_i_frame_uri = _data['admin_i_frame_uri'];
            this.participant_uri = _data['participant_uri'];
            this.pexip_node_uri = _data['pexip_node_uri'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantResponseVho.fromJS(item));
            }
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.hearing_id = _data['hearing_id'];
        }
    }

    static fromJS(data: any): ConferenceResponseVho {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceResponseVho();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['admin_i_frame_uri'] = this.admin_i_frame_uri;
        data['participant_uri'] = this.participant_uri;
        data['pexip_node_uri'] = this.pexip_node_uri;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['hearing_id'] = this.hearing_id;
        return data;
    }
}

/** Detailed information about a conference for VHO officer */
export interface IConferenceResponseVho {
    /** Conference ID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** Scheduled duration in minutes */
    scheduled_duration?: number;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The uri of the Admin iFrame */
    admin_i_frame_uri?: string | undefined;
    /** The participant meeting room uri */
    participant_uri?: string | undefined;
    /** The pexip node to connect to */
    pexip_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponseVho[] | undefined;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The name of venue */
    hearing_venue_name?: string | undefined;
    /** The hearing id of the video hearing conference */
    hearing_id?: string;
}

export class CourtRoomsAccountResponse implements ICourtRoomsAccountResponse {
    /** The venue name (judge first name) */
    first_name?: string | undefined;
    /** The list of court rooms (judge last name) */
    last_names?: string[] | undefined;

    constructor(data?: ICourtRoomsAccountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.first_name = _data['first_name'];
            if (Array.isArray(_data['last_names'])) {
                this.last_names = [] as any;
                for (let item of _data['last_names']) this.last_names!.push(item);
            }
        }
    }

    static fromJS(data: any): CourtRoomsAccountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CourtRoomsAccountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['first_name'] = this.first_name;
        if (Array.isArray(this.last_names)) {
            data['last_names'] = [];
            for (let item of this.last_names) data['last_names'].push(item);
        }
        return data;
    }
}

export interface ICourtRoomsAccountResponse {
    /** The venue name (judge first name) */
    first_name?: string | undefined;
    /** The list of court rooms (judge last name) */
    last_names?: string[] | undefined;
}

export class HealthCheck implements IHealthCheck {
    successful?: boolean;
    error_message?: string | undefined;
    data?: { [key: string]: any } | undefined;

    constructor(data?: IHealthCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.successful = _data['successful'];
            this.error_message = _data['error_message'];
            if (_data['data']) {
                this.data = {} as any;
                for (let key in _data['data']) {
                    if (_data['data'].hasOwnProperty(key)) (<any>this.data)![key] = _data['data'][key];
                }
            }
        }
    }

    static fromJS(data: any): HealthCheck {
        data = typeof data === 'object' ? data : {};
        let result = new HealthCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['successful'] = this.successful;
        data['error_message'] = this.error_message;
        if (this.data) {
            data['data'] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key)) (<any>data['data'])[key] = (<any>this.data)[key];
            }
        }
        return data;
    }
}

export interface IHealthCheck {
    successful?: boolean;
    error_message?: string | undefined;
    data?: { [key: string]: any } | undefined;
}

export class HealthCheckResponse implements IHealthCheckResponse {
    bookings_api_health?: HealthCheck;
    user_api_health?: HealthCheck;
    video_api_health?: HealthCheck;
    app_version?: ApplicationVersion;

    constructor(data?: IHealthCheckResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookings_api_health = _data['bookings_api_health'] ? HealthCheck.fromJS(_data['bookings_api_health']) : <any>undefined;
            this.user_api_health = _data['user_api_health'] ? HealthCheck.fromJS(_data['user_api_health']) : <any>undefined;
            this.video_api_health = _data['video_api_health'] ? HealthCheck.fromJS(_data['video_api_health']) : <any>undefined;
            this.app_version = _data['app_version'] ? ApplicationVersion.fromJS(_data['app_version']) : <any>undefined;
        }
    }

    static fromJS(data: any): HealthCheckResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HealthCheckResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['bookings_api_health'] = this.bookings_api_health ? this.bookings_api_health.toJSON() : <any>undefined;
        data['user_api_health'] = this.user_api_health ? this.user_api_health.toJSON() : <any>undefined;
        data['video_api_health'] = this.video_api_health ? this.video_api_health.toJSON() : <any>undefined;
        data['app_version'] = this.app_version ? this.app_version.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHealthCheckResponse {
    bookings_api_health?: HealthCheck;
    user_api_health?: HealthCheck;
    video_api_health?: HealthCheck;
    app_version?: ApplicationVersion;
}

export class HeartbeatConfigurationResponse implements IHeartbeatConfigurationResponse {
    heartbeat_url_base?: string | undefined;
    heartbeat_jwt?: string | undefined;

    constructor(data?: IHeartbeatConfigurationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.heartbeat_url_base = _data['heartbeat_url_base'];
            this.heartbeat_jwt = _data['heartbeat_jwt'];
        }
    }

    static fromJS(data: any): HeartbeatConfigurationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HeartbeatConfigurationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['heartbeat_url_base'] = this.heartbeat_url_base;
        data['heartbeat_jwt'] = this.heartbeat_jwt;
        return data;
    }
}

export interface IHeartbeatConfigurationResponse {
    heartbeat_url_base?: string | undefined;
    heartbeat_jwt?: string | undefined;
}

export class IdpSettingsResponse implements IIdpSettingsResponse {
    /** The Azure Tenant Id */
    tenant_id?: string | undefined;
    /** The UI Client Id */
    client_id?: string | undefined;
    /** The UI Resource Id, can be used as an alternative id to ClientId for authentication */
    resource_id?: string | undefined;
    /** The Uri to redirect back to after a successful login */
    redirect_uri?: string | undefined;
    /** The Uri to redirect back to after a successful logout */
    post_logout_redirect_uri?: string | undefined;

    constructor(data?: IIdpSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenant_id = _data['tenant_id'];
            this.client_id = _data['client_id'];
            this.resource_id = _data['resource_id'];
            this.redirect_uri = _data['redirect_uri'];
            this.post_logout_redirect_uri = _data['post_logout_redirect_uri'];
        }
    }

    static fromJS(data: any): IdpSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IdpSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['tenant_id'] = this.tenant_id;
        data['client_id'] = this.client_id;
        data['resource_id'] = this.resource_id;
        data['redirect_uri'] = this.redirect_uri;
        data['post_logout_redirect_uri'] = this.post_logout_redirect_uri;
        return data;
    }
}

export interface IIdpSettingsResponse {
    /** The Azure Tenant Id */
    tenant_id?: string | undefined;
    /** The UI Client Id */
    client_id?: string | undefined;
    /** The UI Resource Id, can be used as an alternative id to ClientId for authentication */
    resource_id?: string | undefined;
    /** The Uri to redirect back to after a successful login */
    redirect_uri?: string | undefined;
    /** The Uri to redirect back to after a successful logout */
    post_logout_redirect_uri?: string | undefined;
}

export class LinkedParticipantResponse implements ILinkedParticipantResponse {
    /** The id of the participant linked to */
    linked_id?: string;
    link_type?: LinkType;

    constructor(data?: ILinkedParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linked_id = _data['linked_id'];
            this.link_type = _data['link_type'];
        }
    }

    static fromJS(data: any): LinkedParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['linked_id'] = this.linked_id;
        data['link_type'] = this.link_type;
        return data;
    }
}

export interface ILinkedParticipantResponse {
    /** The id of the participant linked to */
    linked_id?: string;
    link_type?: LinkType;
}

export class LoggedParticipantResponse implements ILoggedParticipantResponse {
    participant_id?: string;
    admin_username?: string | undefined;
    role?: Role;
    display_name?: string | undefined;

    constructor(data?: ILoggedParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participant_id = _data['participant_id'];
            this.admin_username = _data['admin_username'];
            this.role = _data['role'];
            this.display_name = _data['display_name'];
        }
    }

    static fromJS(data: any): LoggedParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoggedParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['participant_id'] = this.participant_id;
        data['admin_username'] = this.admin_username;
        data['role'] = this.role;
        data['display_name'] = this.display_name;
        return data;
    }
}

export interface ILoggedParticipantResponse {
    participant_id?: string;
    admin_username?: string | undefined;
    role?: Role;
    display_name?: string | undefined;
}

export class ParticipantContactDetailsResponseVho implements IParticipantContactDetailsResponseVho {
    /** The participant id in a conference */
    id?: string;
    /** The conference id */
    conference_id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    role?: Role;
    /** The participant's hearing role */
    hearing_role?: string | undefined;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The group a participant belongs to in a case */
    case_type_group?: string | undefined;
    /** The participant hearing ref id in a booking */
    ref_id?: string;
    /** The participant's first name */
    first_name?: string | undefined;
    /** The participant's last name */
    last_name?: string | undefined;
    /** The participant's contact email */
    contact_email?: string | undefined;
    /** The participant's contact telephone number */
    contact_telephone?: string | undefined;
    /** The hearing venue this participant is assigned to */
    hearing_venue_name?: string | undefined;
    /** The Host is In Another Hearing */
    host_in_another_hearing?: boolean;
    /** The participant represented by the representative */
    representee?: string | undefined;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;

    constructor(data?: IParticipantContactDetailsResponseVho) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.conference_id = _data['conference_id'];
            this.name = _data['name'];
            this.username = _data['username'];
            this.role = _data['role'];
            this.hearing_role = _data['hearing_role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.case_type_group = _data['case_type_group'];
            this.ref_id = _data['ref_id'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.contact_email = _data['contact_email'];
            this.contact_telephone = _data['contact_telephone'];
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.host_in_another_hearing = _data['host_in_another_hearing'];
            this.representee = _data['representee'];
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantContactDetailsResponseVho {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantContactDetailsResponseVho();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['conference_id'] = this.conference_id;
        data['name'] = this.name;
        data['username'] = this.username;
        data['role'] = this.role;
        data['hearing_role'] = this.hearing_role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['case_type_group'] = this.case_type_group;
        data['ref_id'] = this.ref_id;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['contact_email'] = this.contact_email;
        data['contact_telephone'] = this.contact_telephone;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['host_in_another_hearing'] = this.host_in_another_hearing;
        data['representee'] = this.representee;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

export interface IParticipantContactDetailsResponseVho {
    /** The participant id in a conference */
    id?: string;
    /** The conference id */
    conference_id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    role?: Role;
    /** The participant's hearing role */
    hearing_role?: string | undefined;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The group a participant belongs to in a case */
    case_type_group?: string | undefined;
    /** The participant hearing ref id in a booking */
    ref_id?: string;
    /** The participant's first name */
    first_name?: string | undefined;
    /** The participant's last name */
    last_name?: string | undefined;
    /** The participant's contact email */
    contact_email?: string | undefined;
    /** The participant's contact telephone number */
    contact_telephone?: string | undefined;
    /** The hearing venue this participant is assigned to */
    hearing_venue_name?: string | undefined;
    /** The Host is In Another Hearing */
    host_in_another_hearing?: boolean;
    /** The participant represented by the representative */
    representee?: string | undefined;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;
}

export class ParticipantForHostResponse implements IParticipantForHostResponse {
    /** The participant Id */
    id?: string;
    /** The participant display name during a conference */
    display_name?: string | undefined;
    role?: Role;
    /** The representee (if participant is a representative) */
    representee?: string | undefined;
    /** The group a participant belongs to */
    case_type_group?: string | undefined;
    /** The participant hearing role in conference */
    hearing_role?: string | undefined;

    constructor(data?: IParticipantForHostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.display_name = _data['display_name'];
            this.role = _data['role'];
            this.representee = _data['representee'];
            this.case_type_group = _data['case_type_group'];
            this.hearing_role = _data['hearing_role'];
        }
    }

    static fromJS(data: any): ParticipantForHostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantForHostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['display_name'] = this.display_name;
        data['role'] = this.role;
        data['representee'] = this.representee;
        data['case_type_group'] = this.case_type_group;
        data['hearing_role'] = this.hearing_role;
        return data;
    }
}

export interface IParticipantForHostResponse {
    /** The participant Id */
    id?: string;
    /** The participant display name during a conference */
    display_name?: string | undefined;
    role?: Role;
    /** The representee (if participant is a representative) */
    representee?: string | undefined;
    /** The group a participant belongs to */
    case_type_group?: string | undefined;
    /** The participant hearing role in conference */
    hearing_role?: string | undefined;
}

export class ParticipantForUserResponse implements IParticipantForUserResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    role?: Role;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The tiled display name (the fixed tile location, display name and UUID) */
    tiled_display_name?: string | undefined;
    /** The group a participant belongs to in a case */
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    /** The first name of the participant */
    first_name?: string | undefined;
    /** The last name of the participant */
    last_name?: string | undefined;
    /** The hearing role */
    hearing_role?: string | undefined;
    /** The User Name */
    user_name?: string | undefined;
    current_room?: RoomSummaryResponse;
    interpreter_room?: RoomSummaryResponse;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;

    constructor(data?: IParticipantForUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.case_type_group = _data['case_type_group'];
            this.representee = _data['representee'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.hearing_role = _data['hearing_role'];
            this.user_name = _data['user_name'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
            this.interpreter_room = _data['interpreter_room'] ? RoomSummaryResponse.fromJS(_data['interpreter_room']) : <any>undefined;
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantForUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantForUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['case_type_group'] = this.case_type_group;
        data['representee'] = this.representee;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['hearing_role'] = this.hearing_role;
        data['user_name'] = this.user_name;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        data['interpreter_room'] = this.interpreter_room ? this.interpreter_room.toJSON() : <any>undefined;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

export interface IParticipantForUserResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    role?: Role;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The tiled display name (the fixed tile location, display name and UUID) */
    tiled_display_name?: string | undefined;
    /** The group a participant belongs to in a case */
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    /** The first name of the participant */
    first_name?: string | undefined;
    /** The last name of the participant */
    last_name?: string | undefined;
    /** The hearing role */
    hearing_role?: string | undefined;
    /** The User Name */
    user_name?: string | undefined;
    current_room?: RoomSummaryResponse;
    interpreter_room?: RoomSummaryResponse;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;
}

/** Information about a participant in a conference */
export class ParticipantResponse implements IParticipantResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    role?: Role;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The tiled display name (the fixed tile location, display name and UUID) */
    tiled_display_name?: string | undefined;
    /** The group a participant belongs to in a case */
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    /** The first name of the participant */
    first_name?: string | undefined;
    /** The last name of the participant */
    last_name?: string | undefined;
    /** The hearing role */
    hearing_role?: string | undefined;
    /** The User Name */
    user_name?: string | undefined;
    current_room?: RoomSummaryResponse;
    interpreter_room?: RoomSummaryResponse;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;

    constructor(data?: IParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.case_type_group = _data['case_type_group'];
            this.representee = _data['representee'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.hearing_role = _data['hearing_role'];
            this.user_name = _data['user_name'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
            this.interpreter_room = _data['interpreter_room'] ? RoomSummaryResponse.fromJS(_data['interpreter_room']) : <any>undefined;
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['case_type_group'] = this.case_type_group;
        data['representee'] = this.representee;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['hearing_role'] = this.hearing_role;
        data['user_name'] = this.user_name;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        data['interpreter_room'] = this.interpreter_room ? this.interpreter_room.toJSON() : <any>undefined;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

/** Information about a participant in a conference */
export interface IParticipantResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    role?: Role;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The tiled display name (the fixed tile location, display name and UUID) */
    tiled_display_name?: string | undefined;
    /** The group a participant belongs to in a case */
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    /** The first name of the participant */
    first_name?: string | undefined;
    /** The last name of the participant */
    last_name?: string | undefined;
    /** The hearing role */
    hearing_role?: string | undefined;
    /** The User Name */
    user_name?: string | undefined;
    current_room?: RoomSummaryResponse;
    interpreter_room?: RoomSummaryResponse;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;
}

/** Information about a participant in a conference */
export class ParticipantResponseVho implements IParticipantResponseVho {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    role?: Role;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The tiled display name (the fixed tile location, display name and UUID) */
    tiled_display_name?: string | undefined;
    /** The group a participant belongs to in a case */
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    /** The hearing role */
    hearing_role?: string | undefined;
    current_room?: RoomSummaryResponse;
    interpreter_room?: RoomSummaryResponse;
    /** The linked participants */
    linked_participants?: LinkedParticipantResponse[] | undefined;

    constructor(data?: IParticipantResponseVho) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.case_type_group = _data['case_type_group'];
            this.representee = _data['representee'];
            this.hearing_role = _data['hearing_role'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
            this.interpreter_room = _data['interpreter_room'] ? RoomSummaryResponse.fromJS(_data['interpreter_room']) : <any>undefined;
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantResponseVho {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantResponseVho();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['case_type_group'] = this.case_type_group;
        data['representee'] = this.representee;
        data['hearing_role'] = this.hearing_role;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        data['interpreter_room'] = this.interpreter_room ? this.interpreter_room.toJSON() : <any>undefined;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

/** Information about a participant in a conference */
export interface IParticipantResponseVho {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    role?: Role;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The tiled display name (the fixed tile location, display name and UUID) */
    tiled_display_name?: string | undefined;
    /** The group a participant belongs to in a case */
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    /** The hearing role */
    hearing_role?: string | undefined;
    current_room?: RoomSummaryResponse;
    interpreter_room?: RoomSummaryResponse;
    /** The linked participants */
    linked_participants?: LinkedParticipantResponse[] | undefined;
}

export class QuickLinkParticipantJoinResponse implements IQuickLinkParticipantJoinResponse {
    jwt?: string | undefined;

    constructor(data?: IQuickLinkParticipantJoinResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jwt = _data['jwt'];
        }
    }

    static fromJS(data: any): QuickLinkParticipantJoinResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuickLinkParticipantJoinResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['jwt'] = this.jwt;
        return data;
    }
}

export interface IQuickLinkParticipantJoinResponse {
    jwt?: string | undefined;
}

export class RoomSummaryResponse implements IRoomSummaryResponse {
    /** Room Id */
    id?: string | undefined;
    /** Room label */
    label?: string | undefined;
    /** Is the room locked */
    locked?: boolean;

    constructor(data?: IRoomSummaryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.label = _data['label'];
            this.locked = _data['locked'];
        }
    }

    static fromJS(data: any): RoomSummaryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoomSummaryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['label'] = this.label;
        data['locked'] = this.locked;
        return data;
    }
}

export interface IRoomSummaryResponse {
    /** Room Id */
    id?: string | undefined;
    /** Room label */
    label?: string | undefined;
    /** Is the room locked */
    locked?: boolean;
}

export class SelfTestPexipResponse implements ISelfTestPexipResponse {
    pexip_self_test_node?: string | undefined;

    constructor(data?: ISelfTestPexipResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pexip_self_test_node = _data['pexip_self_test_node'];
        }
    }

    static fromJS(data: any): SelfTestPexipResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SelfTestPexipResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['pexip_self_test_node'] = this.pexip_self_test_node;
        return data;
    }
}

export interface ISelfTestPexipResponse {
    pexip_self_test_node?: string | undefined;
}

export class SharedParticipantRoom implements ISharedParticipantRoom {
    pexip_node?: string | undefined;
    participant_join_uri?: string | undefined;
    display_name?: string | undefined;
    tile_display_name?: string | undefined;

    constructor(data?: ISharedParticipantRoom) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pexip_node = _data['pexip_node'];
            this.participant_join_uri = _data['participant_join_uri'];
            this.display_name = _data['display_name'];
            this.tile_display_name = _data['tile_display_name'];
        }
    }

    static fromJS(data: any): SharedParticipantRoom {
        data = typeof data === 'object' ? data : {};
        let result = new SharedParticipantRoom();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['pexip_node'] = this.pexip_node;
        data['participant_join_uri'] = this.participant_join_uri;
        data['display_name'] = this.display_name;
        data['tile_display_name'] = this.tile_display_name;
        return data;
    }
}

export interface ISharedParticipantRoom {
    pexip_node?: string | undefined;
    participant_join_uri?: string | undefined;
    display_name?: string | undefined;
    tile_display_name?: string | undefined;
}

export class TokenResponse implements ITokenResponse {
    expires_on?: string | undefined;
    token?: string | undefined;

    constructor(data?: ITokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expires_on = _data['expires_on'];
            this.token = _data['token'];
        }
    }

    static fromJS(data: any): TokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['expires_on'] = this.expires_on;
        data['token'] = this.token;
        return data;
    }
}

export interface ITokenResponse {
    expires_on?: string | undefined;
    token?: string | undefined;
}

export class UnreadAdminMessageResponse implements IUnreadAdminMessageResponse {
    participant_username?: string | undefined;
    number_of_unread_messages?: number;
    participant_id?: string;

    constructor(data?: IUnreadAdminMessageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participant_username = _data['participant_username'];
            this.number_of_unread_messages = _data['number_of_unread_messages'];
            this.participant_id = _data['participant_id'];
        }
    }

    static fromJS(data: any): UnreadAdminMessageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnreadAdminMessageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['participant_username'] = this.participant_username;
        data['number_of_unread_messages'] = this.number_of_unread_messages;
        data['participant_id'] = this.participant_id;
        return data;
    }
}

export interface IUnreadAdminMessageResponse {
    participant_username?: string | undefined;
    number_of_unread_messages?: number;
    participant_id?: string;
}

export class UnreadInstantMessageConferenceCountResponse implements IUnreadInstantMessageConferenceCountResponse {
    number_of_unread_messages_conference?: UnreadAdminMessageResponse[] | undefined;

    constructor(data?: IUnreadInstantMessageConferenceCountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['number_of_unread_messages_conference'])) {
                this.number_of_unread_messages_conference = [] as any;
                for (let item of _data['number_of_unread_messages_conference'])
                    this.number_of_unread_messages_conference!.push(UnreadAdminMessageResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UnreadInstantMessageConferenceCountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnreadInstantMessageConferenceCountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.number_of_unread_messages_conference)) {
            data['number_of_unread_messages_conference'] = [];
            for (let item of this.number_of_unread_messages_conference) data['number_of_unread_messages_conference'].push(item.toJSON());
        }
        return data;
    }
}

export interface IUnreadInstantMessageConferenceCountResponse {
    number_of_unread_messages_conference?: UnreadAdminMessageResponse[] | undefined;
}

export class UserProfileResponse implements IUserProfileResponse {
    role?: Role;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    username?: string | undefined;
    name?: string | undefined;

    constructor(data?: IUserProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data['role'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.display_name = _data['display_name'];
            this.username = _data['username'];
            this.name = _data['name'];
        }
    }

    static fromJS(data: any): UserProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['role'] = this.role;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['display_name'] = this.display_name;
        data['username'] = this.username;
        data['name'] = this.name;
        return data;
    }
}

export interface IUserProfileResponse {
    role?: Role;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    username?: string | undefined;
    name?: string | undefined;
}

export class VideoEndpointResponse implements IVideoEndpointResponse {
    /** The endpoint id */
    id?: string;
    /** The endpoint display name */
    display_name?: string | undefined;
    status?: EndpointStatus;
    /** The current endpoint status */
    defence_advocate_username?: string | undefined;
    /** The display name when connected to the pexip node */
    pexip_display_name?: string | undefined;
    is_current_user?: boolean;
    current_room?: RoomSummaryResponse;

    constructor(data?: IVideoEndpointResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.display_name = _data['display_name'];
            this.status = _data['status'];
            this.defence_advocate_username = _data['defence_advocate_username'];
            this.pexip_display_name = _data['pexip_display_name'];
            this.is_current_user = _data['is_current_user'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
        }
    }

    static fromJS(data: any): VideoEndpointResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VideoEndpointResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['display_name'] = this.display_name;
        data['status'] = this.status;
        data['defence_advocate_username'] = this.defence_advocate_username;
        data['pexip_display_name'] = this.pexip_display_name;
        data['is_current_user'] = this.is_current_user;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVideoEndpointResponse {
    /** The endpoint id */
    id?: string;
    /** The endpoint display name */
    display_name?: string | undefined;
    status?: EndpointStatus;
    /** The current endpoint status */
    defence_advocate_username?: string | undefined;
    /** The display name when connected to the pexip node */
    pexip_display_name?: string | undefined;
    is_current_user?: boolean;
    current_room?: RoomSummaryResponse;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): Observable<any> {
    if (result !== null && result !== undefined) return _observableThrow(result);
    else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next('');
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
