/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.1.0 (NJsonSchema v10.4.3.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'https://localhost:5800';
    }

    /**
     * @return Success
     */
    getAudioStreamInfo(hearingId: string): Observable<boolean> {
        let url_ = this.baseUrl + '/conferences/audiostreams/{hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAudioStreamInfo(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAudioStreamInfo(<any>response_);
                        } catch (e) {
                            return <Observable<boolean>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<boolean>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetAudioStreamInfo(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    stopAudioRecording(hearingId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/audiostreams/{hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStopAudioRecording(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStopAudioRecording(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processStopAudioRecording(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Start or resume a video hearing
     * @param conferenceId conference id
     * @param body (optional) start hearing request details
     * @return Success
     */
    startOrResumeVideoHearing(conferenceId: string, body: StartHearingRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/start';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStartOrResumeVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStartOrResumeVideoHearing(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processStartOrResumeVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Pause a video hearing
     * @param conferenceId conference id
     * @return Success
     */
    pauseVideoHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/pause';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processPauseVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processPauseVideoHearing(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processPauseVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * End a video hearing
     * @param conferenceId conference id
     * @return Success
     */
    endVideoHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/end';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processEndVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processEndVideoHearing(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processEndVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Call a witness into a video hearing
     * @param conferenceId conference id
     * @param participantId witness id
     * @return Success
     */
    callWitness(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/call';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCallWitness(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCallWitness(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processCallWitness(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Call a witness into a video hearing
     * @param conferenceId conference id
     * @param participantId witness id
     * @return Success
     */
    dismissWitness(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/dismiss';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDismissWitness(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDismissWitness(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processDismissWitness(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get conferences today for a judge or a clerk
     * @return Success
     */
    getConferencesForJudge(): Observable<ConferenceForJudgeResponse[]> {
        let url_ = this.baseUrl + '/conferences/judges';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForJudge(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForJudge(<any>response_);
                        } catch (e) {
                            return <Observable<ConferenceForJudgeResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ConferenceForJudgeResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferencesForJudge(response: HttpResponseBase): Observable<ConferenceForJudgeResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForJudgeResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForJudgeResponse[]>(<any>null);
    }

    /**
     * Get conferences today for individual or representative excluding those that have been closed for over 120 minutes
     * @return Success
     */
    getConferencesForIndividual(): Observable<ConferenceForIndividualResponse[]> {
        let url_ = this.baseUrl + '/conferences/individuals';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForIndividual(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForIndividual(<any>response_);
                        } catch (e) {
                            return <Observable<ConferenceForIndividualResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ConferenceForIndividualResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferencesForIndividual(response: HttpResponseBase): Observable<ConferenceForIndividualResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForIndividualResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForIndividualResponse[]>(<any>null);
    }

    /**
     * Get conferences for user
     * @param hearingVenueNames (optional)
     * @return Success
     */
    getConferencesForVhOfficer(hearingVenueNames: string[] | undefined): Observable<ConferenceForVhOfficerResponse[]> {
        let url_ = this.baseUrl + '/conferences/vhofficer?';
        if (hearingVenueNames === null) throw new Error("The parameter 'hearingVenueNames' cannot be null.");
        else if (hearingVenueNames !== undefined)
            hearingVenueNames &&
                hearingVenueNames.forEach(item => {
                    url_ += 'HearingVenueNames=' + encodeURIComponent('' + item) + '&';
                });
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForVhOfficer(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForVhOfficer(<any>response_);
                        } catch (e) {
                            return <Observable<ConferenceForVhOfficerResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ConferenceForVhOfficerResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferencesForVhOfficer(response: HttpResponseBase): Observable<ConferenceForVhOfficerResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForVhOfficerResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result401: any = null;
                    let resultData401 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result401 = ProblemDetails.fromJS(resultData401);
                    return throwException('Unauthorized', status, _responseText, _headers, result401);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForVhOfficerResponse[]>(<any>null);
    }

    /**
     * Get the details of a conference by id for VH officer
     * @param conferenceId The unique id of the conference
     * @return Success
     */
    getConferenceByIdVHO(conferenceId: string): Observable<ConferenceResponseVho> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/vhofficer';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceByIdVHO(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceByIdVHO(<any>response_);
                        } catch (e) {
                            return <Observable<ConferenceResponseVho>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ConferenceResponseVho>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferenceByIdVHO(response: HttpResponseBase): Observable<ConferenceResponseVho> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceResponseVho.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceResponseVho>(<any>null);
    }

    /**
     * Get the details of a conference by id
     * @param conferenceId The unique id of the conference
     * @return Success
     */
    getConferenceById(conferenceId: string): Observable<ConferenceResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceById(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceById(<any>response_);
                        } catch (e) {
                            return <Observable<ConferenceResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ConferenceResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferenceById(response: HttpResponseBase): Observable<ConferenceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceResponse>(<any>null);
    }

    /**
     * GetClientConfigurationSettings the configuration settings for client
     * @return Success
     */
    getClientConfigurationSettings(): Observable<ClientSettingsResponse> {
        let url_ = this.baseUrl + '/config';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetClientConfigurationSettings(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetClientConfigurationSettings(<any>response_);
                        } catch (e) {
                            return <Observable<ClientSettingsResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ClientSettingsResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetClientConfigurationSettings(response: HttpResponseBase): Observable<ClientSettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ClientSettingsResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ClientSettingsResponse>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    leaveConsultation(body: LeavePrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/leave';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLeaveConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLeaveConsultation(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processLeaveConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    respondToConsultationRequest(body: PrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/respond';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processRespondToConsultationRequest(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processRespondToConsultationRequest(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processRespondToConsultationRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    joinPrivateConsultation(body: JoinPrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/joinPrivateConsultation';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processJoinPrivateConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processJoinPrivateConsultation(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processJoinPrivateConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    startOrJoinConsultation(body: StartPrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/start';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStartOrJoinConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStartOrJoinConsultation(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processStartOrJoinConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    lockConsultationRoomRequest(body: LockConsultationRoomRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/lock';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLockConsultationRoomRequest(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLockConsultationRoomRequest(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processLockConsultationRoomRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    inviteToConsultation(body: InviteToConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/invite';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processInviteToConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processInviteToConsultation(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processInviteToConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    addEndpointToConsultation(body: AddEndpointConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/addendpoint';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddEndpointToConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddEndpointToConsultation(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processAddEndpointToConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getVideoEndpointsForConference(conferenceId: string): Observable<VideoEndpointResponse[]> {
        let url_ = this.baseUrl + '/{conferenceId}/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetVideoEndpointsForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetVideoEndpointsForConference(<any>response_);
                        } catch (e) {
                            return <Observable<VideoEndpointResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<VideoEndpointResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetVideoEndpointsForConference(response: HttpResponseBase): Observable<VideoEndpointResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(VideoEndpointResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<VideoEndpointResponse[]>(<any>null);
    }

    /**
     * @return Success
     */
    allowedVideoCallEndpoints(conferenceId: string): Observable<AllowedEndpointResponse[]> {
        let url_ = this.baseUrl + '/{conferenceId}/allowed-video-call-endpoints';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAllowedVideoCallEndpoints(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAllowedVideoCallEndpoints(<any>response_);
                        } catch (e) {
                            return <Observable<AllowedEndpointResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<AllowedEndpointResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processAllowedVideoCallEndpoints(response: HttpResponseBase): Observable<AllowedEndpointResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(AllowedEndpointResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<AllowedEndpointResponse[]>(<any>null);
    }

    /**
     * Check Service Health
     * @return Success
     */
    checkServiceHealth(): Observable<HealthCheckResponse> {
        let url_ = this.baseUrl + '/HealthCheck/health';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCheckServiceHealth(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCheckServiceHealth(<any>response_);
                        } catch (e) {
                            return <Observable<HealthCheckResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<HealthCheckResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processCheckServiceHealth(response: HttpResponseBase): Observable<HealthCheckResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HealthCheckResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = HealthCheckResponse.fromJS(resultData500);
                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HealthCheckResponse>(<any>null);
    }

    /**
     * Check Service Health
     * @return Success
     */
    checkServiceHealth2(): Observable<HealthCheckResponse> {
        let url_ = this.baseUrl + '/health/liveness';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCheckServiceHealth2(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCheckServiceHealth2(<any>response_);
                        } catch (e) {
                            return <Observable<HealthCheckResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<HealthCheckResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processCheckServiceHealth2(response: HttpResponseBase): Observable<HealthCheckResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HealthCheckResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = HealthCheckResponse.fromJS(resultData500);
                    return throwException('Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HealthCheckResponse>(<any>null);
    }

    /**
     * Get all the instant messages for a conference for a participant
     * @param conferenceId Id of the conference
     * @param participantId the participant in the conference
     * @return Success
     */
    getConferenceInstantMessageHistoryForParticipant(conferenceId: string, participantId: string): Observable<ChatResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/participant/{participantId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceInstantMessageHistoryForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceInstantMessageHistoryForParticipant(<any>response_);
                        } catch (e) {
                            return <Observable<ChatResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ChatResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetConferenceInstantMessageHistoryForParticipant(response: HttpResponseBase): Observable<ChatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ChatResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ChatResponse[]>(<any>null);
    }

    /**
     * Get number of unread messages for vho
     * @param conferenceId Id of the conference
     * @return Success
     */
    getNumberOfUnreadAdminMessagesForConference(conferenceId: string): Observable<UnreadInstantMessageConferenceCountResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/unread/vho';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetNumberOfUnreadAdminMessagesForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetNumberOfUnreadAdminMessagesForConference(<any>response_);
                        } catch (e) {
                            return <Observable<UnreadInstantMessageConferenceCountResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<UnreadInstantMessageConferenceCountResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetNumberOfUnreadAdminMessagesForConference(
        response: HttpResponseBase
    ): Observable<UnreadInstantMessageConferenceCountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UnreadInstantMessageConferenceCountResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UnreadInstantMessageConferenceCountResponse>(<any>null);
    }

    /**
     * Get number of unread messages for a participant
     * @param conferenceId Id of the conference
     * @param participantId the participant in the conference
     * @return Success
     */
    getNumberOfUnreadAdminMessagesForConferenceByParticipant(
        conferenceId: string,
        participantId: string
    ): Observable<UnreadAdminMessageResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/unread/participant/{participantId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(<any>response_);
                        } catch (e) {
                            return <Observable<UnreadAdminMessageResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<UnreadAdminMessageResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(
        response: HttpResponseBase
    ): Observable<UnreadAdminMessageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UnreadAdminMessageResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UnreadAdminMessageResponse>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    addMediaEventToConference(conferenceId: string, body: AddMediaEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/mediaevents';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddMediaEventToConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddMediaEventToConference(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processAddMediaEventToConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    addSelfTestFailureEventToConference(conferenceId: string, body: AddSelfTestFailureEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/selftestfailureevents';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddSelfTestFailureEventToConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddSelfTestFailureEventToConference(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processAddSelfTestFailureEventToConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getTestCallResult(conferenceId: string, participantId: string): Observable<TestCallScoreResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants/{participantId}/selftestresult';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTestCallResult(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTestCallResult(<any>response_);
                        } catch (e) {
                            return <Observable<TestCallScoreResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TestCallScoreResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetTestCallResult(response: HttpResponseBase): Observable<TestCallScoreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TestCallScoreResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TestCallScoreResponse>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updateParticipantStatus(conferenceId: string, body: UpdateParticipantStatusEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participantstatus';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateParticipantStatus(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateParticipantStatus(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processUpdateParticipantStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param participantId (optional)
     * @return Success
     */
    getIndependentTestCallResult(participantId: string | undefined): Observable<TestCallScoreResponse> {
        let url_ = this.baseUrl + '/conferences/independentselftestresult?';
        if (participantId === null) throw new Error("The parameter 'participantId' cannot be null.");
        else if (participantId !== undefined) url_ += 'participantId=' + encodeURIComponent('' + participantId) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetIndependentTestCallResult(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetIndependentTestCallResult(<any>response_);
                        } catch (e) {
                            return <Observable<TestCallScoreResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TestCallScoreResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetIndependentTestCallResult(response: HttpResponseBase): Observable<TestCallScoreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TestCallScoreResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TestCallScoreResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getHeartbeatDataForParticipant(conferenceId: string, participantId: string): Observable<ParticipantHeartbeatResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/heartbeatrecent';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHeartbeatDataForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHeartbeatDataForParticipant(<any>response_);
                        } catch (e) {
                            return <Observable<ParticipantHeartbeatResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ParticipantHeartbeatResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetHeartbeatDataForParticipant(response: HttpResponseBase): Observable<ParticipantHeartbeatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantHeartbeatResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantHeartbeatResponse[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updateParticipantDisplayName(
        conferenceId: string,
        participantId: string,
        body: UpdateParticipantDisplayNameRequest | undefined
    ): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants/{participantId}/participantDisplayName';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateParticipantDisplayName(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateParticipantDisplayName(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processUpdateParticipantDisplayName(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get the participant details of a conference by id for VH officer
     * @param conferenceId The unique id of the conference
     * @return Success
     */
    getParticipantsWithContactDetailsByConferenceId(conferenceId: string): Observable<ParticipantContactDetailsResponseVho[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/vhofficer/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetParticipantsWithContactDetailsByConferenceId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetParticipantsWithContactDetailsByConferenceId(<any>response_);
                        } catch (e) {
                            return <Observable<ParticipantContactDetailsResponseVho[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ParticipantContactDetailsResponseVho[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetParticipantsWithContactDetailsByConferenceId(
        response: HttpResponseBase
    ): Observable<ParticipantContactDetailsResponseVho[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantContactDetailsResponseVho.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantContactDetailsResponseVho[]>(<any>null);
    }

    /**
     * @return Success
     */
    getParticipantsByConferenceId(conferenceId: string): Observable<ParticipantForUserResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetParticipantsByConferenceId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetParticipantsByConferenceId(<any>response_);
                        } catch (e) {
                            return <Observable<ParticipantForUserResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<ParticipantForUserResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetParticipantsByConferenceId(response: HttpResponseBase): Observable<ParticipantForUserResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantForUserResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantForUserResponse[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrentParticipant(conferenceId: string): Observable<LoggedParticipantResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/currentparticipant';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCurrentParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCurrentParticipant(<any>response_);
                        } catch (e) {
                            return <Observable<LoggedParticipantResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<LoggedParticipantResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetCurrentParticipant(response: HttpResponseBase): Observable<LoggedParticipantResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = LoggedParticipantResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<LoggedParticipantResponse>(<any>null);
    }

    /**
     * Get profile for logged in user
     * @return Success
     */
    getUserProfile(): Observable<UserProfileResponse> {
        let url_ = this.baseUrl + '/profile';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUserProfile(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUserProfile(<any>response_);
                        } catch (e) {
                            return <Observable<UserProfileResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<UserProfileResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<UserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UserProfileResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UserProfileResponse>(<any>null);
    }

    /**
     * Get profile for username
     * @param username (optional)
     * @return Success
     */
    getProfileByUsername(username: string | undefined): Observable<UserProfileResponse> {
        let url_ = this.baseUrl + '/profile/query?';
        if (username === null) throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined) url_ += 'username=' + encodeURIComponent('' + username) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetProfileByUsername(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetProfileByUsername(<any>response_);
                        } catch (e) {
                            return <Observable<UserProfileResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<UserProfileResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetProfileByUsername(response: HttpResponseBase): Observable<UserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UserProfileResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UserProfileResponse>(<any>null);
    }

    /**
     * Get the Pexip self test node.
     * @return Success
     */
    getPexipConfig(): Observable<SelfTestPexipResponse> {
        let url_ = this.baseUrl + '/selftest';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetPexipConfig(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetPexipConfig(<any>response_);
                        } catch (e) {
                            return <Observable<SelfTestPexipResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<SelfTestPexipResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetPexipConfig(response: HttpResponseBase): Observable<SelfTestPexipResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = SelfTestPexipResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<SelfTestPexipResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getTasks(conferenceId: string): Observable<TaskResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/tasks';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTasks(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTasks(<any>response_);
                        } catch (e) {
                            return <Observable<TaskResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TaskResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetTasks(response: HttpResponseBase): Observable<TaskResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(TaskResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TaskResponse[]>(<any>null);
    }

    /**
     * Update existing tasks
     * @param conferenceId The id of the conference to update
     * @param taskId The id of the task to update
     * @return Success
     */
    completeTask(conferenceId: string, taskId: number): Observable<TaskResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/tasks/{taskId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (taskId === undefined || taskId === null) throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace('{taskId}', encodeURIComponent('' + taskId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('patch', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCompleteTask(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCompleteTask(<any>response_);
                        } catch (e) {
                            return <Observable<TaskResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TaskResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processCompleteTask(response: HttpResponseBase): Observable<TaskResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TaskResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TaskResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getSelfTestToken(participantId: string): Observable<TokenResponse> {
        let url_ = this.baseUrl + '/participants/{participantId}/selftesttoken';
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetSelfTestToken(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetSelfTestToken(<any>response_);
                        } catch (e) {
                            return <Observable<TokenResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TokenResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetSelfTestToken(response: HttpResponseBase): Observable<TokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TokenResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TokenResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getJwtoken(participantId: string): Observable<TokenResponse> {
        let url_ = this.baseUrl + '/participants/{participantId}/jwtoken';
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetJwtoken(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetJwtoken(<any>response_);
                        } catch (e) {
                            return <Observable<TokenResponse>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<TokenResponse>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetJwtoken(response: HttpResponseBase): Observable<TokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TokenResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TokenResponse>(<any>null);
    }

    /**
     * Get Court rooms accounts (judges)
     * @param hearingVenueNames (optional)
     * @return Success
     */
    getCourtRoomAccounts(hearingVenueNames: string[] | undefined): Observable<CourtRoomsAccountResponse[]> {
        let url_ = this.baseUrl + '/api/accounts/courtrooms?';
        if (hearingVenueNames === null) throw new Error("The parameter 'hearingVenueNames' cannot be null.");
        else if (hearingVenueNames !== undefined)
            hearingVenueNames &&
                hearingVenueNames.forEach(item => {
                    url_ += 'HearingVenueNames=' + encodeURIComponent('' + item) + '&';
                });
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCourtRoomAccounts(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCourtRoomAccounts(<any>response_);
                        } catch (e) {
                            return <Observable<CourtRoomsAccountResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<CourtRoomsAccountResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetCourtRoomAccounts(response: HttpResponseBase): Observable<CourtRoomsAccountResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(CourtRoomsAccountResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<CourtRoomsAccountResponse[]>(<any>null);
    }

    /**
     * Get available courts
     * @return Success
     */
    getVenues(): Observable<HearingVenueResponse[]> {
        let url_ = this.baseUrl + '/hearing-venues/courts';
        url_ = url_.replace(/[?&]$/, '');
        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };
        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetVenues(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetVenues(<any>response_);
                        } catch (e) {
                            return <Observable<HearingVenueResponse[]>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<HearingVenueResponse[]>>(<any>_observableThrow(response_));
                })
            );
    }
    protected processGetVenues(response: HttpResponseBase): Observable<HearingVenueResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;
        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(HearingVenueResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HearingVenueResponse[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    sendEvent(body: ConferenceEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/callback';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json-patch+json'
            })
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSendEvent(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSendEvent(<any>response_);
                        } catch (e) {
                            return <Observable<void>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<void>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processSendEvent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(<any>null);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param participantType (optional)
     * @return Success
     */
    getParticipantRoomForParticipant(
        conferenceId: string,
        participantId: string,
        participantType: string | undefined
    ): Observable<SharedParticipantRoom> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/rooms/shared/{participantId}?';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        if (participantType === null) throw new Error("The parameter 'participantType' cannot be null.");
        else if (participantType !== undefined) url_ += 'participantType=' + encodeURIComponent('' + participantType) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetParticipantRoomForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetParticipantRoomForParticipant(<any>response_);
                        } catch (e) {
                            return <Observable<SharedParticipantRoom>>(<any>_observableThrow(e));
                        }
                    } else return <Observable<SharedParticipantRoom>>(<any>_observableThrow(response_));
                })
            );
    }

    protected processGetParticipantRoomForParticipant(response: HttpResponseBase): Observable<SharedParticipantRoom> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body : (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = SharedParticipantRoom.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = resultData404 !== undefined ? resultData404 : <any>null;
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<SharedParticipantRoom>(<any>null);
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    readonly extensions?: { [key: string]: any } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data['type'];
            this.title = _data['title'];
            this.status = _data['status'];
            this.detail = _data['detail'];
            this.instance = _data['instance'];
            if (_data['extensions']) {
                (<any>this).extensions = {} as any;
                for (let key in _data['extensions']) {
                    if (_data['extensions'].hasOwnProperty(key)) (<any>(<any>this).extensions)![key] = _data['extensions'][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['type'] = this.type;
        data['title'] = this.title;
        data['status'] = this.status;
        data['detail'] = this.detail;
        data['instance'] = this.instance;
        if (this.extensions) {
            data['extensions'] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key)) (<any>data['extensions'])[key] = this.extensions[key];
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any } | undefined;
}

export enum HearingLayout {
    Dynamic = 'Dynamic',
    OnePlus7 = 'OnePlus7',
    TwoPlus21 = 'TwoPlus21'
}

export class StartHearingRequest implements IStartHearingRequest {
    layout?: HearingLayout | undefined;

    constructor(data?: IStartHearingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layout = _data['layout'];
        }
    }

    static fromJS(data: any): StartHearingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartHearingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['layout'] = this.layout;
        return data;
    }
}

export interface IStartHearingRequest {
    layout?: HearingLayout | undefined;
}

export enum ConferenceStatus {
    NotStarted = 'NotStarted',
    InSession = 'InSession',
    Paused = 'Paused',
    Suspended = 'Suspended',
    Closed = 'Closed'
}

export enum Role {
    None = 'None',
    CaseAdmin = 'CaseAdmin',
    VideoHearingsOfficer = 'VideoHearingsOfficer',
    HearingFacilitationSupport = 'HearingFacilitationSupport',
    Judge = 'Judge',
    Individual = 'Individual',
    Representative = 'Representative',
    JudicialOfficeHolder = 'JudicialOfficeHolder'
}

export class ParticipantForJudgeResponse implements IParticipantForJudgeResponse {
    /** The participant Id */
    id?: string;
    display_name?: string | undefined;
    /** The participant user role in conference */
    role?: Role;
    /** The representee (if participant is a representative) */
    representee?: string | undefined;
    case_type_group?: string | undefined;
    hearing_role?: string | undefined;

    constructor(data?: IParticipantForJudgeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.display_name = _data['display_name'];
            this.role = _data['role'];
            this.representee = _data['representee'];
            this.case_type_group = _data['case_type_group'];
            this.hearing_role = _data['hearing_role'];
        }
    }

    static fromJS(data: any): ParticipantForJudgeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantForJudgeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['display_name'] = this.display_name;
        data['role'] = this.role;
        data['representee'] = this.representee;
        data['case_type_group'] = this.case_type_group;
        data['hearing_role'] = this.hearing_role;
        return data;
    }
}

export interface IParticipantForJudgeResponse {
    /** The participant Id */
    id?: string;
    display_name?: string | undefined;
    /** The participant user role in conference */
    role?: Role;
    /** The representee (if participant is a representative) */
    representee?: string | undefined;
    case_type_group?: string | undefined;
    hearing_role?: string | undefined;
}

export class ConferenceForJudgeResponse implements IConferenceForJudgeResponse {
    /** Conference UUID */
    id?: string;
    scheduled_date_time?: Date;
    closed_date_time?: Date | undefined;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference status */
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForJudgeResponse[] | undefined;
    number_of_endpoints?: number;

    constructor(data?: IConferenceForJudgeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantForJudgeResponse.fromJS(item));
            }
            this.number_of_endpoints = _data['number_of_endpoints'];
        }
    }

    static fromJS(data: any): ConferenceForJudgeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForJudgeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['number_of_endpoints'] = this.number_of_endpoints;
        return data;
    }
}

export interface IConferenceForJudgeResponse {
    /** Conference UUID */
    id?: string;
    scheduled_date_time?: Date;
    closed_date_time?: Date | undefined;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference status */
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForJudgeResponse[] | undefined;
    number_of_endpoints?: number;
}

export class ConferenceForIndividualResponse implements IConferenceForIndividualResponse {
    /** Conference UUID */
    id?: string;
    scheduled_date_time?: Date;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference status */
    status?: ConferenceStatus;
    closed_date_time?: Date | undefined;

    constructor(data?: IConferenceForIndividualResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConferenceForIndividualResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForIndividualResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        return data;
    }
}

export interface IConferenceForIndividualResponse {
    /** Conference UUID */
    id?: string;
    scheduled_date_time?: Date;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference status */
    status?: ConferenceStatus;
    closed_date_time?: Date | undefined;
}

export enum ParticipantStatus {
    None = 'None',
    NotSignedIn = 'NotSignedIn',
    UnableToJoin = 'UnableToJoin',
    Joining = 'Joining',
    Available = 'Available',
    InHearing = 'InHearing',
    InConsultation = 'InConsultation',
    Disconnected = 'Disconnected'
}

export class RoomSummaryResponse implements IRoomSummaryResponse {
    /** Room Id */
    id?: string | undefined;
    /** Room label */
    label?: string | undefined;
    /** Is the room locked */
    locked?: boolean;

    constructor(data?: IRoomSummaryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.label = _data['label'];
            this.locked = _data['locked'];
        }
    }

    static fromJS(data: any): RoomSummaryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoomSummaryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['label'] = this.label;
        data['locked'] = this.locked;
        return data;
    }
}

export interface IRoomSummaryResponse {
    /** Room Id */
    id?: string | undefined;
    /** Room label */
    label?: string | undefined;
    /** Is the room locked */
    locked?: boolean;
}

export enum LinkType {
    Interpreter = 'Interpreter'
}

export class LinkedParticipantResponse implements ILinkedParticipantResponse {
    linked_id?: string;
    link_type?: LinkType;

    constructor(data?: ILinkedParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linked_id = _data['linked_id'];
            this.link_type = _data['link_type'];
        }
    }

    static fromJS(data: any): LinkedParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['linked_id'] = this.linked_id;
        data['link_type'] = this.link_type;
        return data;
    }
}

export interface ILinkedParticipantResponse {
    linked_id?: string;
    link_type?: LinkType;
}

export class ParticipantForUserResponse implements IParticipantForUserResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    hearing_role?: string | undefined;
    current_room?: RoomSummaryResponse | undefined;
    interpreter_room?: RoomSummaryResponse | undefined;
    linked_participants?: LinkedParticipantResponse[] | undefined;

    constructor(data?: IParticipantForUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.case_type_group = _data['case_type_group'];
            this.representee = _data['representee'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.hearing_role = _data['hearing_role'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
            this.interpreter_room = _data['interpreter_room'] ? RoomSummaryResponse.fromJS(_data['interpreter_room']) : <any>undefined;
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantForUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantForUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['case_type_group'] = this.case_type_group;
        data['representee'] = this.representee;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['hearing_role'] = this.hearing_role;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        data['interpreter_room'] = this.interpreter_room ? this.interpreter_room.toJSON() : <any>undefined;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

export interface IParticipantForUserResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    hearing_role?: string | undefined;
    current_room?: RoomSummaryResponse | undefined;
    interpreter_room?: RoomSummaryResponse | undefined;
    linked_participants?: LinkedParticipantResponse[] | undefined;
}

export class ConferenceForVhOfficerResponse implements IConferenceForVhOfficerResponse {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    scheduled_duration?: number;
    /** The current conference status */
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForUserResponse[] | undefined;
    hearing_venue_name?: string | undefined;
    started_date_time?: Date | undefined;
    closed_date_time?: Date | undefined;
    telephone_conference_id?: string | undefined;
    telephone_conference_number?: string | undefined;
    created_date_time?: Date | undefined;

    constructor(data?: IConferenceForVhOfficerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.scheduled_duration = _data['scheduled_duration'];
            this.status = _data['status'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantForUserResponse.fromJS(item));
            }
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.started_date_time = _data['started_date_time'] ? new Date(_data['started_date_time'].toString()) : <any>undefined;
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.telephone_conference_id = _data['telephone_conference_id'];
            this.telephone_conference_number = _data['telephone_conference_number'];
            this.created_date_time = _data['created_date_time'] ? new Date(_data['created_date_time'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ConferenceForVhOfficerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForVhOfficerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['scheduled_duration'] = this.scheduled_duration;
        data['status'] = this.status;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['started_date_time'] = this.started_date_time ? this.started_date_time.toISOString() : <any>undefined;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['telephone_conference_id'] = this.telephone_conference_id;
        data['telephone_conference_number'] = this.telephone_conference_number;
        data['created_date_time'] = this.created_date_time ? this.created_date_time.toISOString() : <any>undefined;
        return data;
    }
}

export interface IConferenceForVhOfficerResponse {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    scheduled_duration?: number;
    /** The current conference status */
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForUserResponse[] | undefined;
    hearing_venue_name?: string | undefined;
    started_date_time?: Date | undefined;
    closed_date_time?: Date | undefined;
    telephone_conference_id?: string | undefined;
    telephone_conference_number?: string | undefined;
    created_date_time?: Date | undefined;
}

export enum LinkedParticipantType {
    Interpreter = 'Interpreter'
}

export class LinkedParticipantResponse2 implements ILinkedParticipantResponse2 {
    linked_id?: string;
    type?: LinkedParticipantType;

    constructor(data?: ILinkedParticipantResponse2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linked_id = _data['linked_id'];
            this.type = _data['type'];
        }
    }

    static fromJS(data: any): LinkedParticipantResponse2 {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedParticipantResponse2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['linked_id'] = this.linked_id;
        data['type'] = this.type;
        return data;
    }
}

export interface ILinkedParticipantResponse2 {
    linked_id?: string;
    type?: LinkedParticipantType;
}

/** Information about a participant in a conference */
export class ParticipantResponseVho implements IParticipantResponseVho {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    hearing_role?: string | undefined;
    current_room?: RoomSummaryResponse | undefined;
    interpreter_room?: RoomSummaryResponse | undefined;
    linked_participants?: LinkedParticipantResponse2[] | undefined;

    constructor(data?: IParticipantResponseVho) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.case_type_group = _data['case_type_group'];
            this.representee = _data['representee'];
            this.hearing_role = _data['hearing_role'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
            this.interpreter_room = _data['interpreter_room'] ? RoomSummaryResponse.fromJS(_data['interpreter_room']) : <any>undefined;
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantResponseVho {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantResponseVho();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['case_type_group'] = this.case_type_group;
        data['representee'] = this.representee;
        data['hearing_role'] = this.hearing_role;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        data['interpreter_room'] = this.interpreter_room ? this.interpreter_room.toJSON() : <any>undefined;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

/** Information about a participant in a conference */
export interface IParticipantResponseVho {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    hearing_role?: string | undefined;
    current_room?: RoomSummaryResponse | undefined;
    interpreter_room?: RoomSummaryResponse | undefined;
    linked_participants?: LinkedParticipantResponse2[] | undefined;
}

/** Detailed information about a conference for VHO officer */
export class ConferenceResponseVho implements IConferenceResponseVho {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference Status */
    status?: ConferenceStatus;
    admin_i_frame_uri?: string | undefined;
    participant_uri?: string | undefined;
    pexip_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponseVho[] | undefined;
    closed_date_time?: Date | undefined;
    hearing_venue_name?: string | undefined;

    constructor(data?: IConferenceResponseVho) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.admin_i_frame_uri = _data['admin_i_frame_uri'];
            this.participant_uri = _data['participant_uri'];
            this.pexip_node_uri = _data['pexip_node_uri'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantResponseVho.fromJS(item));
            }
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.hearing_venue_name = _data['hearing_venue_name'];
        }
    }

    static fromJS(data: any): ConferenceResponseVho {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceResponseVho();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['admin_i_frame_uri'] = this.admin_i_frame_uri;
        data['participant_uri'] = this.participant_uri;
        data['pexip_node_uri'] = this.pexip_node_uri;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['hearing_venue_name'] = this.hearing_venue_name;
        return data;
    }
}

/** Detailed information about a conference for VHO officer */
export interface IConferenceResponseVho {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference Status */
    status?: ConferenceStatus;
    admin_i_frame_uri?: string | undefined;
    participant_uri?: string | undefined;
    pexip_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponseVho[] | undefined;
    closed_date_time?: Date | undefined;
    hearing_venue_name?: string | undefined;
}

/** Information about a participant in a conference */
export class ParticipantResponse implements IParticipantResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    hearing_role?: string | undefined;
    current_room?: RoomSummaryResponse | undefined;
    interpreter_room?: RoomSummaryResponse | undefined;
    linked_participants?: LinkedParticipantResponse[] | undefined;

    constructor(data?: IParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.case_type_group = _data['case_type_group'];
            this.representee = _data['representee'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.hearing_role = _data['hearing_role'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
            this.interpreter_room = _data['interpreter_room'] ? RoomSummaryResponse.fromJS(_data['interpreter_room']) : <any>undefined;
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['case_type_group'] = this.case_type_group;
        data['representee'] = this.representee;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['hearing_role'] = this.hearing_role;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        data['interpreter_room'] = this.interpreter_room ? this.interpreter_room.toJSON() : <any>undefined;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

/** Information about a participant in a conference */
export interface IParticipantResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's role */
    role?: Role;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    tiled_display_name?: string | undefined;
    case_type_group?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    hearing_role?: string | undefined;
    current_room?: RoomSummaryResponse | undefined;
    interpreter_room?: RoomSummaryResponse | undefined;
    linked_participants?: LinkedParticipantResponse[] | undefined;
}

export enum EndpointStatus {
    NotYetJoined = 'NotYetJoined',
    Connected = 'Connected',
    Disconnected = 'Disconnected',
    InConsultation = 'InConsultation'
}

export class VideoEndpointResponse implements IVideoEndpointResponse {
    /** The endpoint id */
    id?: string;
    display_name?: string | undefined;
    /** The current endpoint status */
    status?: EndpointStatus;
    defence_advocate_username?: string | undefined;
    pexip_display_name?: string | undefined;
    is_current_user?: boolean;
    current_room?: RoomSummaryResponse | undefined;

    constructor(data?: IVideoEndpointResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.display_name = _data['display_name'];
            this.status = _data['status'];
            this.defence_advocate_username = _data['defence_advocate_username'];
            this.pexip_display_name = _data['pexip_display_name'];
            this.is_current_user = _data['is_current_user'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
        }
    }

    static fromJS(data: any): VideoEndpointResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VideoEndpointResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['display_name'] = this.display_name;
        data['status'] = this.status;
        data['defence_advocate_username'] = this.defence_advocate_username;
        data['pexip_display_name'] = this.pexip_display_name;
        data['is_current_user'] = this.is_current_user;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        return data;
    }
}

export interface IVideoEndpointResponse {
    /** The endpoint id */
    id?: string;
    display_name?: string | undefined;
    /** The current endpoint status */
    status?: EndpointStatus;
    defence_advocate_username?: string | undefined;
    pexip_display_name?: string | undefined;
    is_current_user?: boolean;
    current_room?: RoomSummaryResponse | undefined;
}

/** Detailed information about a conference */
export class ConferenceResponse implements IConferenceResponse {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference Status */
    status?: ConferenceStatus;
    participant_uri?: string | undefined;
    pexip_node_uri?: string | undefined;
    pexip_self_test_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponse[] | undefined;
    closed_date_time?: Date | undefined;
    hearing_venue_name?: string | undefined;
    audio_recording_required?: boolean;
    hearing_ref_id?: string;
    /** The video access endpoints in the conference */
    endpoints?: VideoEndpointResponse[] | undefined;

    constructor(data?: IConferenceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.participant_uri = _data['participant_uri'];
            this.pexip_node_uri = _data['pexip_node_uri'];
            this.pexip_self_test_node_uri = _data['pexip_self_test_node_uri'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantResponse.fromJS(item));
            }
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.audio_recording_required = _data['audio_recording_required'];
            this.hearing_ref_id = _data['hearing_ref_id'];
            if (Array.isArray(_data['endpoints'])) {
                this.endpoints = [] as any;
                for (let item of _data['endpoints']) this.endpoints!.push(VideoEndpointResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConferenceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['participant_uri'] = this.participant_uri;
        data['pexip_node_uri'] = this.pexip_node_uri;
        data['pexip_self_test_node_uri'] = this.pexip_self_test_node_uri;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['audio_recording_required'] = this.audio_recording_required;
        data['hearing_ref_id'] = this.hearing_ref_id;
        if (Array.isArray(this.endpoints)) {
            data['endpoints'] = [];
            for (let item of this.endpoints) data['endpoints'].push(item.toJSON());
        }
        return data;
    }
}

/** Detailed information about a conference */
export interface IConferenceResponse {
    /** Conference ID */
    id?: string;
    scheduled_date_time?: Date;
    scheduled_duration?: number;
    case_type?: string | undefined;
    case_number?: string | undefined;
    case_name?: string | undefined;
    /** The current conference Status */
    status?: ConferenceStatus;
    participant_uri?: string | undefined;
    pexip_node_uri?: string | undefined;
    pexip_self_test_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponse[] | undefined;
    closed_date_time?: Date | undefined;
    hearing_venue_name?: string | undefined;
    audio_recording_required?: boolean;
    hearing_ref_id?: string;
    /** The video access endpoints in the conference */
    endpoints?: VideoEndpointResponse[] | undefined;
}

export class IdpSettingsResponse implements IIdpSettingsResponse {
    tenant_id?: string | undefined;
    client_id?: string | undefined;
    redirect_uri?: string | undefined;
    post_logout_redirect_uri?: string | undefined;

    constructor(data?: IIdpSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenant_id = _data['tenant_id'];
            this.client_id = _data['client_id'];
            this.redirect_uri = _data['redirect_uri'];
            this.post_logout_redirect_uri = _data['post_logout_redirect_uri'];
        }
    }

    static fromJS(data: any): IdpSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IdpSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['tenant_id'] = this.tenant_id;
        data['client_id'] = this.client_id;
        data['redirect_uri'] = this.redirect_uri;
        data['post_logout_redirect_uri'] = this.post_logout_redirect_uri;
        return data;
    }
}

export interface IIdpSettingsResponse {
    tenant_id?: string | undefined;
    client_id?: string | undefined;
    redirect_uri?: string | undefined;
    post_logout_redirect_uri?: string | undefined;
}

/** Configuration to initialise the UI application */
export class ClientSettingsResponse implements IClientSettingsResponse {
    app_insights_instrumentation_key?: string | undefined;
    event_hub_path?: string | undefined;
    join_by_phone_from_date?: string | undefined;
    kinly_turn_server?: string | undefined;
    kinly_turn_server_user?: string | undefined;
    kinly_turn_server_credential?: string | undefined;
    e_jud_idp_settings?: IdpSettingsResponse | undefined;
    vh_idp_settings?: IdpSettingsResponse | undefined;

    constructor(data?: IClientSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.app_insights_instrumentation_key = _data['app_insights_instrumentation_key'];
            this.event_hub_path = _data['event_hub_path'];
            this.join_by_phone_from_date = _data['join_by_phone_from_date'];
            this.kinly_turn_server = _data['kinly_turn_server'];
            this.kinly_turn_server_user = _data['kinly_turn_server_user'];
            this.kinly_turn_server_credential = _data['kinly_turn_server_credential'];
            this.e_jud_idp_settings = _data['e_jud_idp_settings']
                ? IdpSettingsResponse.fromJS(_data['e_jud_idp_settings'])
                : <any>undefined;
            this.vh_idp_settings = _data['vh_idp_settings'] ? IdpSettingsResponse.fromJS(_data['vh_idp_settings']) : <any>undefined;
        }
    }

    static fromJS(data: any): ClientSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['app_insights_instrumentation_key'] = this.app_insights_instrumentation_key;
        data['event_hub_path'] = this.event_hub_path;
        data['join_by_phone_from_date'] = this.join_by_phone_from_date;
        data['kinly_turn_server'] = this.kinly_turn_server;
        data['kinly_turn_server_user'] = this.kinly_turn_server_user;
        data['kinly_turn_server_credential'] = this.kinly_turn_server_credential;
        data['e_jud_idp_settings'] = this.e_jud_idp_settings ? this.e_jud_idp_settings.toJSON() : <any>undefined;
        data['vh_idp_settings'] = this.vh_idp_settings ? this.vh_idp_settings.toJSON() : <any>undefined;
        return data;
    }
}

/** Configuration to initialise the UI application */
export interface IClientSettingsResponse {
    app_insights_instrumentation_key?: string | undefined;
    event_hub_path?: string | undefined;
    join_by_phone_from_date?: string | undefined;
    kinly_turn_server?: string | undefined;
    kinly_turn_server_user?: string | undefined;
    kinly_turn_server_credential?: string | undefined;
    e_jud_idp_settings?: IdpSettingsResponse | undefined;
    vh_idp_settings?: IdpSettingsResponse | undefined;
}

/** Leave a private consultation */
export class LeavePrivateConsultationRequest implements ILeavePrivateConsultationRequest {
    conference_id?: string;
    participant_id?: string;

    constructor(data?: ILeavePrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
        }
    }

    static fromJS(data: any): LeavePrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        return data;
    }
}

/** Leave a private consultation */
export interface ILeavePrivateConsultationRequest {
    conference_id?: string;
    participant_id?: string;
}

export enum ConsultationAnswer {
    None = 'None',
    Accepted = 'Accepted',
    Rejected = 'Rejected',
    Failed = 'Failed',
    Transferring = 'Transferring'
}

/** Raise or respond to a private consultation request */
export class PrivateConsultationRequest implements IPrivateConsultationRequest {
    invitation_id?: string;
    conference_id?: string;
    requested_by_id?: string;
    requested_for_id?: string;
    /** Response to a consultation request (i.e. 'Accepted or Rejected') */
    answer?: ConsultationAnswer;
    room_label?: string | undefined;

    constructor(data?: IPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invitation_id = _data['invitation_id'];
            this.conference_id = _data['conference_id'];
            this.requested_by_id = _data['requested_by_id'];
            this.requested_for_id = _data['requested_for_id'];
            this.answer = _data['answer'];
            this.room_label = _data['room_label'];
        }
    }

    static fromJS(data: any): PrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['invitation_id'] = this.invitation_id;
        data['conference_id'] = this.conference_id;
        data['requested_by_id'] = this.requested_by_id;
        data['requested_for_id'] = this.requested_for_id;
        data['answer'] = this.answer;
        data['room_label'] = this.room_label;
        return data;
    }
}

/** Raise or respond to a private consultation request */
export interface IPrivateConsultationRequest {
    invitation_id?: string;
    conference_id?: string;
    requested_by_id?: string;
    requested_for_id?: string;
    /** Response to a consultation request (i.e. 'Accepted or Rejected') */
    answer?: ConsultationAnswer;
    room_label?: string | undefined;
}

export class JoinPrivateConsultationRequest implements IJoinPrivateConsultationRequest {
    conference_id?: string;
    participant_id?: string;
    room_label?: string | undefined;

    constructor(data?: IJoinPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
            this.room_label = _data['room_label'];
        }
    }

    static fromJS(data: any): JoinPrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JoinPrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        data['room_label'] = this.room_label;
        return data;
    }
}

export interface IJoinPrivateConsultationRequest {
    conference_id?: string;
    participant_id?: string;
    room_label?: string | undefined;
}

export enum VirtualCourtRoomType {
    JudgeJOH = 'JudgeJOH',
    Participant = 'Participant'
}

export class StartPrivateConsultationRequest implements IStartPrivateConsultationRequest {
    invite_participants?: string[] | undefined;
    invite_endpoints?: string[] | undefined;
    conference_id?: string;
    requested_by?: string;
    room_type?: VirtualCourtRoomType;

    constructor(data?: IStartPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['invite_participants'])) {
                this.invite_participants = [] as any;
                for (let item of _data['invite_participants']) this.invite_participants!.push(item);
            }
            if (Array.isArray(_data['invite_endpoints'])) {
                this.invite_endpoints = [] as any;
                for (let item of _data['invite_endpoints']) this.invite_endpoints!.push(item);
            }
            this.conference_id = _data['conference_id'];
            this.requested_by = _data['requested_by'];
            this.room_type = _data['room_type'];
        }
    }

    static fromJS(data: any): StartPrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartPrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.invite_participants)) {
            data['invite_participants'] = [];
            for (let item of this.invite_participants) data['invite_participants'].push(item);
        }
        if (Array.isArray(this.invite_endpoints)) {
            data['invite_endpoints'] = [];
            for (let item of this.invite_endpoints) data['invite_endpoints'].push(item);
        }
        data['conference_id'] = this.conference_id;
        data['requested_by'] = this.requested_by;
        data['room_type'] = this.room_type;
        return data;
    }
}

export interface IStartPrivateConsultationRequest {
    invite_participants?: string[] | undefined;
    invite_endpoints?: string[] | undefined;
    conference_id?: string;
    requested_by?: string;
    room_type?: VirtualCourtRoomType;
}

export class LockConsultationRoomRequest implements ILockConsultationRoomRequest {
    conference_id?: string;
    room_label?: string | undefined;
    /** The desired lock state of the room */
    lock?: boolean;

    constructor(data?: ILockConsultationRoomRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.room_label = _data['room_label'];
            this.lock = _data['lock'];
        }
    }

    static fromJS(data: any): LockConsultationRoomRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LockConsultationRoomRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['room_label'] = this.room_label;
        data['lock'] = this.lock;
        return data;
    }
}

export interface ILockConsultationRoomRequest {
    conference_id?: string;
    room_label?: string | undefined;
    /** The desired lock state of the room */
    lock?: boolean;
}

export class InviteToConsultationRequest implements IInviteToConsultationRequest {
    conference_id?: string;
    room_label?: string | undefined;
    participant_id?: string;

    constructor(data?: IInviteToConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.room_label = _data['room_label'];
            this.participant_id = _data['participant_id'];
        }
    }

    static fromJS(data: any): InviteToConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InviteToConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['room_label'] = this.room_label;
        data['participant_id'] = this.participant_id;
        return data;
    }
}

export interface IInviteToConsultationRequest {
    conference_id?: string;
    room_label?: string | undefined;
    participant_id?: string;
}

export class AddEndpointConsultationRequest implements IAddEndpointConsultationRequest {
    conference_id?: string;
    room_label?: string | undefined;
    endpoint_id?: string;

    constructor(data?: IAddEndpointConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.room_label = _data['room_label'];
            this.endpoint_id = _data['endpoint_id'];
        }
    }

    static fromJS(data: any): AddEndpointConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddEndpointConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['room_label'] = this.room_label;
        data['endpoint_id'] = this.endpoint_id;
        return data;
    }
}

export interface IAddEndpointConsultationRequest {
    conference_id?: string;
    room_label?: string | undefined;
    endpoint_id?: string;
}

export class AllowedEndpointResponse implements IAllowedEndpointResponse {
    id?: string;
    display_name?: string | undefined;
    defence_advocate_username?: string | undefined;

    constructor(data?: IAllowedEndpointResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.display_name = _data['display_name'];
            this.defence_advocate_username = _data['defence_advocate_username'];
        }
    }

    static fromJS(data: any): AllowedEndpointResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AllowedEndpointResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['display_name'] = this.display_name;
        data['defence_advocate_username'] = this.defence_advocate_username;
        return data;
    }
}

export interface IAllowedEndpointResponse {
    id?: string;
    display_name?: string | undefined;
    defence_advocate_username?: string | undefined;
}

export class HealthCheck implements IHealthCheck {
    successful?: boolean;
    error_message?: string | undefined;
    data?: { [key: string]: any } | undefined;

    constructor(data?: IHealthCheck) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.successful = _data['successful'];
            this.error_message = _data['error_message'];
            if (_data['data']) {
                this.data = {} as any;
                for (let key in _data['data']) {
                    if (_data['data'].hasOwnProperty(key)) (<any>this.data)![key] = _data['data'][key];
                }
            }
        }
    }

    static fromJS(data: any): HealthCheck {
        data = typeof data === 'object' ? data : {};
        let result = new HealthCheck();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['successful'] = this.successful;
        data['error_message'] = this.error_message;
        if (this.data) {
            data['data'] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key)) (<any>data['data'])[key] = this.data[key];
            }
        }
        return data;
    }
}

export interface IHealthCheck {
    successful?: boolean;
    error_message?: string | undefined;
    data?: { [key: string]: any } | undefined;
}

export class ApplicationVersion implements IApplicationVersion {
    file_version?: string | undefined;
    information_version?: string | undefined;

    constructor(data?: IApplicationVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file_version = _data['file_version'];
            this.information_version = _data['information_version'];
        }
    }

    static fromJS(data: any): ApplicationVersion {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['file_version'] = this.file_version;
        data['information_version'] = this.information_version;
        return data;
    }
}

export interface IApplicationVersion {
    file_version?: string | undefined;
    information_version?: string | undefined;
}

export class HealthCheckResponse implements IHealthCheckResponse {
    bookings_api_health?: HealthCheck | undefined;
    user_api_health?: HealthCheck | undefined;
    video_api_health?: HealthCheck | undefined;
    app_version?: ApplicationVersion | undefined;

    constructor(data?: IHealthCheckResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookings_api_health = _data['bookings_api_health'] ? HealthCheck.fromJS(_data['bookings_api_health']) : <any>undefined;
            this.user_api_health = _data['user_api_health'] ? HealthCheck.fromJS(_data['user_api_health']) : <any>undefined;
            this.video_api_health = _data['video_api_health'] ? HealthCheck.fromJS(_data['video_api_health']) : <any>undefined;
            this.app_version = _data['app_version'] ? ApplicationVersion.fromJS(_data['app_version']) : <any>undefined;
        }
    }

    static fromJS(data: any): HealthCheckResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HealthCheckResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['bookings_api_health'] = this.bookings_api_health ? this.bookings_api_health.toJSON() : <any>undefined;
        data['user_api_health'] = this.user_api_health ? this.user_api_health.toJSON() : <any>undefined;
        data['video_api_health'] = this.video_api_health ? this.video_api_health.toJSON() : <any>undefined;
        data['app_version'] = this.app_version ? this.app_version.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHealthCheckResponse {
    bookings_api_health?: HealthCheck | undefined;
    user_api_health?: HealthCheck | undefined;
    video_api_health?: HealthCheck | undefined;
    app_version?: ApplicationVersion | undefined;
}

export class ChatResponse implements IChatResponse {
    /** Message UUID */
    readonly id?: string;
    /** Username of sender */
    from?: string | undefined;
    from_display_name?: string | undefined;
    /** Username of recipient */
    to?: string | undefined;
    /** Body of message */
    message?: string | undefined;
    /** Time of message */
    timestamp?: Date;
    is_user?: boolean;

    constructor(data?: IChatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data['id'];
            this.from = _data['from'];
            this.from_display_name = _data['from_display_name'];
            this.to = _data['to'];
            this.message = _data['message'];
            this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
            this.is_user = _data['is_user'];
        }
    }

    static fromJS(data: any): ChatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['from'] = this.from;
        data['from_display_name'] = this.from_display_name;
        data['to'] = this.to;
        data['message'] = this.message;
        data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data['is_user'] = this.is_user;
        return data;
    }
}

export interface IChatResponse {
    /** Message UUID */
    id?: string;
    /** Username of sender */
    from?: string | undefined;
    from_display_name?: string | undefined;
    /** Username of recipient */
    to?: string | undefined;
    /** Body of message */
    message?: string | undefined;
    /** Time of message */
    timestamp?: Date;
    is_user?: boolean;
}

export class UnreadAdminMessageResponse implements IUnreadAdminMessageResponse {
    participant_username?: string | undefined;
    number_of_unread_messages?: number;
    participant_id?: string;
    conference_id?: string;

    constructor(data?: IUnreadAdminMessageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participant_username = _data['participant_username'];
            this.number_of_unread_messages = _data['number_of_unread_messages'];
            this.participant_id = _data['participant_id'];
        }
    }

    static fromJS(data: any): UnreadAdminMessageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnreadAdminMessageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['participant_username'] = this.participant_username;
        data['number_of_unread_messages'] = this.number_of_unread_messages;
        data['participant_id'] = this.participant_id;
        return data;
    }
}

export interface IUnreadAdminMessageResponse {
    participant_username?: string | undefined;
    number_of_unread_messages?: number;
    participant_id?: string;
    conference_id?: string;
}

export class UnreadInstantMessageConferenceCountResponse implements IUnreadInstantMessageConferenceCountResponse {
    number_of_unread_messages_conference?: UnreadAdminMessageResponse[] | undefined;

    constructor(data?: IUnreadInstantMessageConferenceCountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['number_of_unread_messages_conference'])) {
                this.number_of_unread_messages_conference = [] as any;
                for (let item of _data['number_of_unread_messages_conference'])
                    this.number_of_unread_messages_conference!.push(UnreadAdminMessageResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UnreadInstantMessageConferenceCountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnreadInstantMessageConferenceCountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.number_of_unread_messages_conference)) {
            data['number_of_unread_messages_conference'] = [];
            for (let item of this.number_of_unread_messages_conference) data['number_of_unread_messages_conference'].push(item.toJSON());
        }
        return data;
    }
}

export interface IUnreadInstantMessageConferenceCountResponse {
    number_of_unread_messages_conference?: UnreadAdminMessageResponse[] | undefined;
}

export enum EventType {
    None = 'None',
    Joined = 'Joined',
    Disconnected = 'Disconnected',
    Transfer = 'Transfer',
    Help = 'Help',
    Start = 'Start',
    CountdownFinished = 'CountdownFinished',
    Pause = 'Pause',
    Close = 'Close',
    Leave = 'Leave',
    Consultation = 'Consultation',
    MediaPermissionDenied = 'MediaPermissionDenied',
    ParticipantJoining = 'ParticipantJoining',
    SelfTestFailed = 'SelfTestFailed',
    Suspend = 'Suspend',
    VhoCall = 'VhoCall',
    ParticipantNotSignedIn = 'ParticipantNotSignedIn',
    EndpointJoined = 'EndpointJoined',
    EndpointDisconnected = 'EndpointDisconnected',
    EndpointTransfer = 'EndpointTransfer',
    ConnectingToEventHub = 'ConnectingToEventHub',
    SelectingMedia = 'SelectingMedia',
    ConnectingToConference = 'ConnectingToConference',
    RoomParticipantJoined = 'RoomParticipantJoined',
    RoomParticipantDisconnected = 'RoomParticipantDisconnected',
    RoomParticipantTransfer = 'RoomParticipantTransfer'
}

export class AddMediaEventRequest implements IAddMediaEventRequest {
    readonly event_type?: EventType;

    constructor(data?: IAddMediaEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).event_type = _data['event_type'];
        }
    }

    static fromJS(data: any): AddMediaEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddMediaEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        return data;
    }
}

export interface IAddMediaEventRequest {
    event_type?: EventType;
}

export enum SelfTestFailureReason {
    Camera = 'Camera',
    Microphone = 'Microphone',
    Video = 'Video',
    BadScore = 'BadScore',
    IncompleteTest = 'IncompleteTest'
}

export class AddSelfTestFailureEventRequest implements IAddSelfTestFailureEventRequest {
    readonly event_type?: EventType;
    self_test_failure_reason?: SelfTestFailureReason;

    constructor(data?: IAddSelfTestFailureEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).event_type = _data['event_type'];
            this.self_test_failure_reason = _data['self_test_failure_reason'];
        }
    }

    static fromJS(data: any): AddSelfTestFailureEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddSelfTestFailureEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        data['self_test_failure_reason'] = this.self_test_failure_reason;
        return data;
    }
}

export interface IAddSelfTestFailureEventRequest {
    event_type?: EventType;
    self_test_failure_reason?: SelfTestFailureReason;
}

export enum TestScore {
    Good = 'Good',
    Okay = 'Okay',
    Bad = 'Bad'
}

export class TestCallScoreResponse implements ITestCallScoreResponse {
    score?: TestScore;
    passed?: boolean;

    constructor(data?: ITestCallScoreResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.score = _data['score'];
            this.passed = _data['passed'];
        }
    }

    static fromJS(data: any): TestCallScoreResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestCallScoreResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['score'] = this.score;
        data['passed'] = this.passed;
        return data;
    }
}

export interface ITestCallScoreResponse {
    score?: TestScore;
    passed?: boolean;
}

export class UpdateParticipantStatusEventRequest implements IUpdateParticipantStatusEventRequest {
    event_type?: EventType;

    constructor(data?: IUpdateParticipantStatusEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_type = _data['event_type'];
        }
    }

    static fromJS(data: any): UpdateParticipantStatusEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantStatusEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        return data;
    }
}

export interface IUpdateParticipantStatusEventRequest {
    event_type?: EventType;
}

export class ParticipantHeartbeatResponse implements IParticipantHeartbeatResponse {
    recent_packet_loss?: number;
    browser_name?: string | undefined;
    browser_version?: string | undefined;
    operating_system?: string | undefined;
    operating_system_version?: string | undefined;
    timestamp?: Date;

    constructor(data?: IParticipantHeartbeatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recent_packet_loss = _data['recent_packet_loss'];
            this.browser_name = _data['browser_name'];
            this.browser_version = _data['browser_version'];
            this.operating_system = _data['operating_system'];
            this.operating_system_version = _data['operating_system_version'];
            this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipantHeartbeatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantHeartbeatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['recent_packet_loss'] = this.recent_packet_loss;
        data['browser_name'] = this.browser_name;
        data['browser_version'] = this.browser_version;
        data['operating_system'] = this.operating_system;
        data['operating_system_version'] = this.operating_system_version;
        data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IParticipantHeartbeatResponse {
    recent_packet_loss?: number;
    browser_name?: string | undefined;
    browser_version?: string | undefined;
    operating_system?: string | undefined;
    operating_system_version?: string | undefined;
    timestamp?: Date;
}

export class UpdateParticipantDisplayNameRequest implements IUpdateParticipantDisplayNameRequest {
    /** Participant Fullname */
    fullname?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    /** Representee */
    representee?: string | undefined;

    constructor(data?: IUpdateParticipantDisplayNameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullname = _data['fullname'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.display_name = _data['display_name'];
            this.representee = _data['representee'];
        }
    }

    static fromJS(data: any): UpdateParticipantDisplayNameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantDisplayNameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['fullname'] = this.fullname;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['display_name'] = this.display_name;
        data['representee'] = this.representee;
        return data;
    }
}

export interface IUpdateParticipantDisplayNameRequest {
    /** Participant Fullname */
    fullname?: string | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    /** Representee */
    representee?: string | undefined;
}

export class ParticipantContactDetailsResponseVho implements IParticipantContactDetailsResponseVho {
    /** The participant id in a conference */
    id?: string;
    conference_id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    /** The participant's user role */
    role?: Role;
    hearing_role?: string | undefined;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    case_type_group?: string | undefined;
    ref_id?: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    contact_telephone?: string | undefined;
    hearing_venue_name?: string | undefined;
    judge_in_another_hearing?: boolean;
    /** The participant represented by the representative */
    representee?: string | undefined;
    linked_participants?: LinkedParticipantResponse[] | undefined;

    constructor(data?: IParticipantContactDetailsResponseVho) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.conference_id = _data['conference_id'];
            this.name = _data['name'];
            this.username = _data['username'];
            this.role = _data['role'];
            this.hearing_role = _data['hearing_role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.case_type_group = _data['case_type_group'];
            this.ref_id = _data['ref_id'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.contact_email = _data['contact_email'];
            this.contact_telephone = _data['contact_telephone'];
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.judge_in_another_hearing = _data['judge_in_another_hearing'];
            this.representee = _data['representee'];
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantContactDetailsResponseVho {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantContactDetailsResponseVho();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['conference_id'] = this.conference_id;
        data['name'] = this.name;
        data['username'] = this.username;
        data['role'] = this.role;
        data['hearing_role'] = this.hearing_role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['case_type_group'] = this.case_type_group;
        data['ref_id'] = this.ref_id;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['contact_email'] = this.contact_email;
        data['contact_telephone'] = this.contact_telephone;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['judge_in_another_hearing'] = this.judge_in_another_hearing;
        data['representee'] = this.representee;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

export interface IParticipantContactDetailsResponseVho {
    /** The participant id in a conference */
    id?: string;
    conference_id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    /** The participant's user role */
    role?: Role;
    hearing_role?: string | undefined;
    /** The participant's status */
    status?: ParticipantStatus;
    display_name?: string | undefined;
    case_type_group?: string | undefined;
    ref_id?: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    contact_email?: string | undefined;
    contact_telephone?: string | undefined;
    hearing_venue_name?: string | undefined;
    judge_in_another_hearing?: boolean;
    /** The participant represented by the representative */
    representee?: string | undefined;
    linked_participants?: LinkedParticipantResponse[] | undefined;
}

export class LoggedParticipantResponse implements ILoggedParticipantResponse {
    participant_id?: string;
    admin_username?: string | undefined;
    role?: Role;
    display_name?: string | undefined;

    constructor(data?: ILoggedParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participant_id = _data['participant_id'];
            this.admin_username = _data['admin_username'];
            this.role = _data['role'];
            this.display_name = _data['display_name'];
        }
    }

    static fromJS(data: any): LoggedParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoggedParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['participant_id'] = this.participant_id;
        data['admin_username'] = this.admin_username;
        data['role'] = this.role;
        data['display_name'] = this.display_name;
        return data;
    }
}

export interface ILoggedParticipantResponse {
    participant_id?: string;
    admin_username?: string | undefined;
    role?: Role;
    display_name?: string | undefined;
}

export class UserProfileResponse implements IUserProfileResponse {
    role?: Role;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    username?: string | undefined;

    constructor(data?: IUserProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data['role'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.display_name = _data['display_name'];
            this.username = _data['username'];
        }
    }

    static fromJS(data: any): UserProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['role'] = this.role;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['display_name'] = this.display_name;
        data['username'] = this.username;
        return data;
    }
}

export interface IUserProfileResponse {
    role?: Role;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    username?: string | undefined;
}

export class SelfTestPexipResponse implements ISelfTestPexipResponse {
    pexip_self_test_node?: string | undefined;

    constructor(data?: ISelfTestPexipResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pexip_self_test_node = _data['pexip_self_test_node'];
        }
    }

    static fromJS(data: any): SelfTestPexipResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SelfTestPexipResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['pexip_self_test_node'] = this.pexip_self_test_node;
        return data;
    }
}

export interface ISelfTestPexipResponse {
    pexip_self_test_node?: string | undefined;
}

export enum TaskType {
    Hearing = 'Hearing',
    Judge = 'Judge',
    Participant = 'Participant'
}

export enum TaskStatus {
    ToDo = 'ToDo',
    Done = 'Done'
}

export class TaskResponse implements ITaskResponse {
    id?: number;
    origin_id?: string;
    body?: string | undefined;
    type?: TaskType;
    status?: TaskStatus;
    created?: Date;
    updated?: Date | undefined;
    updated_by?: string | undefined;

    constructor(data?: ITaskResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.origin_id = _data['origin_id'];
            this.body = _data['body'];
            this.type = _data['type'];
            this.status = _data['status'];
            this.created = _data['created'] ? new Date(_data['created'].toString()) : <any>undefined;
            this.updated = _data['updated'] ? new Date(_data['updated'].toString()) : <any>undefined;
            this.updated_by = _data['updated_by'];
        }
    }

    static fromJS(data: any): TaskResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['origin_id'] = this.origin_id;
        data['body'] = this.body;
        data['type'] = this.type;
        data['status'] = this.status;
        data['created'] = this.created ? this.created.toISOString() : <any>undefined;
        data['updated'] = this.updated ? this.updated.toISOString() : <any>undefined;
        data['updated_by'] = this.updated_by;
        return data;
    }
}

export interface ITaskResponse {
    id?: number;
    origin_id?: string;
    body?: string | undefined;
    type?: TaskType;
    status?: TaskStatus;
    created?: Date;
    updated?: Date | undefined;
    updated_by?: string | undefined;
}

export class TokenResponse implements ITokenResponse {
    expires_on?: string | undefined;
    token?: string | undefined;

    constructor(data?: ITokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expires_on = _data['expires_on'];
            this.token = _data['token'];
        }
    }

    static fromJS(data: any): TokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['expires_on'] = this.expires_on;
        data['token'] = this.token;
        return data;
    }
}

export interface ITokenResponse {
    expires_on?: string | undefined;
    token?: string | undefined;
}

export class CourtRoomsAccountResponse implements ICourtRoomsAccountResponse {
    /** The venue name (judge first name) */
    venue?: string | undefined;
    court_rooms?: string[] | undefined;

    constructor(data?: ICourtRoomsAccountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.venue = _data['venue'];
            if (Array.isArray(_data['court_rooms'])) {
                this.court_rooms = [] as any;
                for (let item of _data['court_rooms']) this.court_rooms!.push(item);
            }
        }
    }

    static fromJS(data: any): CourtRoomsAccountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CourtRoomsAccountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['venue'] = this.venue;
        if (Array.isArray(this.court_rooms)) {
            data['court_rooms'] = [];
            for (let item of this.court_rooms) data['court_rooms'].push(item);
        }
        return data;
    }
}

export interface ICourtRoomsAccountResponse {
    /** The venue name (judge first name) */
    venue?: string | undefined;
    court_rooms?: string[] | undefined;
}

export class HearingVenueResponse implements IHearingVenueResponse {
    id?: number;
    name?: string | undefined;
    constructor(data?: IHearingVenueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }
    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
        }
    }
    static fromJS(data: any): HearingVenueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HearingVenueResponse();
        result.init(data);
        return result;
    }
    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        return data;
    }
}
export interface IHearingVenueResponse {
    id?: number;
    name?: string | undefined;
}

export class ConferenceEventRequest implements IConferenceEventRequest {
    event_id?: string | undefined;
    event_type?: EventType;
    time_stamp_utc?: Date;
    conference_id?: string | undefined;
    participant_id?: string | undefined;
    participant_room_id?: string | undefined;
    transfer_from?: string | undefined;
    transfer_to?: string | undefined;
    reason?: string | undefined;
    phone?: string | undefined;

    constructor(data?: IConferenceEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_id = _data['event_id'];
            this.event_type = _data['event_type'];
            this.time_stamp_utc = _data['time_stamp_utc'] ? new Date(_data['time_stamp_utc'].toString()) : <any>undefined;
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
            this.participant_room_id = _data['participant_room_id'];
            this.transfer_from = _data['transfer_from'];
            this.transfer_to = _data['transfer_to'];
            this.reason = _data['reason'];
            this.phone = _data['phone'];
        }
    }

    static fromJS(data: any): ConferenceEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_id'] = this.event_id;
        data['event_type'] = this.event_type;
        data['time_stamp_utc'] = this.time_stamp_utc ? this.time_stamp_utc.toISOString() : <any>undefined;
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        data['participant_room_id'] = this.participant_room_id;
        data['transfer_from'] = this.transfer_from;
        data['transfer_to'] = this.transfer_to;
        data['reason'] = this.reason;
        data['phone'] = this.phone;
        return data;
    }
}

export interface IConferenceEventRequest {
    event_id?: string | undefined;
    event_type?: EventType;
    time_stamp_utc?: Date;
    conference_id?: string | undefined;
    participant_id?: string | undefined;
    participant_room_id?: string | undefined;
    transfer_from?: string | undefined;
    transfer_to?: string | undefined;
    reason?: string | undefined;
    phone?: string | undefined;
}

export class SharedParticipantRoom implements ISharedParticipantRoom {
    pexip_node?: string | undefined;
    participant_join_uri?: string | undefined;
    display_name?: string | undefined;
    tile_display_name?: string | undefined;

    constructor(data?: ISharedParticipantRoom) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pexip_node = _data['pexip_node'];
            this.participant_join_uri = _data['participant_join_uri'];
            this.display_name = _data['display_name'];
            this.tile_display_name = _data['tile_display_name'];
        }
    }

    static fromJS(data: any): SharedParticipantRoom {
        data = typeof data === 'object' ? data : {};
        let result = new SharedParticipantRoom();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['pexip_node'] = this.pexip_node;
        data['participant_join_uri'] = this.participant_join_uri;
        data['display_name'] = this.display_name;
        data['tile_display_name'] = this.tile_display_name;
        return data;
    }
}

export interface ISharedParticipantRoom {
    pexip_node?: string | undefined;
    participant_join_uri?: string | undefined;
    display_name?: string | undefined;
    tile_display_name?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): Observable<any> {
    if (result !== null && result !== undefined) return _observableThrow(result);
    else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next('');
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
