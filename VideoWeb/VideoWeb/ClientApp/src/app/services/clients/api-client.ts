//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export class ApiClientBase {
    protected transformOptions(options: any) {
        options.headers = options.headers.append('Cache-Control', 'no-store');
        return Promise.resolve(options);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiClient extends ApiClientBase {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ?? 'https://localhost:5800';
    }

    /**
     * Start or resume a video hearing
     * @param conferenceId conference id
     * @param body (optional) start hearing request details
     * @return Accepted
     */
    startOrResumeVideoHearing(conferenceId: string, body: StartOrResumeVideoHearingRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/start';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStartOrResumeVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStartOrResumeVideoHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processStartOrResumeVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Returns the active layout for a conference
     * @param conferenceId conference id
     * @return OK
     */
    getLayoutForHearing(conferenceId: string): Observable<HearingLayout> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/getlayout';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetLayoutForHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetLayoutForHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingLayout>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingLayout>;
                })
            );
    }

    protected processGetLayoutForHearing(response: HttpResponseBase): Observable<HearingLayout> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;

                    return _observableOf(result200);
                })
            );
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result403: any = null;
                    let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result403 = ProblemDetails.fromJS(resultData403);
                    return throwException('Forbidden', status, _responseText, _headers, result403);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HearingLayout>(null as any);
    }

    /**
     * Update the active layout for a conference
     * @param conferenceId conference id
     * @param layout (optional) layout
     * @return OK
     */
    updateLayoutForHearing(conferenceId: string, layout: HearingLayout | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/updatelayout?';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (layout === null) throw new Error("The parameter 'layout' cannot be null.");
        else if (layout !== undefined) url_ += 'layout=' + encodeURIComponent('' + layout) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateLayoutForHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateLayoutForHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processUpdateLayoutForHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result403: any = null;
                    let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result403 = ProblemDetails.fromJS(resultData403);
                    return throwException('Forbidden', status, _responseText, _headers, result403);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get recommended layout for hearing
     * @param conferenceId conference id
     * @return OK
     */
    getRecommendedLayoutForHearing(conferenceId: string): Observable<HearingLayout> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/getrecommendedlayout';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetRecommendedLayoutForHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetRecommendedLayoutForHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingLayout>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingLayout>;
                })
            );
    }

    protected processGetRecommendedLayoutForHearing(response: HttpResponseBase): Observable<HearingLayout> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;

                    return _observableOf(result200);
                })
            );
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result403: any = null;
                    let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result403 = ProblemDetails.fromJS(resultData403);
                    return throwException('Forbidden', status, _responseText, _headers, result403);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HearingLayout>(null as any);
    }

    /**
     * Pause a video hearing
     * @param conferenceId conference id
     * @return Accepted
     */
    pauseVideoHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/pause';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processPauseVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processPauseVideoHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processPauseVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Suspend a video hearing
     * @param conferenceId conference id
     * @return Accepted
     */
    suspendVideoHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/suspend';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSuspendVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSuspendVideoHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processSuspendVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * End a video hearing
     * @param conferenceId conference id
     * @return Accepted
     */
    endVideoHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/end';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processEndVideoHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processEndVideoHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processEndVideoHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Admit a participant into an active video hearing
     * @param conferenceId conference id
     * @param participantId participant or endpoint id
     * @return Accepted
     */
    callParticipant(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/call';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCallParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCallParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processCallParticipant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Joins a video hearing currently in session
     * @param conferenceId conference id
     * @param participantId participant id
     * @return Accepted
     */
    joinHearingInSession(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/join-hearing';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processJoinHearingInSession(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processJoinHearingInSession(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processJoinHearingInSession(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Call a participant into a video hearing
     * @param conferenceId conference id
     * @param participantId participant or endpoint id
     * @return Accepted
     */
    dismissParticipant(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/dismiss';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDismissParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDismissParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processDismissParticipant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Leave host from hearing
     * @param conferenceId conference id
     * @param participantId participant id
     * @return Accepted
     */
    leaveHearing(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/leave';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLeaveHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLeaveHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processLeaveHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Leave host from hearing
     * @param conferenceId conference id
     * @return Accepted
     */
    nonHostLeaveHearing(conferenceId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/non-host-leave';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processNonHostLeaveHearing(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processNonHostLeaveHearing(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processNonHostLeaveHearing(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get conferences today for a host
     * @return OK
     */
    getConferencesForHost(): Observable<ConferenceForHostResponse[]> {
        let url_ = this.baseUrl + '/conferences/hosts';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForHost(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForHost(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceForHostResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceForHostResponse[]>;
                })
            );
    }

    protected processGetConferencesForHost(response: HttpResponseBase): Observable<ConferenceForHostResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForHostResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForHostResponse[]>(null as any);
    }

    /**
     * Get conferences today for staff member with the specifed hearing venue names
     * @param hearingVenueNames (optional)
     * @return OK
     */
    getConferencesForStaffMember(hearingVenueNames: string[] | undefined): Observable<ConferenceForHostResponse[]> {
        let url_ = this.baseUrl + '/conferences/staffmember?';
        if (hearingVenueNames === null) throw new Error("The parameter 'hearingVenueNames' cannot be null.");
        else if (hearingVenueNames !== undefined)
            hearingVenueNames &&
                hearingVenueNames.forEach(item => {
                    url_ += 'hearingVenueNames=' + encodeURIComponent('' + item) + '&';
                });
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForStaffMember(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForStaffMember(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceForHostResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceForHostResponse[]>;
                })
            );
    }

    protected processGetConferencesForStaffMember(response: HttpResponseBase): Observable<ConferenceForHostResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForHostResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForHostResponse[]>(null as any);
    }

    /**
     * Get conferences today for individual or representative excluding those that have been closed for over 120 minutes
     * @return OK
     */
    getConferencesForIndividual(): Observable<ConferenceForIndividualResponse[]> {
        let url_ = this.baseUrl + '/conferences/individuals';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForIndividual(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForIndividual(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceForIndividualResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceForIndividualResponse[]>;
                })
            );
    }

    protected processGetConferencesForIndividual(response: HttpResponseBase): Observable<ConferenceForIndividualResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForIndividualResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForIndividualResponse[]>(null as any);
    }

    /**
     * Get conferences for user
     * @param hearingVenueNames (optional)
     * @param allocatedCsoIds (optional)
     * @param includeUnallocated (optional)
     * @return OK
     */
    getConferencesForVhOfficer(
        hearingVenueNames: string[] | undefined,
        allocatedCsoIds: string[] | undefined,
        includeUnallocated: boolean | undefined
    ): Observable<ConferenceForVhOfficerResponse[]> {
        let url_ = this.baseUrl + '/conferences/vhofficer?';
        if (hearingVenueNames === null) throw new Error("The parameter 'hearingVenueNames' cannot be null.");
        else if (hearingVenueNames !== undefined)
            hearingVenueNames &&
                hearingVenueNames.forEach(item => {
                    url_ += 'HearingVenueNames=' + encodeURIComponent('' + item) + '&';
                });
        if (allocatedCsoIds === null) throw new Error("The parameter 'allocatedCsoIds' cannot be null.");
        else if (allocatedCsoIds !== undefined)
            allocatedCsoIds &&
                allocatedCsoIds.forEach(item => {
                    url_ += 'AllocatedCsoIds=' + encodeURIComponent('' + item) + '&';
                });
        if (includeUnallocated === null) throw new Error("The parameter 'includeUnallocated' cannot be null.");
        else if (includeUnallocated !== undefined) url_ += 'IncludeUnallocated=' + encodeURIComponent('' + includeUnallocated) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferencesForVhOfficer(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferencesForVhOfficer(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceForVhOfficerResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceForVhOfficerResponse[]>;
                })
            );
    }

    protected processGetConferencesForVhOfficer(response: HttpResponseBase): Observable<ConferenceForVhOfficerResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForVhOfficerResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result401: any = null;
                    let resultData401 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result401 = ProblemDetails.fromJS(resultData401);
                    return throwException('Unauthorized', status, _responseText, _headers, result401);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForVhOfficerResponse[]>(null as any);
    }

    /**
     * Get the details of a conference by id for VH officer
     * @param conferenceId The unique id of the conference
     * @return OK
     */
    getConferenceByIdVHO(conferenceId: string): Observable<ConferenceResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/vhofficer';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceByIdVHO(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceByIdVHO(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceResponse>;
                })
            );
    }

    protected processGetConferenceByIdVHO(response: HttpResponseBase): Observable<ConferenceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceResponse>(null as any);
    }

    /**
     * Get the details of a conference by id
     * @param conferenceId The unique id of the conference
     * @return OK
     */
    getConferenceById(conferenceId: string): Observable<ConferenceResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceById(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceById(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceResponse>;
                })
            );
    }

    protected processGetConferenceById(response: HttpResponseBase): Observable<ConferenceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('No Content', status, _responseText, _headers);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceResponse>(null as any);
    }

    /**
     * Updates the video control statuses for the conference
     * @param conferenceId conference id
     * @param body (optional) Request object to set Video Control Staus
     * @return Accepted
     */
    setVideoControlStatusesForConference(
        conferenceId: string,
        body: SetConferenceVideoControlStatusesRequest | undefined
    ): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/setVideoControlStatuses';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('put', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSetVideoControlStatusesForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSetVideoControlStatusesForConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processSetVideoControlStatusesForConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Returns the video control statuses for the conference
     * @param conferenceId conference id
     * @return OK
     */
    getVideoControlStatusesForConference(conferenceId: string): Observable<ConferenceVideoControlStatuses> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/getVideoControlStatuses';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetVideoControlStatusesForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetVideoControlStatusesForConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceVideoControlStatuses>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceVideoControlStatuses>;
                })
            );
    }

    protected processGetVideoControlStatusesForConference(response: HttpResponseBase): Observable<ConferenceVideoControlStatuses> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceVideoControlStatuses.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceVideoControlStatuses>(null as any);
    }

    /**
     * GetClientConfigurationSettings the configuration settings for client
     * @return OK
     */
    getClientConfigurationSettings(): Observable<ClientSettingsResponse> {
        let url_ = this.baseUrl + '/config';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetClientConfigurationSettings(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetClientConfigurationSettings(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ClientSettingsResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ClientSettingsResponse>;
                })
            );
    }

    protected processGetClientConfigurationSettings(response: HttpResponseBase): Observable<ClientSettingsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ClientSettingsResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ClientSettingsResponse>(null as any);
    }

    /**
     * Leave the Consultation
     * @param body (optional)
     * @return No Content
     */
    leaveConsultation(body: LeavePrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/leave';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLeaveConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLeaveConsultation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processLeaveConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Send response to Consultation Request
     * @param body (optional)
     * @return No Content
     */
    respondToConsultationRequest(body: PrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/respond';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processRespondToConsultationRequest(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processRespondToConsultationRequest(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processRespondToConsultationRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Join a private consultation
     * @param body (optional)
     * @return Accepted
     */
    joinPrivateConsultation(body: JoinPrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/joinPrivateConsultation';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processJoinPrivateConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processJoinPrivateConsultation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processJoinPrivateConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Start a private consultation
     * @param body (optional)
     * @return Accepted
     */
    startOrJoinConsultation(body: StartPrivateConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/start';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStartOrJoinConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStartOrJoinConsultation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processStartOrJoinConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    lockConsultationRoomRequest(body: LockConsultationRoomRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/lock';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLockConsultationRoomRequest(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLockConsultationRoomRequest(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processLockConsultationRoomRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return Accepted
     */
    inviteToConsultation(body: InviteToConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/invite';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processInviteToConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processInviteToConsultation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processInviteToConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return Accepted
     */
    addEndpointToConsultation(body: AddEndpointConsultationRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/consultations/addendpoint';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddEndpointToConsultation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddEndpointToConsultation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processAddEndpointToConsultation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 202) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get all active conferences.
    This includes conferences that are in progress or paused.
    This includes conferences that are closed but the participants are still in consultation.
     * @return OK
     */
    getActiveConferences(): Observable<ConferenceForVhOfficerResponse[]> {
        let url_ = this.baseUrl + '/end-of-day/active-sessions';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetActiveConferences(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetActiveConferences(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceForVhOfficerResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceForVhOfficerResponse[]>;
                })
            );
    }

    protected processGetActiveConferences(response: HttpResponseBase): Observable<ConferenceForVhOfficerResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ConferenceForVhOfficerResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceForVhOfficerResponse[]>(null as any);
    }

    /**
     * @return OK
     */
    getVideoEndpointsForConference(conferenceId: string): Observable<VideoEndpointResponse[]> {
        let url_ = this.baseUrl + '/video-endpoints/{conferenceId}/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetVideoEndpointsForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetVideoEndpointsForConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<VideoEndpointResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<VideoEndpointResponse[]>;
                })
            );
    }

    protected processGetVideoEndpointsForConference(response: HttpResponseBase): Observable<VideoEndpointResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(VideoEndpointResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<VideoEndpointResponse[]>(null as any);
    }

    /**
     * @return OK
     */
    getHeartbeatConfigForParticipant(conferenceId: string, participantId: string): Observable<HeartbeatConfigurationResponse> {
        let url_ = this.baseUrl + '/heartbeat/conferences/{conferenceId}/GetHeartbeatConfigForParticipant/{participantId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHeartbeatConfigForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHeartbeatConfigForParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HeartbeatConfigurationResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HeartbeatConfigurationResponse>;
                })
            );
    }

    protected processGetHeartbeatConfigForParticipant(response: HttpResponseBase): Observable<HeartbeatConfigurationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = HeartbeatConfigurationResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HeartbeatConfigurationResponse>(null as any);
    }

    /**
     * Get all the instant messages for a conference for a participant
     * @param conferenceId Id of the conference
     * @param participantId the participant in the conference
     * @return OK
     */
    getConferenceInstantMessageHistoryForParticipant(conferenceId: string, participantId: string): Observable<ChatResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/participant/{participantId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetConferenceInstantMessageHistoryForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetConferenceInstantMessageHistoryForParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ChatResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ChatResponse[]>;
                })
            );
    }

    protected processGetConferenceInstantMessageHistoryForParticipant(response: HttpResponseBase): Observable<ChatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ChatResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ChatResponse[]>(null as any);
    }

    /**
     * Get number of unread messages for vho
     * @param conferenceId Id of the conference
     * @return OK
     */
    getNumberOfUnreadAdminMessagesForConference(conferenceId: string): Observable<UnreadInstantMessageConferenceCountResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/unread/vho';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetNumberOfUnreadAdminMessagesForConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetNumberOfUnreadAdminMessagesForConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UnreadInstantMessageConferenceCountResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UnreadInstantMessageConferenceCountResponse>;
                })
            );
    }

    protected processGetNumberOfUnreadAdminMessagesForConference(
        response: HttpResponseBase
    ): Observable<UnreadInstantMessageConferenceCountResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UnreadInstantMessageConferenceCountResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UnreadInstantMessageConferenceCountResponse>(null as any);
    }

    /**
     * Get number of unread messages for a participant
     * @param conferenceId Id of the conference
     * @param participantId the participant in the conference
     * @return OK
     */
    getNumberOfUnreadAdminMessagesForConferenceByParticipant(
        conferenceId: string,
        participantId: string
    ): Observable<UnreadAdminMessageResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/instantmessages/unread/participant/{participantId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UnreadAdminMessageResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UnreadAdminMessageResponse>;
                })
            );
    }

    protected processGetNumberOfUnreadAdminMessagesForConferenceByParticipant(
        response: HttpResponseBase
    ): Observable<UnreadAdminMessageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UnreadAdminMessageResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UnreadAdminMessageResponse>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    addMediaEventToConference(conferenceId: string, body: AddMediaEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/mediaevents';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddMediaEventToConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddMediaEventToConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processAddMediaEventToConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    addSelfTestFailureEventToConference(conferenceId: string, body: AddSelfTestFailureEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/selftestfailureevents';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAddSelfTestFailureEventToConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAddSelfTestFailureEventToConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processAddSelfTestFailureEventToConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Update the participant status for a conference
     * @param conferenceId The conference ID
     * @param body (optional) The status change
     * @return No Content
     */
    updateParticipantStatus(conferenceId: string, body: UpdateParticipantStatusEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participantstatus';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateParticipantStatus(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateParticipantStatus(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processUpdateParticipantStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get the heartbeat data for a participant
     * @param conferenceId The ID of a conference
     * @param participantId The ID of the participant
     * @return OK
     */
    getHeartbeatDataForParticipant(conferenceId: string, participantId: string): Observable<ParticipantHeartbeatResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participant/{participantId}/heartbeatrecent';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetHeartbeatDataForParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetHeartbeatDataForParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ParticipantHeartbeatResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ParticipantHeartbeatResponse[]>;
                })
            );
    }

    protected processGetHeartbeatDataForParticipant(response: HttpResponseBase): Observable<ParticipantHeartbeatResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantHeartbeatResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantHeartbeatResponse[]>(null as any);
    }

    /**
     * @param conferenceId The ID of a conference
     * @param participantId The ID of the participant
     * @param body (optional) Payload including the new display name
     * @return No Content
     */
    updateParticipantDisplayName(
        conferenceId: string,
        participantId: string,
        body: UpdateParticipantDisplayNameRequest | undefined
    ): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants/{participantId}/participantDisplayName';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateParticipantDisplayName(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateParticipantDisplayName(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processUpdateParticipantDisplayName(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get the participant details of a conference by id for VH officer
     * @param conferenceId The unique id of the conference
     * @return OK
     */
    getParticipantsWithContactDetailsByConferenceId(conferenceId: string): Observable<ParticipantContactDetailsResponseVho[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/vhofficer/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetParticipantsWithContactDetailsByConferenceId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetParticipantsWithContactDetailsByConferenceId(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ParticipantContactDetailsResponseVho[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ParticipantContactDetailsResponseVho[]>;
                })
            );
    }

    protected processGetParticipantsWithContactDetailsByConferenceId(
        response: HttpResponseBase
    ): Observable<ParticipantContactDetailsResponseVho[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantContactDetailsResponseVho.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantContactDetailsResponseVho[]>(null as any);
    }

    /**
     * Get participants for a conference
     * @return OK
     */
    getParticipantsByConferenceId(conferenceId: string): Observable<ParticipantResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetParticipantsByConferenceId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetParticipantsByConferenceId(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ParticipantResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ParticipantResponse[]>;
                })
            );
    }

    protected processGetParticipantsByConferenceId(response: HttpResponseBase): Observable<ParticipantResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(ParticipantResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ParticipantResponse[]>(null as any);
    }

    /**
     * Get Participant details for the user logged in
     * @return OK
     */
    getCurrentParticipant(conferenceId: string): Observable<LoggedParticipantResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/currentparticipant';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCurrentParticipant(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCurrentParticipant(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<LoggedParticipantResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<LoggedParticipantResponse>;
                })
            );
    }

    protected processGetCurrentParticipant(response: HttpResponseBase): Observable<LoggedParticipantResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = LoggedParticipantResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<LoggedParticipantResponse>(null as any);
    }

    /**
     * Join a conference as a staff member
     * @return OK
     */
    staffMemberJoinConference(conferenceId: string): Observable<ConferenceResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/joinConference';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processStaffMemberJoinConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processStaffMemberJoinConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ConferenceResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ConferenceResponse>;
                })
            );
    }

    protected processStaffMemberJoinConference(response: HttpResponseBase): Observable<ConferenceResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = ConferenceResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<ConferenceResponse>(null as any);
    }

    /**
     * Removes a participant from a conference  
    errors.
     * @return No Content
     */
    deleteParticipantFromConference(conferenceId: string, participantId: string): Observable<void> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/participants/{participantId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('delete', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteParticipantFromConference(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteParticipantFromConference(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processDeleteParticipantFromConference(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ValidationProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get profile for logged in user
     * @return OK
     */
    getUserProfile(): Observable<UserProfileResponse> {
        let url_ = this.baseUrl + '/profile';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUserProfile(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUserProfile(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserProfileResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserProfileResponse>;
                })
            );
    }

    protected processGetUserProfile(response: HttpResponseBase): Observable<UserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UserProfileResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UserProfileResponse>(null as any);
    }

    /**
     * Get profile for username
     * @param username (optional)
     * @return OK
     */
    getProfileByUsername(username: string | undefined): Observable<UserProfileResponse> {
        let url_ = this.baseUrl + '/profile/query?';
        if (username === null) throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined) url_ += 'username=' + encodeURIComponent('' + username) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetProfileByUsername(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetProfileByUsername(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserProfileResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserProfileResponse>;
                })
            );
    }

    protected processGetProfileByUsername(response: HttpResponseBase): Observable<UserProfileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = UserProfileResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<UserProfileResponse>(null as any);
    }

    /**
     * @return OK
     */
    getQuickLinkParticipantRoles(): Observable<Role[]> {
        let url_ = this.baseUrl + '/quickjoin/GetQuickLinkParticipantRoles';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetQuickLinkParticipantRoles(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetQuickLinkParticipantRoles(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<Role[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<Role[]>;
                })
            );
    }

    protected processGetQuickLinkParticipantRoles(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(item);
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<Role[]>(null as any);
    }

    /**
     * @return OK
     */
    validateQuickLink(hearingId: string): Observable<boolean> {
        let url_ = this.baseUrl + '/quickjoin/ValidateQuickLink/{hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processValidateQuickLink(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processValidateQuickLink(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<boolean>;
                        }
                    } else return _observableThrow(response_) as any as Observable<boolean>;
                })
            );
    }

    protected processValidateQuickLink(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;

                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * joinConferenceAsAQuickLinkUser
     * @param body (optional)
     * @return OK
     */
    joinConferenceAsAQuickLinkUser(
        hearingId: string,
        body: QuickLinkParticipantJoinRequest | undefined
    ): Observable<QuickLinkParticipantJoinResponse> {
        let url_ = this.baseUrl + '/quickjoin/joinConferenceAsAQuickLinkUser/${hearingId}';
        if (hearingId === undefined || hearingId === null) throw new Error("The parameter 'hearingId' must be defined.");
        url_ = url_.replace('{hearingId}', encodeURIComponent('' + hearingId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processJoinConferenceAsAQuickLinkUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processJoinConferenceAsAQuickLinkUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<QuickLinkParticipantJoinResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<QuickLinkParticipantJoinResponse>;
                })
            );
    }

    protected processJoinConferenceAsAQuickLinkUser(response: HttpResponseBase): Observable<QuickLinkParticipantJoinResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = QuickLinkParticipantJoinResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<QuickLinkParticipantJoinResponse>(null as any);
    }

    /**
     * isQuickLinkParticipantAuthorised
     * @return OK
     */
    isQuickLinkParticipantAuthorised(): Observable<void> {
        let url_ = this.baseUrl + '/quickjoin/isQuickLinkParticipantAuthorised';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({})
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processIsQuickLinkParticipantAuthorised(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processIsQuickLinkParticipantAuthorised(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processIsQuickLinkParticipantAuthorised(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result403: any = null;
                    let resultData403 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result403 = ProblemDetails.fromJS(resultData403);
                    return throwException('Forbidden', status, _responseText, _headers, result403);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get available interpreter languages
     * @return OK
     */
    getAvailableInterpreterLanguages(): Observable<InterpreterLanguageResponse[]> {
        let url_ = this.baseUrl + '/api/reference-data/interpreter-languages';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetAvailableInterpreterLanguages(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetAvailableInterpreterLanguages(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<InterpreterLanguageResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<InterpreterLanguageResponse[]>;
                })
            );
    }

    protected processGetAvailableInterpreterLanguages(response: HttpResponseBase): Observable<InterpreterLanguageResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(InterpreterLanguageResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<InterpreterLanguageResponse[]>(null as any);
    }

    /**
     * Get the Pexip self test node.
     * @return OK
     */
    getPexipConfig(): Observable<SelfTestPexipResponse> {
        let url_ = this.baseUrl + '/selftest';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetPexipConfig(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetPexipConfig(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<SelfTestPexipResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<SelfTestPexipResponse>;
                })
            );
    }

    protected processGetPexipConfig(response: HttpResponseBase): Observable<SelfTestPexipResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = SelfTestPexipResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<SelfTestPexipResponse>(null as any);
    }

    /**
     * Check if a user has completed a test call at least once today
     * @return OK
     */
    checkUserCompletedATestToday(): Observable<boolean> {
        let url_ = this.baseUrl + '/selftest/today';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCheckUserCompletedATestToday(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCheckUserCompletedATestToday(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<boolean>;
                        }
                    } else return _observableThrow(response_) as any as Observable<boolean>;
                })
            );
    }

    protected processCheckUserCompletedATestToday(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = resultData200 !== undefined ? resultData200 : <any>null;

                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @return OK
     */
    getTestCallResult(conferenceId: string, participantId: string): Observable<TestCallScoreResponse> {
        let url_ = this.baseUrl + '/selftest/conferences/{conferenceId}/participants/{participantId}/selftestresult';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTestCallResult(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTestCallResult(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TestCallScoreResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TestCallScoreResponse>;
                })
            );
    }

    protected processGetTestCallResult(response: HttpResponseBase): Observable<TestCallScoreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TestCallScoreResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TestCallScoreResponse>(null as any);
    }

    /**
     * @return OK
     */
    getIndependentTestCallResult(participantId: string): Observable<TestCallScoreResponse> {
        let url_ = this.baseUrl + '/selftest/independentselftestresult/{participantId}';
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetIndependentTestCallResult(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetIndependentTestCallResult(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TestCallScoreResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TestCallScoreResponse>;
                })
            );
    }

    protected processGetIndependentTestCallResult(response: HttpResponseBase): Observable<TestCallScoreResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TestCallScoreResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TestCallScoreResponse>(null as any);
    }

    /**
     * @return OK
     */
    getTasks(conferenceId: string): Observable<TaskResponse[]> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/tasks';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTasks(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTasks(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TaskResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TaskResponse[]>;
                })
            );
    }

    protected processGetTasks(response: HttpResponseBase): Observable<TaskResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(TaskResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TaskResponse[]>(null as any);
    }

    /**
     * Update existing tasks
     * @param conferenceId The id of the conference to update
     * @param taskId The id of the task to update
     * @return OK
     */
    completeTask(conferenceId: string, taskId: number): Observable<TaskResponse> {
        let url_ = this.baseUrl + '/conferences/{conferenceId}/tasks/{taskId}';
        if (conferenceId === undefined || conferenceId === null) throw new Error("The parameter 'conferenceId' must be defined.");
        url_ = url_.replace('{conferenceId}', encodeURIComponent('' + conferenceId));
        if (taskId === undefined || taskId === null) throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace('{taskId}', encodeURIComponent('' + taskId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('patch', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCompleteTask(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCompleteTask(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TaskResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TaskResponse>;
                })
            );
    }

    protected processCompleteTask(response: HttpResponseBase): Observable<TaskResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TaskResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TaskResponse>(null as any);
    }

    /**
     * @return OK
     */
    getSelfTestToken(participantId: string): Observable<TokenResponse> {
        let url_ = this.baseUrl + '/participants/{participantId}/selftesttoken';
        if (participantId === undefined || participantId === null) throw new Error("The parameter 'participantId' must be defined.");
        url_ = url_.replace('{participantId}', encodeURIComponent('' + participantId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetSelfTestToken(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetSelfTestToken(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TokenResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TokenResponse>;
                })
            );
    }

    protected processGetSelfTestToken(response: HttpResponseBase): Observable<TokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result200 = TokenResponse.fromJS(resultData200);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = ProblemDetails.fromJS(resultData400);
                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<TokenResponse>(null as any);
    }

    /**
     * Get CSOS
     * @return OK
     */
    getCSOs(): Observable<JusticeUserResponse[]> {
        let url_ = this.baseUrl + '/api/accounts/csos';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetCSOs(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetCSOs(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<JusticeUserResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<JusticeUserResponse[]>;
                })
            );
    }

    protected processGetCSOs(response: HttpResponseBase): Observable<JusticeUserResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(JusticeUserResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<JusticeUserResponse[]>(null as any);
    }

    /**
     * Get available courts
     * @return OK
     */
    getVenues(): Observable<HearingVenueResponse[]> {
        let url_ = this.baseUrl + '/hearing-venues/courts';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                Accept: 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('get', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetVenues(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetVenues(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<HearingVenueResponse[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<HearingVenueResponse[]>;
                })
            );
    }

    protected processGetVenues(response: HttpResponseBase): Observable<HearingVenueResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result200: any = null;
                    let resultData200 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    if (Array.isArray(resultData200)) {
                        result200 = [] as any;
                        for (let item of resultData200) result200!.push(HearingVenueResponse.fromJS(item));
                    } else {
                        result200 = <any>null;
                    }
                    return _observableOf(result200);
                })
            );
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result404: any = null;
                    let resultData404 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result404 = ProblemDetails.fromJS(resultData404);
                    return throwException('Not Found', status, _responseText, _headers, result404);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<HearingVenueResponse[]>(null as any);
    }

    /**
     * @param body (optional)
     * @return No Content
     */
    sendEvent(body: ConferenceEventRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + '/callback';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            headers: new HttpHeaders({
                'Content-Type': 'application/json'
            })
        };

        return _observableFrom(this.transformOptions(options_))
            .pipe(
                _observableMergeMap(transformedOptions_ => {
                    return this.http.request('post', url_, transformedOptions_);
                })
            )
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSendEvent(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSendEvent(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<void>;
                        }
                    } else return _observableThrow(response_) as any as Observable<void>;
                })
            );
    }

    protected processSendEvent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                  ? (response as any).error
                  : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result500: any = null;
                    let resultData500 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result500 = resultData500 !== undefined ? resultData500 : <any>null;

                    return throwException('Internal Server Error', status, _responseText, _headers, result500);
                })
            );
        } else if (status === 504) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result504: any = null;
                    let resultData504 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result504 = resultData504 !== undefined ? resultData504 : <any>null;

                    return throwException('Gateway Timeout', status, _responseText, _headers, result504);
                })
            );
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return _observableOf<void>(null as any);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    let result400: any = null;
                    let resultData400 = _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
                    result400 = resultData400 !== undefined ? resultData400 : <any>null;

                    return throwException('Bad Request', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('Unauthorized', status, _responseText, _headers);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap(_responseText => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf<void>(null as any);
    }
}

export enum JusticeUserRole {
    CaseAdmin = 'CaseAdmin',
    Vho = 'Vho',
    Clerk = 'Clerk',
    Judge = 'Judge',
    Individual = 'Individual',
    Representative = 'Representative',
    JudicialOfficeHolder = 'JudicialOfficeHolder',
    StaffMember = 'StaffMember',
    VhTeamLead = 'VhTeamLead'
}

export class HearingVenueResponse implements IHearingVenueResponse {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;

    constructor(data?: IHearingVenueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.code = _data['code'];
        }
    }

    static fromJS(data: any): HearingVenueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HearingVenueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['code'] = this.code;
        return data;
    }
}

export interface IHearingVenueResponse {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
}

export class JusticeUserResponse implements IJusticeUserResponse {
    id?: string;
    first_name?: string | undefined;
    lastname?: string | undefined;
    contact_email?: string | undefined;
    username?: string | undefined;
    telephone?: string | undefined;
    user_roles?: JusticeUserRole[] | undefined;
    is_vh_team_leader?: boolean;
    created_by?: string | undefined;
    full_name?: string | undefined;
    deleted?: boolean;

    constructor(data?: IJusticeUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.first_name = _data['first_name'];
            this.lastname = _data['lastname'];
            this.contact_email = _data['contact_email'];
            this.username = _data['username'];
            this.telephone = _data['telephone'];
            if (Array.isArray(_data['user_roles'])) {
                this.user_roles = [] as any;
                for (let item of _data['user_roles']) this.user_roles!.push(item);
            }
            this.is_vh_team_leader = _data['is_vh_team_leader'];
            this.created_by = _data['created_by'];
            this.full_name = _data['full_name'];
            this.deleted = _data['deleted'];
        }
    }

    static fromJS(data: any): JusticeUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new JusticeUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['first_name'] = this.first_name;
        data['lastname'] = this.lastname;
        data['contact_email'] = this.contact_email;
        data['username'] = this.username;
        data['telephone'] = this.telephone;
        if (Array.isArray(this.user_roles)) {
            data['user_roles'] = [];
            for (let item of this.user_roles) data['user_roles'].push(item);
        }
        data['is_vh_team_leader'] = this.is_vh_team_leader;
        data['created_by'] = this.created_by;
        data['full_name'] = this.full_name;
        data['deleted'] = this.deleted;
        return data;
    }
}

export interface IJusticeUserResponse {
    id?: string;
    first_name?: string | undefined;
    lastname?: string | undefined;
    contact_email?: string | undefined;
    username?: string | undefined;
    telephone?: string | undefined;
    user_roles?: JusticeUserRole[] | undefined;
    is_vh_team_leader?: boolean;
    created_by?: string | undefined;
    full_name?: string | undefined;
    deleted?: boolean;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property)) this[property] = _data[property];
            }
            this.type = _data['type'];
            this.title = _data['title'];
            this.status = _data['status'];
            this.detail = _data['detail'];
            this.instance = _data['instance'];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property)) data[property] = this[property];
        }
        data['type'] = this.type;
        data['title'] = this.title;
        data['status'] = this.status;
        data['detail'] = this.detail;
        data['instance'] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ValidationProblemDetails implements IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[] } | undefined;

    [key: string]: any;

    constructor(data?: IValidationProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property)) this[property] = _data[property];
            }
            this.type = _data['type'];
            this.title = _data['title'];
            this.status = _data['status'];
            this.detail = _data['detail'];
            this.instance = _data['instance'];
            if (_data['errors']) {
                this.errors = {} as any;
                for (let key in _data['errors']) {
                    if (_data['errors'].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data['errors'][key] !== undefined ? _data['errors'][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property)) data[property] = this[property];
        }
        data['type'] = this.type;
        data['title'] = this.title;
        data['status'] = this.status;
        data['detail'] = this.detail;
        data['instance'] = this.instance;
        if (this.errors) {
            data['errors'] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key)) (<any>data['errors'])[key] = (<any>this.errors)[key];
            }
        }
        return data;
    }
}

export interface IValidationProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    errors?: { [key: string]: string[] } | undefined;

    [key: string]: any;
}

export enum ConferenceRole {
    Host = 'Host',
    Guest = 'Guest'
}

export enum EventType {
    None = 'None',
    Joined = 'Joined',
    Disconnected = 'Disconnected',
    Transfer = 'Transfer',
    Help = 'Help',
    Pause = 'Pause',
    Close = 'Close',
    Leave = 'Leave',
    Consultation = 'Consultation',
    MediaPermissionDenied = 'MediaPermissionDenied',
    ParticipantJoining = 'ParticipantJoining',
    SelfTestFailed = 'SelfTestFailed',
    Suspend = 'Suspend',
    VhoCall = 'VhoCall',
    ParticipantNotSignedIn = 'ParticipantNotSignedIn',
    Start = 'Start',
    CountdownFinished = 'CountdownFinished',
    EndpointJoined = 'EndpointJoined',
    EndpointDisconnected = 'EndpointDisconnected',
    EndpointTransfer = 'EndpointTransfer',
    ConnectingToEventHub = 'ConnectingToEventHub',
    SelectingMedia = 'SelectingMedia',
    ConnectingToConference = 'ConnectingToConference',
    RoomParticipantJoined = 'RoomParticipantJoined',
    RoomParticipantDisconnected = 'RoomParticipantDisconnected',
    RoomParticipantTransfer = 'RoomParticipantTransfer',
    TelephoneJoined = 'TelephoneJoined',
    TelephoneDisconnected = 'TelephoneDisconnected',
    TelephoneTransfer = 'TelephoneTransfer',
    RecordingConnectionFailed = 'RecordingConnectionFailed'
}

export enum TaskStatus {
    ToDo = 'ToDo',
    Done = 'Done'
}

export enum TaskType {
    Hearing = 'Hearing',
    Judge = 'Judge',
    Participant = 'Participant'
}

export enum TestScore {
    Unknown = 'Unknown',
    Good = 'Good',
    Okay = 'Okay',
    Bad = 'Bad'
}

export class ConferenceEventRequest implements IConferenceEventRequest {
    event_id?: string | undefined;
    event_type?: EventType;
    time_stamp_utc?: Date;
    conference_id?: string | undefined;
    participant_id?: string | undefined;
    participant_room_id?: string | undefined;
    transfer_from?: string | undefined;
    transfer_to?: string | undefined;
    reason?: string | undefined;
    phone?: string | undefined;
    conference_role?: ConferenceRole;

    constructor(data?: IConferenceEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_id = _data['event_id'];
            this.event_type = _data['event_type'];
            this.time_stamp_utc = _data['time_stamp_utc'] ? new Date(_data['time_stamp_utc'].toString()) : <any>undefined;
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
            this.participant_room_id = _data['participant_room_id'];
            this.transfer_from = _data['transfer_from'];
            this.transfer_to = _data['transfer_to'];
            this.reason = _data['reason'];
            this.phone = _data['phone'];
            this.conference_role = _data['conference_role'];
        }
    }

    static fromJS(data: any): ConferenceEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_id'] = this.event_id;
        data['event_type'] = this.event_type;
        data['time_stamp_utc'] = this.time_stamp_utc ? this.time_stamp_utc.toISOString() : <any>undefined;
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        data['participant_room_id'] = this.participant_room_id;
        data['transfer_from'] = this.transfer_from;
        data['transfer_to'] = this.transfer_to;
        data['reason'] = this.reason;
        data['phone'] = this.phone;
        data['conference_role'] = this.conference_role;
        return data;
    }
}

export interface IConferenceEventRequest {
    event_id?: string | undefined;
    event_type?: EventType;
    time_stamp_utc?: Date;
    conference_id?: string | undefined;
    participant_id?: string | undefined;
    participant_room_id?: string | undefined;
    transfer_from?: string | undefined;
    transfer_to?: string | undefined;
    reason?: string | undefined;
    phone?: string | undefined;
    conference_role?: ConferenceRole;
}

export enum HearingLayout {
    Dynamic = 'Dynamic',
    OnePlus7 = 'OnePlus7',
    TwoPlus21 = 'TwoPlus21',
    NineEqual = 'NineEqual',
    SixteenEqual = 'SixteenEqual',
    TwentyFiveEqual = 'TwentyFiveEqual'
}

export class ParticipantHeartbeatResponse implements IParticipantHeartbeatResponse {
    recent_packet_loss?: number;
    browser_name?: string | undefined;
    browser_version?: string | undefined;
    operating_system?: string | undefined;
    operating_system_version?: string | undefined;
    timestamp?: Date;

    constructor(data?: IParticipantHeartbeatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recent_packet_loss = _data['recent_packet_loss'];
            this.browser_name = _data['browser_name'];
            this.browser_version = _data['browser_version'];
            this.operating_system = _data['operating_system'];
            this.operating_system_version = _data['operating_system_version'];
            this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ParticipantHeartbeatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantHeartbeatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['recent_packet_loss'] = this.recent_packet_loss;
        data['browser_name'] = this.browser_name;
        data['browser_version'] = this.browser_version;
        data['operating_system'] = this.operating_system;
        data['operating_system_version'] = this.operating_system_version;
        data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IParticipantHeartbeatResponse {
    recent_packet_loss?: number;
    browser_name?: string | undefined;
    browser_version?: string | undefined;
    operating_system?: string | undefined;
    operating_system_version?: string | undefined;
    timestamp?: Date;
}

export class TaskResponse implements ITaskResponse {
    id?: number;
    origin_id?: string;
    body?: string | undefined;
    type?: TaskType;
    status?: TaskStatus;
    created?: Date;
    updated?: Date | undefined;
    updated_by?: string | undefined;

    constructor(data?: ITaskResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.origin_id = _data['origin_id'];
            this.body = _data['body'];
            this.type = _data['type'];
            this.status = _data['status'];
            this.created = _data['created'] ? new Date(_data['created'].toString()) : <any>undefined;
            this.updated = _data['updated'] ? new Date(_data['updated'].toString()) : <any>undefined;
            this.updated_by = _data['updated_by'];
        }
    }

    static fromJS(data: any): TaskResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['origin_id'] = this.origin_id;
        data['body'] = this.body;
        data['type'] = this.type;
        data['status'] = this.status;
        data['created'] = this.created ? this.created.toISOString() : <any>undefined;
        data['updated'] = this.updated ? this.updated.toISOString() : <any>undefined;
        data['updated_by'] = this.updated_by;
        return data;
    }
}

export interface ITaskResponse {
    id?: number;
    origin_id?: string;
    body?: string | undefined;
    type?: TaskType;
    status?: TaskStatus;
    created?: Date;
    updated?: Date | undefined;
    updated_by?: string | undefined;
}

export class TestCallScoreResponse implements ITestCallScoreResponse {
    score?: TestScore;
    passed?: boolean;

    constructor(data?: ITestCallScoreResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.score = _data['score'];
            this.passed = _data['passed'];
        }
    }

    static fromJS(data: any): TestCallScoreResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestCallScoreResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['score'] = this.score;
        data['passed'] = this.passed;
        return data;
    }
}

export interface ITestCallScoreResponse {
    score?: TestScore;
    passed?: boolean;
}

export enum Supplier {
    Vodafone = 'Vodafone',
    Stub = 'Stub'
}

export enum ConferenceStatus {
    NotStarted = 'NotStarted',
    InSession = 'InSession',
    Paused = 'Paused',
    Suspended = 'Suspended',
    Closed = 'Closed'
}

export class ConferenceVideoControlStatuses implements IConferenceVideoControlStatuses {
    participant_id_to_video_control_status_map?: { [key: string]: VideoControlStatus } | undefined;

    constructor(data?: IConferenceVideoControlStatuses) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data['participant_id_to_video_control_status_map']) {
                this.participant_id_to_video_control_status_map = {} as any;
                for (let key in _data['participant_id_to_video_control_status_map']) {
                    if (_data['participant_id_to_video_control_status_map'].hasOwnProperty(key))
                        (<any>this.participant_id_to_video_control_status_map)![key] = _data['participant_id_to_video_control_status_map'][
                            key
                        ]
                            ? VideoControlStatus.fromJS(_data['participant_id_to_video_control_status_map'][key])
                            : new VideoControlStatus();
                }
            }
        }
    }

    static fromJS(data: any): ConferenceVideoControlStatuses {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceVideoControlStatuses();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.participant_id_to_video_control_status_map) {
            data['participant_id_to_video_control_status_map'] = {};
            for (let key in this.participant_id_to_video_control_status_map) {
                if (this.participant_id_to_video_control_status_map.hasOwnProperty(key))
                    (<any>data['participant_id_to_video_control_status_map'])[key] = this.participant_id_to_video_control_status_map[key]
                        ? this.participant_id_to_video_control_status_map[key].toJSON()
                        : <any>undefined;
            }
        }
        return data;
    }
}

export interface IConferenceVideoControlStatuses {
    participant_id_to_video_control_status_map?: { [key: string]: VideoControlStatus } | undefined;
}

export enum ConsultationAnswer {
    None = 'None',
    Accepted = 'Accepted',
    Rejected = 'Rejected',
    Failed = 'Failed',
    Transferring = 'Transferring'
}

export enum EndpointStatus {
    NotYetJoined = 'NotYetJoined',
    Connected = 'Connected',
    Disconnected = 'Disconnected',
    InConsultation = 'InConsultation',
    InHearing = 'InHearing'
}

export enum LinkType {
    Interpreter = 'Interpreter'
}

export enum ParticipantStatus {
    None = 'None',
    NotSignedIn = 'NotSignedIn',
    UnableToJoin = 'UnableToJoin',
    Joining = 'Joining',
    Available = 'Available',
    InHearing = 'InHearing',
    InConsultation = 'InConsultation',
    Disconnected = 'Disconnected'
}

export enum Role {
    None = 'None',
    CaseAdmin = 'CaseAdmin',
    VideoHearingsOfficer = 'VideoHearingsOfficer',
    HearingFacilitationSupport = 'HearingFacilitationSupport',
    Judge = 'Judge',
    Individual = 'Individual',
    Representative = 'Representative',
    JudicialOfficeHolder = 'JudicialOfficeHolder',
    QuickLinkParticipant = 'QuickLinkParticipant',
    QuickLinkObserver = 'QuickLinkObserver',
    StaffMember = 'StaffMember',
    Administrator = 'Administrator'
}

export class VideoControlStatus implements IVideoControlStatus {
    is_remote_muted?: boolean;
    is_hand_raised?: boolean;
    is_spotlighted?: boolean;
    is_local_audio_muted?: boolean;
    is_local_video_muted?: boolean;

    constructor(data?: IVideoControlStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.is_remote_muted = _data['is_remote_muted'];
            this.is_hand_raised = _data['is_hand_raised'];
            this.is_spotlighted = _data['is_spotlighted'];
            this.is_local_audio_muted = _data['is_local_audio_muted'];
            this.is_local_video_muted = _data['is_local_video_muted'];
        }
    }

    static fromJS(data: any): VideoControlStatus {
        data = typeof data === 'object' ? data : {};
        let result = new VideoControlStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['is_remote_muted'] = this.is_remote_muted;
        data['is_hand_raised'] = this.is_hand_raised;
        data['is_spotlighted'] = this.is_spotlighted;
        data['is_local_audio_muted'] = this.is_local_audio_muted;
        data['is_local_video_muted'] = this.is_local_video_muted;
        return data;
    }
}

export interface IVideoControlStatus {
    is_remote_muted?: boolean;
    is_hand_raised?: boolean;
    is_spotlighted?: boolean;
    is_local_audio_muted?: boolean;
    is_local_video_muted?: boolean;
}

export enum VirtualCourtRoomType {
    JudgeJOH = 'JudgeJOH',
    Participant = 'Participant'
}

export class AddEndpointConsultationRequest implements IAddEndpointConsultationRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The id of the endpoint you would like to invite into the consultation */
    endpoint_id?: string;

    constructor(data?: IAddEndpointConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.room_label = _data['room_label'];
            this.endpoint_id = _data['endpoint_id'];
        }
    }

    static fromJS(data: any): AddEndpointConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddEndpointConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['room_label'] = this.room_label;
        data['endpoint_id'] = this.endpoint_id;
        return data;
    }
}

export interface IAddEndpointConsultationRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The id of the endpoint you would like to invite into the consultation */
    endpoint_id?: string;
}

export class AddMediaEventRequest implements IAddMediaEventRequest {
    event_type?: EventType;

    constructor(data?: IAddMediaEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_type = _data['event_type'];
        }
    }

    static fromJS(data: any): AddMediaEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddMediaEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        return data;
    }
}

export interface IAddMediaEventRequest {
    event_type?: EventType;
}

export class AddSelfTestFailureEventRequest implements IAddSelfTestFailureEventRequest {
    self_test_failure_reason?: SelfTestFailureReason;

    constructor(data?: IAddSelfTestFailureEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.self_test_failure_reason = _data['self_test_failure_reason'];
        }
    }

    static fromJS(data: any): AddSelfTestFailureEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddSelfTestFailureEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['self_test_failure_reason'] = this.self_test_failure_reason;
        return data;
    }
}

export interface IAddSelfTestFailureEventRequest {
    self_test_failure_reason?: SelfTestFailureReason;
}

export class InviteToConsultationRequest implements IInviteToConsultationRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The id of the participant you would like to invite into the consultation */
    participant_id?: string;

    constructor(data?: IInviteToConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.room_label = _data['room_label'];
            this.participant_id = _data['participant_id'];
        }
    }

    static fromJS(data: any): InviteToConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InviteToConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['room_label'] = this.room_label;
        data['participant_id'] = this.participant_id;
        return data;
    }
}

export interface IInviteToConsultationRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The id of the participant you would like to invite into the consultation */
    participant_id?: string;
}

export class JoinPrivateConsultationRequest implements IJoinPrivateConsultationRequest {
    conference_id?: string;
    participant_id?: string;
    room_label?: string | undefined;

    constructor(data?: IJoinPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
            this.room_label = _data['room_label'];
        }
    }

    static fromJS(data: any): JoinPrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new JoinPrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        data['room_label'] = this.room_label;
        return data;
    }
}

export interface IJoinPrivateConsultationRequest {
    conference_id?: string;
    participant_id?: string;
    room_label?: string | undefined;
}

/** Leave a private consultation */
export class LeavePrivateConsultationRequest implements ILeavePrivateConsultationRequest {
    /** The id of the conference */
    conference_id?: string;
    /** The id of the participant */
    participant_id?: string;

    constructor(data?: ILeavePrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.participant_id = _data['participant_id'];
        }
    }

    static fromJS(data: any): LeavePrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LeavePrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['participant_id'] = this.participant_id;
        return data;
    }
}

/** Leave a private consultation */
export interface ILeavePrivateConsultationRequest {
    /** The id of the conference */
    conference_id?: string;
    /** The id of the participant */
    participant_id?: string;
}

export class LockConsultationRoomRequest implements ILockConsultationRoomRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The desired lock state of the room */
    lock?: boolean;

    constructor(data?: ILockConsultationRoomRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.conference_id = _data['conference_id'];
            this.room_label = _data['room_label'];
            this.lock = _data['lock'];
        }
    }

    static fromJS(data: any): LockConsultationRoomRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LockConsultationRoomRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['conference_id'] = this.conference_id;
        data['room_label'] = this.room_label;
        data['lock'] = this.lock;
        return data;
    }
}

export interface ILockConsultationRoomRequest {
    /** Conference ID */
    conference_id?: string;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
    /** The desired lock state of the room */
    lock?: boolean;
}

/** Raise or respond to a private consultation request */
export class PrivateConsultationRequest implements IPrivateConsultationRequest {
    /** ID unique to the request */
    invitation_id?: string;
    /** Conference ID */
    conference_id?: string;
    /** Id of participant requesting consultation */
    requested_by_id?: string;
    /** Id of participant requesting consultation with */
    requested_for_id?: string;
    answer?: ConsultationAnswer;
    /** The room to have a private consultation in */
    room_label?: string | undefined;

    constructor(data?: IPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invitation_id = _data['invitation_id'];
            this.conference_id = _data['conference_id'];
            this.requested_by_id = _data['requested_by_id'];
            this.requested_for_id = _data['requested_for_id'];
            this.answer = _data['answer'];
            this.room_label = _data['room_label'];
        }
    }

    static fromJS(data: any): PrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['invitation_id'] = this.invitation_id;
        data['conference_id'] = this.conference_id;
        data['requested_by_id'] = this.requested_by_id;
        data['requested_for_id'] = this.requested_for_id;
        data['answer'] = this.answer;
        data['room_label'] = this.room_label;
        return data;
    }
}

/** Raise or respond to a private consultation request */
export interface IPrivateConsultationRequest {
    /** ID unique to the request */
    invitation_id?: string;
    /** Conference ID */
    conference_id?: string;
    /** Id of participant requesting consultation */
    requested_by_id?: string;
    /** Id of participant requesting consultation with */
    requested_for_id?: string;
    answer?: ConsultationAnswer;
    /** The room to have a private consultation in */
    room_label?: string | undefined;
}

export class QuickLinkParticipantJoinRequest implements IQuickLinkParticipantJoinRequest {
    name?: string | undefined;
    role?: Role;

    constructor(data?: IQuickLinkParticipantJoinRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data['name'];
            this.role = _data['role'];
        }
    }

    static fromJS(data: any): QuickLinkParticipantJoinRequest {
        data = typeof data === 'object' ? data : {};
        let result = new QuickLinkParticipantJoinRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['name'] = this.name;
        data['role'] = this.role;
        return data;
    }
}

export interface IQuickLinkParticipantJoinRequest {
    name?: string | undefined;
    role?: Role;
}

export enum SelfTestFailureReason {
    Camera = 'Camera',
    Microphone = 'Microphone',
    Video = 'Video',
    BadScore = 'BadScore',
    IncompleteTest = 'IncompleteTest'
}

export class SetConferenceVideoControlStatusesRequest implements ISetConferenceVideoControlStatusesRequest {
    participant_id_to_video_control_status_map?:
        | { [key: string]: SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest }
        | undefined;

    constructor(data?: ISetConferenceVideoControlStatusesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data['participant_id_to_video_control_status_map']) {
                this.participant_id_to_video_control_status_map = {} as any;
                for (let key in _data['participant_id_to_video_control_status_map']) {
                    if (_data['participant_id_to_video_control_status_map'].hasOwnProperty(key))
                        (<any>this.participant_id_to_video_control_status_map)![key] = _data['participant_id_to_video_control_status_map'][
                            key
                        ]
                            ? SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest.fromJS(
                                  _data['participant_id_to_video_control_status_map'][key]
                              )
                            : new SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest();
                }
            }
        }
    }

    static fromJS(data: any): SetConferenceVideoControlStatusesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetConferenceVideoControlStatusesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.participant_id_to_video_control_status_map) {
            data['participant_id_to_video_control_status_map'] = {};
            for (let key in this.participant_id_to_video_control_status_map) {
                if (this.participant_id_to_video_control_status_map.hasOwnProperty(key))
                    (<any>data['participant_id_to_video_control_status_map'])[key] = this.participant_id_to_video_control_status_map[key]
                        ? this.participant_id_to_video_control_status_map[key].toJSON()
                        : <any>undefined;
            }
        }
        return data;
    }
}

export interface ISetConferenceVideoControlStatusesRequest {
    participant_id_to_video_control_status_map?:
        | { [key: string]: SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest }
        | undefined;
}

export class SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest
    implements ISetConferenceVideoControlStatusesRequest_VideoControlStatusRequest
{
    is_spotlighted?: boolean;
    is_local_audio_muted?: boolean;
    is_remote_muted?: boolean;
    is_hand_raised?: boolean;
    is_local_video_muted?: boolean;

    constructor(data?: ISetConferenceVideoControlStatusesRequest_VideoControlStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.is_spotlighted = _data['is_spotlighted'];
            this.is_local_audio_muted = _data['is_local_audio_muted'];
            this.is_remote_muted = _data['is_remote_muted'];
            this.is_hand_raised = _data['is_hand_raised'];
            this.is_local_video_muted = _data['is_local_video_muted'];
        }
    }

    static fromJS(data: any): SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetConferenceVideoControlStatusesRequest_VideoControlStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['is_spotlighted'] = this.is_spotlighted;
        data['is_local_audio_muted'] = this.is_local_audio_muted;
        data['is_remote_muted'] = this.is_remote_muted;
        data['is_hand_raised'] = this.is_hand_raised;
        data['is_local_video_muted'] = this.is_local_video_muted;
        return data;
    }
}

export interface ISetConferenceVideoControlStatusesRequest_VideoControlStatusRequest {
    is_spotlighted?: boolean;
    is_local_audio_muted?: boolean;
    is_remote_muted?: boolean;
    is_hand_raised?: boolean;
    is_local_video_muted?: boolean;
}

export class StartOrResumeVideoHearingRequest implements IStartOrResumeVideoHearingRequest {
    layout?: HearingLayout;

    constructor(data?: IStartOrResumeVideoHearingRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layout = _data['layout'];
        }
    }

    static fromJS(data: any): StartOrResumeVideoHearingRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartOrResumeVideoHearingRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['layout'] = this.layout;
        return data;
    }
}

export interface IStartOrResumeVideoHearingRequest {
    layout?: HearingLayout;
}

export class StartPrivateConsultationRequest implements IStartPrivateConsultationRequest {
    invite_participants?: string[] | undefined;
    invite_endpoints?: string[] | undefined;
    conference_id?: string;
    requested_by?: string;
    room_type?: VirtualCourtRoomType;

    constructor(data?: IStartPrivateConsultationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['invite_participants'])) {
                this.invite_participants = [] as any;
                for (let item of _data['invite_participants']) this.invite_participants!.push(item);
            }
            if (Array.isArray(_data['invite_endpoints'])) {
                this.invite_endpoints = [] as any;
                for (let item of _data['invite_endpoints']) this.invite_endpoints!.push(item);
            }
            this.conference_id = _data['conference_id'];
            this.requested_by = _data['requested_by'];
            this.room_type = _data['room_type'];
        }
    }

    static fromJS(data: any): StartPrivateConsultationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartPrivateConsultationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.invite_participants)) {
            data['invite_participants'] = [];
            for (let item of this.invite_participants) data['invite_participants'].push(item);
        }
        if (Array.isArray(this.invite_endpoints)) {
            data['invite_endpoints'] = [];
            for (let item of this.invite_endpoints) data['invite_endpoints'].push(item);
        }
        data['conference_id'] = this.conference_id;
        data['requested_by'] = this.requested_by;
        data['room_type'] = this.room_type;
        return data;
    }
}

export interface IStartPrivateConsultationRequest {
    invite_participants?: string[] | undefined;
    invite_endpoints?: string[] | undefined;
    conference_id?: string;
    requested_by?: string;
    room_type?: VirtualCourtRoomType;
}

export class UpdateParticipantDisplayNameRequest implements IUpdateParticipantDisplayNameRequest {
    /** Participant Display Name */
    display_name?: string | undefined;

    constructor(data?: IUpdateParticipantDisplayNameRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.display_name = _data['display_name'];
        }
    }

    static fromJS(data: any): UpdateParticipantDisplayNameRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantDisplayNameRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['display_name'] = this.display_name;
        return data;
    }
}

export interface IUpdateParticipantDisplayNameRequest {
    /** Participant Display Name */
    display_name?: string | undefined;
}

export class UpdateParticipantStatusEventRequest implements IUpdateParticipantStatusEventRequest {
    event_type?: EventType;

    constructor(data?: IUpdateParticipantStatusEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.event_type = _data['event_type'];
        }
    }

    static fromJS(data: any): UpdateParticipantStatusEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateParticipantStatusEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['event_type'] = this.event_type;
        return data;
    }
}

export interface IUpdateParticipantStatusEventRequest {
    event_type?: EventType;
}

export class ChatResponse implements IChatResponse {
    /** Message UUID */
    readonly id?: string;
    /** Username of sender */
    from?: string | undefined;
    /** Display name of sender */
    from_display_name?: string | undefined;
    /** Username of recipient */
    to?: string | undefined;
    /** Body of message */
    message?: string | undefined;
    /** Time of message */
    timestamp?: Date;
    /** Did the message originate from user logged in */
    is_user?: boolean;

    constructor(data?: IChatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data['id'];
            this.from = _data['from'];
            this.from_display_name = _data['from_display_name'];
            this.to = _data['to'];
            this.message = _data['message'];
            this.timestamp = _data['timestamp'] ? new Date(_data['timestamp'].toString()) : <any>undefined;
            this.is_user = _data['is_user'];
        }
    }

    static fromJS(data: any): ChatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['from'] = this.from;
        data['from_display_name'] = this.from_display_name;
        data['to'] = this.to;
        data['message'] = this.message;
        data['timestamp'] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data['is_user'] = this.is_user;
        return data;
    }
}

export interface IChatResponse {
    /** Message UUID */
    id?: string;
    /** Username of sender */
    from?: string | undefined;
    /** Display name of sender */
    from_display_name?: string | undefined;
    /** Username of recipient */
    to?: string | undefined;
    /** Body of message */
    message?: string | undefined;
    /** Time of message */
    timestamp?: Date;
    /** Did the message originate from user logged in */
    is_user?: boolean;
}

/** Configuration to initialise the UI application */
export class ClientSettingsResponse implements IClientSettingsResponse {
    /** The Application Insights Connection String */
    app_insights_connection_string?: string | undefined;
    /** The eventhub path */
    event_hub_path?: string | undefined;
    e_jud_idp_settings?: IdpSettingsResponse;
    dom1_idp_settings?: IdpSettingsResponse;
    vh_idp_settings?: IdpSettingsResponse;
    /** Enable video filters */
    enable_video_filters?: boolean;
    /** Enable Android support */
    enable_android_support?: boolean;
    /** Enable iOS mobile support */
    enable_ios_mobile_support?: boolean;
    /** Enable iOS tablet support */
    enable_ios_tablet_support?: boolean;
    /** Blur radius in pixels */
    blur_radius?: number;
    /** Launch Darkly Client for feature toggling */
    launch_darkly_client_id?: string | undefined;
    /** Configurations for the suppliers */
    supplier_configurations?: SupplierConfigurationResponse[] | undefined;
    /** The url to the Dynatrace Real User Monitoring javascript script. */
    dynatrace_rum_link?: string | undefined;

    constructor(data?: IClientSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.app_insights_connection_string = _data['app_insights_connection_string'];
            this.event_hub_path = _data['event_hub_path'];
            this.e_jud_idp_settings = _data['e_jud_idp_settings']
                ? IdpSettingsResponse.fromJS(_data['e_jud_idp_settings'])
                : <any>undefined;
            this.dom1_idp_settings = _data['dom1_idp_settings'] ? IdpSettingsResponse.fromJS(_data['dom1_idp_settings']) : <any>undefined;
            this.vh_idp_settings = _data['vh_idp_settings'] ? IdpSettingsResponse.fromJS(_data['vh_idp_settings']) : <any>undefined;
            this.enable_video_filters = _data['enable_video_filters'];
            this.enable_android_support = _data['enable_android_support'];
            this.enable_ios_mobile_support = _data['enable_ios_mobile_support'];
            this.enable_ios_tablet_support = _data['enable_ios_tablet_support'];
            this.blur_radius = _data['blur_radius'];
            this.launch_darkly_client_id = _data['launch_darkly_client_id'];
            if (Array.isArray(_data['supplier_configurations'])) {
                this.supplier_configurations = [] as any;
                for (let item of _data['supplier_configurations'])
                    this.supplier_configurations!.push(SupplierConfigurationResponse.fromJS(item));
            }
            this.dynatrace_rum_link = _data['dynatrace_rum_link'];
        }
    }

    static fromJS(data: any): ClientSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['app_insights_connection_string'] = this.app_insights_connection_string;
        data['event_hub_path'] = this.event_hub_path;
        data['e_jud_idp_settings'] = this.e_jud_idp_settings ? this.e_jud_idp_settings.toJSON() : <any>undefined;
        data['dom1_idp_settings'] = this.dom1_idp_settings ? this.dom1_idp_settings.toJSON() : <any>undefined;
        data['vh_idp_settings'] = this.vh_idp_settings ? this.vh_idp_settings.toJSON() : <any>undefined;
        data['enable_video_filters'] = this.enable_video_filters;
        data['enable_android_support'] = this.enable_android_support;
        data['enable_ios_mobile_support'] = this.enable_ios_mobile_support;
        data['enable_ios_tablet_support'] = this.enable_ios_tablet_support;
        data['blur_radius'] = this.blur_radius;
        data['launch_darkly_client_id'] = this.launch_darkly_client_id;
        if (Array.isArray(this.supplier_configurations)) {
            data['supplier_configurations'] = [];
            for (let item of this.supplier_configurations) data['supplier_configurations'].push(item.toJSON());
        }
        data['dynatrace_rum_link'] = this.dynatrace_rum_link;
        return data;
    }
}

/** Configuration to initialise the UI application */
export interface IClientSettingsResponse {
    /** The Application Insights Connection String */
    app_insights_connection_string?: string | undefined;
    /** The eventhub path */
    event_hub_path?: string | undefined;
    e_jud_idp_settings?: IdpSettingsResponse;
    dom1_idp_settings?: IdpSettingsResponse;
    vh_idp_settings?: IdpSettingsResponse;
    /** Enable video filters */
    enable_video_filters?: boolean;
    /** Enable Android support */
    enable_android_support?: boolean;
    /** Enable iOS mobile support */
    enable_ios_mobile_support?: boolean;
    /** Enable iOS tablet support */
    enable_ios_tablet_support?: boolean;
    /** Blur radius in pixels */
    blur_radius?: number;
    /** Launch Darkly Client for feature toggling */
    launch_darkly_client_id?: string | undefined;
    /** Configurations for the suppliers */
    supplier_configurations?: SupplierConfigurationResponse[] | undefined;
    /** The url to the Dynatrace Real User Monitoring javascript script. */
    dynatrace_rum_link?: string | undefined;
}

export class ConferenceForHostResponse implements IConferenceForHostResponse {
    /** Conference UUID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The scheduled duration in minutes */
    scheduled_duration?: number;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForHostResponse[] | undefined;
    /** The number of hearing endpoints */
    number_of_endpoints?: number;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;

    constructor(data?: IConferenceForHostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantForHostResponse.fromJS(item));
            }
            this.number_of_endpoints = _data['number_of_endpoints'];
            this.hearing_venue_is_scottish = _data['hearing_venue_is_scottish'];
        }
    }

    static fromJS(data: any): ConferenceForHostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForHostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['number_of_endpoints'] = this.number_of_endpoints;
        data['hearing_venue_is_scottish'] = this.hearing_venue_is_scottish;
        return data;
    }
}

export interface IConferenceForHostResponse {
    /** Conference UUID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The scheduled duration in minutes */
    scheduled_duration?: number;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForHostResponse[] | undefined;
    /** The number of hearing endpoints */
    number_of_endpoints?: number;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;
}

export class ConferenceForIndividualResponse implements IConferenceForIndividualResponse {
    /** Conference UUID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The conference closed datetime */
    closed_date_time?: Date | undefined;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;
    /** Flags true when waiting room is open to users */
    is_waiting_room_open?: boolean;

    constructor(data?: IConferenceForIndividualResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.hearing_venue_is_scottish = _data['hearing_venue_is_scottish'];
            this.is_waiting_room_open = _data['is_waiting_room_open'];
        }
    }

    static fromJS(data: any): ConferenceForIndividualResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForIndividualResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['hearing_venue_is_scottish'] = this.hearing_venue_is_scottish;
        data['is_waiting_room_open'] = this.is_waiting_room_open;
        return data;
    }
}

export interface IConferenceForIndividualResponse {
    /** Conference UUID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** The conference closed datetime */
    closed_date_time?: Date | undefined;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;
    /** Flags true when waiting room is open to users */
    is_waiting_room_open?: boolean;
}

export class ConferenceForVhOfficerResponse implements IConferenceForVhOfficerResponse {
    /** Conference ID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    /** The scheduled duration in minutes */
    scheduled_duration?: number;
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForUserResponse[] | undefined;
    /** The name of the hearing venue */
    hearing_venue_name?: string | undefined;
    /** Started date time as UTC */
    started_date_time?: Date | undefined;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The telephone Id of the conference */
    telephone_conference_id?: string | undefined;
    /** The telephone conference number to dial */
    telephone_conference_numbers?: string | undefined;
    /** Created date time as UTC */
    created_date_time?: Date | undefined;
    /** Hearing Id for the vh-booking database */
    hearing_ref_id?: string;
    /** Allocated Cso Full name */
    allocated_cso?: string | undefined;
    /** Allocated Cso Id */
    allocated_cso_id?: string | undefined;
    supplier?: Supplier;

    constructor(data?: IConferenceForVhOfficerResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.scheduled_duration = _data['scheduled_duration'];
            this.status = _data['status'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantForUserResponse.fromJS(item));
            }
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.started_date_time = _data['started_date_time'] ? new Date(_data['started_date_time'].toString()) : <any>undefined;
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.telephone_conference_id = _data['telephone_conference_id'];
            this.telephone_conference_numbers = _data['telephone_conference_numbers'];
            this.created_date_time = _data['created_date_time'] ? new Date(_data['created_date_time'].toString()) : <any>undefined;
            this.hearing_ref_id = _data['hearing_ref_id'];
            this.allocated_cso = _data['allocated_cso'];
            this.allocated_cso_id = _data['allocated_cso_id'];
            this.supplier = _data['supplier'];
        }
    }

    static fromJS(data: any): ConferenceForVhOfficerResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceForVhOfficerResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['scheduled_duration'] = this.scheduled_duration;
        data['status'] = this.status;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['started_date_time'] = this.started_date_time ? this.started_date_time.toISOString() : <any>undefined;
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['telephone_conference_id'] = this.telephone_conference_id;
        data['telephone_conference_numbers'] = this.telephone_conference_numbers;
        data['created_date_time'] = this.created_date_time ? this.created_date_time.toISOString() : <any>undefined;
        data['hearing_ref_id'] = this.hearing_ref_id;
        data['allocated_cso'] = this.allocated_cso;
        data['allocated_cso_id'] = this.allocated_cso_id;
        data['supplier'] = this.supplier;
        return data;
    }
}

export interface IConferenceForVhOfficerResponse {
    /** Conference ID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    /** The scheduled duration in minutes */
    scheduled_duration?: number;
    status?: ConferenceStatus;
    /** The conference participants */
    participants?: ParticipantForUserResponse[] | undefined;
    /** The name of the hearing venue */
    hearing_venue_name?: string | undefined;
    /** Started date time as UTC */
    started_date_time?: Date | undefined;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The telephone Id of the conference */
    telephone_conference_id?: string | undefined;
    /** The telephone conference number to dial */
    telephone_conference_numbers?: string | undefined;
    /** Created date time as UTC */
    created_date_time?: Date | undefined;
    /** Hearing Id for the vh-booking database */
    hearing_ref_id?: string;
    /** Allocated Cso Full name */
    allocated_cso?: string | undefined;
    /** Allocated Cso Id */
    allocated_cso_id?: string | undefined;
    supplier?: Supplier;
}

/** Detailed information about a conference */
export class ConferenceResponse implements IConferenceResponse {
    /** Conference ID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** Scheduled duration in minutes */
    scheduled_duration?: number;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** Has the countdown completed */
    countdown_completed?: boolean;
    /** The participant meeting room uri */
    participant_uri?: string | undefined;
    /** The pexip node to connect to */
    pexip_node_uri?: string | undefined;
    /** The pexip self-test node to connect to */
    pexip_self_test_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponse[] | undefined;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The name of venue */
    hearing_venue_name?: string | undefined;
    /** The options indicated hearing audio recording */
    audio_recording_required?: boolean;
    /** The hearing Id */
    hearing_ref_id?: string;
    /** The video access endpoints in the conference */
    endpoints?: VideoEndpointResponse[] | undefined;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;
    /** Property to indicate whether wowza recording is via single app setup or bespoke hearing setup */
    ingest_url?: string | undefined;
    supplier?: Supplier;
    /** Allocated Cso Full name */
    allocated_cso?: string | undefined;
    /** Allocated Cso Id */
    allocated_cso_id?: string | undefined;
    /** Allocated Cso Username */
    allocated_cso_username?: string | undefined;

    constructor(data?: IConferenceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.scheduled_date_time = _data['scheduled_date_time'] ? new Date(_data['scheduled_date_time'].toString()) : <any>undefined;
            this.scheduled_duration = _data['scheduled_duration'];
            this.case_type = _data['case_type'];
            this.case_number = _data['case_number'];
            this.case_name = _data['case_name'];
            this.status = _data['status'];
            this.countdown_completed = _data['countdown_completed'];
            this.participant_uri = _data['participant_uri'];
            this.pexip_node_uri = _data['pexip_node_uri'];
            this.pexip_self_test_node_uri = _data['pexip_self_test_node_uri'];
            if (Array.isArray(_data['participants'])) {
                this.participants = [] as any;
                for (let item of _data['participants']) this.participants!.push(ParticipantResponse.fromJS(item));
            }
            this.closed_date_time = _data['closed_date_time'] ? new Date(_data['closed_date_time'].toString()) : <any>undefined;
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.audio_recording_required = _data['audio_recording_required'];
            this.hearing_ref_id = _data['hearing_ref_id'];
            if (Array.isArray(_data['endpoints'])) {
                this.endpoints = [] as any;
                for (let item of _data['endpoints']) this.endpoints!.push(VideoEndpointResponse.fromJS(item));
            }
            this.hearing_venue_is_scottish = _data['hearing_venue_is_scottish'];
            this.ingest_url = _data['ingest_url'];
            this.supplier = _data['supplier'];
            this.allocated_cso = _data['allocated_cso'];
            this.allocated_cso_id = _data['allocated_cso_id'];
            this.allocated_cso_username = _data['allocated_cso_username'];
        }
    }

    static fromJS(data: any): ConferenceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ConferenceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['scheduled_date_time'] = this.scheduled_date_time ? this.scheduled_date_time.toISOString() : <any>undefined;
        data['scheduled_duration'] = this.scheduled_duration;
        data['case_type'] = this.case_type;
        data['case_number'] = this.case_number;
        data['case_name'] = this.case_name;
        data['status'] = this.status;
        data['countdown_completed'] = this.countdown_completed;
        data['participant_uri'] = this.participant_uri;
        data['pexip_node_uri'] = this.pexip_node_uri;
        data['pexip_self_test_node_uri'] = this.pexip_self_test_node_uri;
        if (Array.isArray(this.participants)) {
            data['participants'] = [];
            for (let item of this.participants) data['participants'].push(item.toJSON());
        }
        data['closed_date_time'] = this.closed_date_time ? this.closed_date_time.toISOString() : <any>undefined;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['audio_recording_required'] = this.audio_recording_required;
        data['hearing_ref_id'] = this.hearing_ref_id;
        if (Array.isArray(this.endpoints)) {
            data['endpoints'] = [];
            for (let item of this.endpoints) data['endpoints'].push(item.toJSON());
        }
        data['hearing_venue_is_scottish'] = this.hearing_venue_is_scottish;
        data['ingest_url'] = this.ingest_url;
        data['supplier'] = this.supplier;
        data['allocated_cso'] = this.allocated_cso;
        data['allocated_cso_id'] = this.allocated_cso_id;
        data['allocated_cso_username'] = this.allocated_cso_username;
        return data;
    }
}

/** Detailed information about a conference */
export interface IConferenceResponse {
    /** Conference ID */
    id?: string;
    /** Scheduled date time as UTC */
    scheduled_date_time?: Date;
    /** Scheduled duration in minutes */
    scheduled_duration?: number;
    /** The case type */
    case_type?: string | undefined;
    /** The case number */
    case_number?: string | undefined;
    /** The case name */
    case_name?: string | undefined;
    status?: ConferenceStatus;
    /** Has the countdown completed */
    countdown_completed?: boolean;
    /** The participant meeting room uri */
    participant_uri?: string | undefined;
    /** The pexip node to connect to */
    pexip_node_uri?: string | undefined;
    /** The pexip self-test node to connect to */
    pexip_self_test_node_uri?: string | undefined;
    /** The participants in the conference */
    participants?: ParticipantResponse[] | undefined;
    /** Closed date time as UTC */
    closed_date_time?: Date | undefined;
    /** The name of venue */
    hearing_venue_name?: string | undefined;
    /** The options indicated hearing audio recording */
    audio_recording_required?: boolean;
    /** The hearing Id */
    hearing_ref_id?: string;
    /** The video access endpoints in the conference */
    endpoints?: VideoEndpointResponse[] | undefined;
    /** Flags true when hearing venue is in Scotland */
    hearing_venue_is_scottish?: boolean;
    /** Property to indicate whether wowza recording is via single app setup or bespoke hearing setup */
    ingest_url?: string | undefined;
    supplier?: Supplier;
    /** Allocated Cso Full name */
    allocated_cso?: string | undefined;
    /** Allocated Cso Id */
    allocated_cso_id?: string | undefined;
    /** Allocated Cso Username */
    allocated_cso_username?: string | undefined;
}

export class HeartbeatConfigurationResponse implements IHeartbeatConfigurationResponse {
    heartbeat_url_base?: string | undefined;
    heartbeat_jwt?: string | undefined;

    constructor(data?: IHeartbeatConfigurationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.heartbeat_url_base = _data['heartbeat_url_base'];
            this.heartbeat_jwt = _data['heartbeat_jwt'];
        }
    }

    static fromJS(data: any): HeartbeatConfigurationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HeartbeatConfigurationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['heartbeat_url_base'] = this.heartbeat_url_base;
        data['heartbeat_jwt'] = this.heartbeat_jwt;
        return data;
    }
}

export interface IHeartbeatConfigurationResponse {
    heartbeat_url_base?: string | undefined;
    heartbeat_jwt?: string | undefined;
}

export class IdpSettingsResponse implements IIdpSettingsResponse {
    /** The IDP Config ID (used to identify the IDP by the UI) */
    config_id?: string | undefined;
    /** The Azure Tenant Id */
    tenant_id?: string | undefined;
    /** The UI Client Id */
    client_id?: string | undefined;
    /** The UI Resource Id, can be used as an alternative id to ClientId for authentication */
    resource_id?: string | undefined;
    /** The Uri to redirect back to after a successful login */
    redirect_uri?: string | undefined;
    /** The Uri to redirect back to after a successful logout */
    post_logout_redirect_uri?: string | undefined;

    constructor(data?: IIdpSettingsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.config_id = _data['config_id'];
            this.tenant_id = _data['tenant_id'];
            this.client_id = _data['client_id'];
            this.resource_id = _data['resource_id'];
            this.redirect_uri = _data['redirect_uri'];
            this.post_logout_redirect_uri = _data['post_logout_redirect_uri'];
        }
    }

    static fromJS(data: any): IdpSettingsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new IdpSettingsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['config_id'] = this.config_id;
        data['tenant_id'] = this.tenant_id;
        data['client_id'] = this.client_id;
        data['resource_id'] = this.resource_id;
        data['redirect_uri'] = this.redirect_uri;
        data['post_logout_redirect_uri'] = this.post_logout_redirect_uri;
        return data;
    }
}

export interface IIdpSettingsResponse {
    /** The IDP Config ID (used to identify the IDP by the UI) */
    config_id?: string | undefined;
    /** The Azure Tenant Id */
    tenant_id?: string | undefined;
    /** The UI Client Id */
    client_id?: string | undefined;
    /** The UI Resource Id, can be used as an alternative id to ClientId for authentication */
    resource_id?: string | undefined;
    /** The Uri to redirect back to after a successful login */
    redirect_uri?: string | undefined;
    /** The Uri to redirect back to after a successful logout */
    post_logout_redirect_uri?: string | undefined;
}

export class InterpreterLanguageResponse implements IInterpreterLanguageResponse {
    code?: string | undefined;
    description?: string | undefined;
    type?: InterpreterType;

    constructor(data?: IInterpreterLanguageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data['code'];
            this.description = _data['description'];
            this.type = _data['type'];
        }
    }

    static fromJS(data: any): InterpreterLanguageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InterpreterLanguageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['code'] = this.code;
        data['description'] = this.description;
        data['type'] = this.type;
        return data;
    }
}

export interface IInterpreterLanguageResponse {
    code?: string | undefined;
    description?: string | undefined;
    type?: InterpreterType;
}

export enum InterpreterType {
    Sign = 'Sign',
    Verbal = 'Verbal'
}

export class LinkedParticipantResponse implements ILinkedParticipantResponse {
    /** The id of the participant linked to */
    linked_id?: string;
    link_type?: LinkType;

    constructor(data?: ILinkedParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linked_id = _data['linked_id'];
            this.link_type = _data['link_type'];
        }
    }

    static fromJS(data: any): LinkedParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['linked_id'] = this.linked_id;
        data['link_type'] = this.link_type;
        return data;
    }
}

export interface ILinkedParticipantResponse {
    /** The id of the participant linked to */
    linked_id?: string;
    link_type?: LinkType;
}

export class LoggedParticipantResponse implements ILoggedParticipantResponse {
    participant_id?: string;
    admin_username?: string | undefined;
    role?: Role;
    display_name?: string | undefined;

    constructor(data?: ILoggedParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participant_id = _data['participant_id'];
            this.admin_username = _data['admin_username'];
            this.role = _data['role'];
            this.display_name = _data['display_name'];
        }
    }

    static fromJS(data: any): LoggedParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoggedParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['participant_id'] = this.participant_id;
        data['admin_username'] = this.admin_username;
        data['role'] = this.role;
        data['display_name'] = this.display_name;
        return data;
    }
}

export interface ILoggedParticipantResponse {
    participant_id?: string;
    admin_username?: string | undefined;
    role?: Role;
    display_name?: string | undefined;
}

export class ParticipantContactDetailsResponseVho implements IParticipantContactDetailsResponseVho {
    /** The participant id in a conference */
    id?: string;
    /** The conference id */
    conference_id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    role?: Role;
    /** The participant's hearing role */
    hearing_role?: string | undefined;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The participant hearing ref id in a booking */
    ref_id?: string;
    /** The participant's first name */
    first_name?: string | undefined;
    /** The participant's last name */
    last_name?: string | undefined;
    /** The participant's contact email */
    contact_email?: string | undefined;
    /** The participant's contact telephone number */
    contact_telephone?: string | undefined;
    /** The hearing venue this participant is assigned to */
    hearing_venue_name?: string | undefined;
    /** The Host is In Another Hearing */
    host_in_another_hearing?: boolean;
    /** The participant represented by the representative */
    representee?: string | undefined;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;

    constructor(data?: IParticipantContactDetailsResponseVho) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.conference_id = _data['conference_id'];
            this.name = _data['name'];
            this.username = _data['username'];
            this.role = _data['role'];
            this.hearing_role = _data['hearing_role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.ref_id = _data['ref_id'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.contact_email = _data['contact_email'];
            this.contact_telephone = _data['contact_telephone'];
            this.hearing_venue_name = _data['hearing_venue_name'];
            this.host_in_another_hearing = _data['host_in_another_hearing'];
            this.representee = _data['representee'];
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ParticipantContactDetailsResponseVho {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantContactDetailsResponseVho();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['conference_id'] = this.conference_id;
        data['name'] = this.name;
        data['username'] = this.username;
        data['role'] = this.role;
        data['hearing_role'] = this.hearing_role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['ref_id'] = this.ref_id;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['contact_email'] = this.contact_email;
        data['contact_telephone'] = this.contact_telephone;
        data['hearing_venue_name'] = this.hearing_venue_name;
        data['host_in_another_hearing'] = this.host_in_another_hearing;
        data['representee'] = this.representee;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        return data;
    }
}

export interface IParticipantContactDetailsResponseVho {
    /** The participant id in a conference */
    id?: string;
    /** The conference id */
    conference_id?: string;
    /** The participant's full name */
    name?: string | undefined;
    /** The participant's username */
    username?: string | undefined;
    role?: Role;
    /** The participant's hearing role */
    hearing_role?: string | undefined;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The participant hearing ref id in a booking */
    ref_id?: string;
    /** The participant's first name */
    first_name?: string | undefined;
    /** The participant's last name */
    last_name?: string | undefined;
    /** The participant's contact email */
    contact_email?: string | undefined;
    /** The participant's contact telephone number */
    contact_telephone?: string | undefined;
    /** The hearing venue this participant is assigned to */
    hearing_venue_name?: string | undefined;
    /** The Host is In Another Hearing */
    host_in_another_hearing?: boolean;
    /** The participant represented by the representative */
    representee?: string | undefined;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;
}

export class ParticipantForHostResponse implements IParticipantForHostResponse {
    /** The participant Id */
    id?: string;
    /** The participant display name during a conference */
    display_name?: string | undefined;
    role?: Role;

    constructor(data?: IParticipantForHostResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.display_name = _data['display_name'];
            this.role = _data['role'];
        }
    }

    static fromJS(data: any): ParticipantForHostResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantForHostResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['display_name'] = this.display_name;
        data['role'] = this.role;
        return data;
    }
}

export interface IParticipantForHostResponse {
    /** The participant Id */
    id?: string;
    /** The participant display name during a conference */
    display_name?: string | undefined;
    role?: Role;
}

export class ParticipantForUserResponse implements IParticipantForUserResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    role?: Role;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The tiled display name (the fixed tile location, display name and UUID) */
    tiled_display_name?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    /** The first name of the participant */
    first_name?: string | undefined;
    /** The last name of the participant */
    last_name?: string | undefined;
    /** The hearing role */
    hearing_role?: string | undefined;
    /** The User Name */
    user_name?: string | undefined;
    current_room?: RoomSummaryResponse;
    interpreter_room?: RoomSummaryResponse;
    interpreter_language?: InterpreterLanguageResponse;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;
    /** A unique identifier for the participant (used by special measures) */
    external_reference_id?: string | undefined;
    /** List of external references to protect this participant from */
    protect_from?: string[] | undefined;

    constructor(data?: IParticipantForUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.representee = _data['representee'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.hearing_role = _data['hearing_role'];
            this.user_name = _data['user_name'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
            this.interpreter_room = _data['interpreter_room'] ? RoomSummaryResponse.fromJS(_data['interpreter_room']) : <any>undefined;
            this.interpreter_language = _data['interpreter_language']
                ? InterpreterLanguageResponse.fromJS(_data['interpreter_language'])
                : <any>undefined;
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
            this.external_reference_id = _data['external_reference_id'];
            if (Array.isArray(_data['protect_from'])) {
                this.protect_from = [] as any;
                for (let item of _data['protect_from']) this.protect_from!.push(item);
            }
        }
    }

    static fromJS(data: any): ParticipantForUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantForUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['representee'] = this.representee;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['hearing_role'] = this.hearing_role;
        data['user_name'] = this.user_name;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        data['interpreter_room'] = this.interpreter_room ? this.interpreter_room.toJSON() : <any>undefined;
        data['interpreter_language'] = this.interpreter_language ? this.interpreter_language.toJSON() : <any>undefined;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        data['external_reference_id'] = this.external_reference_id;
        if (Array.isArray(this.protect_from)) {
            data['protect_from'] = [];
            for (let item of this.protect_from) data['protect_from'].push(item);
        }
        return data;
    }
}

export interface IParticipantForUserResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    role?: Role;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The tiled display name (the fixed tile location, display name and UUID) */
    tiled_display_name?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    /** The first name of the participant */
    first_name?: string | undefined;
    /** The last name of the participant */
    last_name?: string | undefined;
    /** The hearing role */
    hearing_role?: string | undefined;
    /** The User Name */
    user_name?: string | undefined;
    current_room?: RoomSummaryResponse;
    interpreter_room?: RoomSummaryResponse;
    interpreter_language?: InterpreterLanguageResponse;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;
    /** A unique identifier for the participant (used by special measures) */
    external_reference_id?: string | undefined;
    /** List of external references to protect this participant from */
    protect_from?: string[] | undefined;
}

/** Information about a participant in a conference */
export class ParticipantResponse implements IParticipantResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    role?: Role;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The tiled display name (the fixed tile location, display name and UUID) */
    tiled_display_name?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    /** The first name of the participant */
    first_name?: string | undefined;
    /** The last name of the participant */
    last_name?: string | undefined;
    /** The hearing role */
    hearing_role?: string | undefined;
    /** The User Name */
    user_name?: string | undefined;
    current_room?: RoomSummaryResponse;
    interpreter_room?: RoomSummaryResponse;
    interpreter_language?: InterpreterLanguageResponse;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;
    /** A unique identifier for the participant (used by special measures) */
    external_reference_id?: string | undefined;
    /** List of external references to protect this participant from */
    protect_from?: string[] | undefined;

    constructor(data?: IParticipantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.name = _data['name'];
            this.role = _data['role'];
            this.status = _data['status'];
            this.display_name = _data['display_name'];
            this.tiled_display_name = _data['tiled_display_name'];
            this.representee = _data['representee'];
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.hearing_role = _data['hearing_role'];
            this.user_name = _data['user_name'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
            this.interpreter_room = _data['interpreter_room'] ? RoomSummaryResponse.fromJS(_data['interpreter_room']) : <any>undefined;
            this.interpreter_language = _data['interpreter_language']
                ? InterpreterLanguageResponse.fromJS(_data['interpreter_language'])
                : <any>undefined;
            if (Array.isArray(_data['linked_participants'])) {
                this.linked_participants = [] as any;
                for (let item of _data['linked_participants']) this.linked_participants!.push(LinkedParticipantResponse.fromJS(item));
            }
            this.external_reference_id = _data['external_reference_id'];
            if (Array.isArray(_data['protect_from'])) {
                this.protect_from = [] as any;
                for (let item of _data['protect_from']) this.protect_from!.push(item);
            }
        }
    }

    static fromJS(data: any): ParticipantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ParticipantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['name'] = this.name;
        data['role'] = this.role;
        data['status'] = this.status;
        data['display_name'] = this.display_name;
        data['tiled_display_name'] = this.tiled_display_name;
        data['representee'] = this.representee;
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['hearing_role'] = this.hearing_role;
        data['user_name'] = this.user_name;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        data['interpreter_room'] = this.interpreter_room ? this.interpreter_room.toJSON() : <any>undefined;
        data['interpreter_language'] = this.interpreter_language ? this.interpreter_language.toJSON() : <any>undefined;
        if (Array.isArray(this.linked_participants)) {
            data['linked_participants'] = [];
            for (let item of this.linked_participants) data['linked_participants'].push(item.toJSON());
        }
        data['external_reference_id'] = this.external_reference_id;
        if (Array.isArray(this.protect_from)) {
            data['protect_from'] = [];
            for (let item of this.protect_from) data['protect_from'].push(item);
        }
        return data;
    }
}

/** Information about a participant in a conference */
export interface IParticipantResponse {
    /** The participant id in a conference */
    id?: string;
    /** The participant's full name */
    name?: string | undefined;
    role?: Role;
    status?: ParticipantStatus;
    /** The participant's display name */
    display_name?: string | undefined;
    /** The tiled display name (the fixed tile location, display name and UUID) */
    tiled_display_name?: string | undefined;
    /** The representee the participant is acting on behalf */
    representee?: string | undefined;
    /** The first name of the participant */
    first_name?: string | undefined;
    /** The last name of the participant */
    last_name?: string | undefined;
    /** The hearing role */
    hearing_role?: string | undefined;
    /** The User Name */
    user_name?: string | undefined;
    current_room?: RoomSummaryResponse;
    interpreter_room?: RoomSummaryResponse;
    interpreter_language?: InterpreterLanguageResponse;
    /** List of participants linked this participant */
    linked_participants?: LinkedParticipantResponse[] | undefined;
    /** A unique identifier for the participant (used by special measures) */
    external_reference_id?: string | undefined;
    /** List of external references to protect this participant from */
    protect_from?: string[] | undefined;
}

export class QuickLinkParticipantJoinResponse implements IQuickLinkParticipantJoinResponse {
    jwt?: string | undefined;

    constructor(data?: IQuickLinkParticipantJoinResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jwt = _data['jwt'];
        }
    }

    static fromJS(data: any): QuickLinkParticipantJoinResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuickLinkParticipantJoinResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['jwt'] = this.jwt;
        return data;
    }
}

export interface IQuickLinkParticipantJoinResponse {
    jwt?: string | undefined;
}

export class RoomSummaryResponse implements IRoomSummaryResponse {
    /** Room Id */
    id?: string | undefined;
    /** Room label */
    label?: string | undefined;
    /** Is the room locked */
    locked?: boolean;

    constructor(data?: IRoomSummaryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.label = _data['label'];
            this.locked = _data['locked'];
        }
    }

    static fromJS(data: any): RoomSummaryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RoomSummaryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['label'] = this.label;
        data['locked'] = this.locked;
        return data;
    }
}

export interface IRoomSummaryResponse {
    /** Room Id */
    id?: string | undefined;
    /** Room label */
    label?: string | undefined;
    /** Is the room locked */
    locked?: boolean;
}

export class SelfTestPexipResponse implements ISelfTestPexipResponse {
    pexip_self_test_node?: string | undefined;

    constructor(data?: ISelfTestPexipResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pexip_self_test_node = _data['pexip_self_test_node'];
        }
    }

    static fromJS(data: any): SelfTestPexipResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SelfTestPexipResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['pexip_self_test_node'] = this.pexip_self_test_node;
        return data;
    }
}

export interface ISelfTestPexipResponse {
    pexip_self_test_node?: string | undefined;
}

export class SupplierConfigurationResponse implements ISupplierConfigurationResponse {
    supplier?: Supplier;
    /** The date to set option ON to display functionality to join hearing by phone */
    join_by_phone_from_date?: string | undefined;
    /** The turn server */
    turn_server?: string | undefined;
    /** The turn server username */
    turn_server_user?: string | undefined;
    /** The turn server password */
    turn_server_credential?: string | undefined;

    constructor(data?: ISupplierConfigurationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplier = _data['supplier'];
            this.join_by_phone_from_date = _data['join_by_phone_from_date'];
            this.turn_server = _data['turn_server'];
            this.turn_server_user = _data['turn_server_user'];
            this.turn_server_credential = _data['turn_server_credential'];
        }
    }

    static fromJS(data: any): SupplierConfigurationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierConfigurationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['supplier'] = this.supplier;
        data['join_by_phone_from_date'] = this.join_by_phone_from_date;
        data['turn_server'] = this.turn_server;
        data['turn_server_user'] = this.turn_server_user;
        data['turn_server_credential'] = this.turn_server_credential;
        return data;
    }
}

export interface ISupplierConfigurationResponse {
    supplier?: Supplier;
    /** The date to set option ON to display functionality to join hearing by phone */
    join_by_phone_from_date?: string | undefined;
    /** The turn server */
    turn_server?: string | undefined;
    /** The turn server username */
    turn_server_user?: string | undefined;
    /** The turn server password */
    turn_server_credential?: string | undefined;
}

export class TokenResponse implements ITokenResponse {
    expires_on?: string | undefined;
    token?: string | undefined;

    constructor(data?: ITokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expires_on = _data['expires_on'];
            this.token = _data['token'];
        }
    }

    static fromJS(data: any): TokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['expires_on'] = this.expires_on;
        data['token'] = this.token;
        return data;
    }
}

export interface ITokenResponse {
    expires_on?: string | undefined;
    token?: string | undefined;
}

export class UnreadAdminMessageResponse implements IUnreadAdminMessageResponse {
    participant_username?: string | undefined;
    number_of_unread_messages?: number;
    participant_id?: string;

    constructor(data?: IUnreadAdminMessageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.participant_username = _data['participant_username'];
            this.number_of_unread_messages = _data['number_of_unread_messages'];
            this.participant_id = _data['participant_id'];
        }
    }

    static fromJS(data: any): UnreadAdminMessageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnreadAdminMessageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['participant_username'] = this.participant_username;
        data['number_of_unread_messages'] = this.number_of_unread_messages;
        data['participant_id'] = this.participant_id;
        return data;
    }
}

export interface IUnreadAdminMessageResponse {
    participant_username?: string | undefined;
    number_of_unread_messages?: number;
    participant_id?: string;
}

export class UnreadInstantMessageConferenceCountResponse implements IUnreadInstantMessageConferenceCountResponse {
    number_of_unread_messages_conference?: UnreadAdminMessageResponse[] | undefined;

    constructor(data?: IUnreadInstantMessageConferenceCountResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['number_of_unread_messages_conference'])) {
                this.number_of_unread_messages_conference = [] as any;
                for (let item of _data['number_of_unread_messages_conference'])
                    this.number_of_unread_messages_conference!.push(UnreadAdminMessageResponse.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UnreadInstantMessageConferenceCountResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UnreadInstantMessageConferenceCountResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.number_of_unread_messages_conference)) {
            data['number_of_unread_messages_conference'] = [];
            for (let item of this.number_of_unread_messages_conference) data['number_of_unread_messages_conference'].push(item.toJSON());
        }
        return data;
    }
}

export interface IUnreadInstantMessageConferenceCountResponse {
    number_of_unread_messages_conference?: UnreadAdminMessageResponse[] | undefined;
}

export class UserProfileResponse implements IUserProfileResponse {
    roles?: Role[] | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    username?: string | undefined;
    name?: string | undefined;

    constructor(data?: IUserProfileResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data['roles'])) {
                this.roles = [] as any;
                for (let item of _data['roles']) this.roles!.push(item);
            }
            this.first_name = _data['first_name'];
            this.last_name = _data['last_name'];
            this.display_name = _data['display_name'];
            this.username = _data['username'];
            this.name = _data['name'];
        }
    }

    static fromJS(data: any): UserProfileResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data['roles'] = [];
            for (let item of this.roles) data['roles'].push(item);
        }
        data['first_name'] = this.first_name;
        data['last_name'] = this.last_name;
        data['display_name'] = this.display_name;
        data['username'] = this.username;
        data['name'] = this.name;
        return data;
    }
}

export interface IUserProfileResponse {
    roles?: Role[] | undefined;
    first_name?: string | undefined;
    last_name?: string | undefined;
    display_name?: string | undefined;
    username?: string | undefined;
    name?: string | undefined;
}

export class VideoEndpointResponse implements IVideoEndpointResponse {
    /** The endpoint id */
    id?: string;
    /** The endpoint display name */
    display_name?: string | undefined;
    status?: EndpointStatus;
    /** The current endpoint status */
    participants_linked?: string[] | undefined;
    /** The display name when connected to the pexip node */
    pexip_display_name?: string | undefined;
    is_current_user?: boolean;
    current_room?: RoomSummaryResponse;
    interpreter_language?: InterpreterLanguageResponse;
    /** A unique identifier for the participant (used by special measures) */
    external_reference_id?: string | undefined;
    /** List of external references to protect this participant from */
    protect_from?: string[] | undefined;

    constructor(data?: IVideoEndpointResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data['id'];
            this.display_name = _data['display_name'];
            this.status = _data['status'];
            if (Array.isArray(_data['participants_linked'])) {
                this.participants_linked = [] as any;
                for (let item of _data['participants_linked']) this.participants_linked!.push(item);
            }
            this.pexip_display_name = _data['pexip_display_name'];
            this.is_current_user = _data['is_current_user'];
            this.current_room = _data['current_room'] ? RoomSummaryResponse.fromJS(_data['current_room']) : <any>undefined;
            this.interpreter_language = _data['interpreter_language']
                ? InterpreterLanguageResponse.fromJS(_data['interpreter_language'])
                : <any>undefined;
            this.external_reference_id = _data['external_reference_id'];
            if (Array.isArray(_data['protect_from'])) {
                this.protect_from = [] as any;
                for (let item of _data['protect_from']) this.protect_from!.push(item);
            }
        }
    }

    static fromJS(data: any): VideoEndpointResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VideoEndpointResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data['id'] = this.id;
        data['display_name'] = this.display_name;
        data['status'] = this.status;
        if (Array.isArray(this.participants_linked)) {
            data['participants_linked'] = [];
            for (let item of this.participants_linked) data['participants_linked'].push(item);
        }
        data['pexip_display_name'] = this.pexip_display_name;
        data['is_current_user'] = this.is_current_user;
        data['current_room'] = this.current_room ? this.current_room.toJSON() : <any>undefined;
        data['interpreter_language'] = this.interpreter_language ? this.interpreter_language.toJSON() : <any>undefined;
        data['external_reference_id'] = this.external_reference_id;
        if (Array.isArray(this.protect_from)) {
            data['protect_from'] = [];
            for (let item of this.protect_from) data['protect_from'].push(item);
        }
        return data;
    }
}

export interface IVideoEndpointResponse {
    /** The endpoint id */
    id?: string;
    /** The endpoint display name */
    display_name?: string | undefined;
    status?: EndpointStatus;
    /** The current endpoint status */
    participants_linked?: string[] | undefined;
    /** The display name when connected to the pexip node */
    pexip_display_name?: string | undefined;
    is_current_user?: boolean;
    current_room?: RoomSummaryResponse;
    interpreter_language?: InterpreterLanguageResponse;
    /** A unique identifier for the participant (used by special measures) */
    external_reference_id?: string | undefined;
    /** List of external references to protect this participant from */
    protect_from?: string[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any }, result?: any): Observable<any> {
    if (result !== null && result !== undefined) return _observableThrow(result);
    else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next('');
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
